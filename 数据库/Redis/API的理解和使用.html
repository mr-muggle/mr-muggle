<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>API的理解和使用 | Knowledge</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/mr-mugglefavicon.ico">
    <meta name="description" content="talk is cheap show me the code">
    <link rel="preload" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css" as="style"><link rel="preload" href="/mr-muggle/assets/js/app.03b0f33a.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/2.c49e4524.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/30.98fcced0.js" as="script"><link rel="prefetch" href="/mr-muggle/assets/js/10.b769111d.js"><link rel="prefetch" href="/mr-muggle/assets/js/11.3b528e8b.js"><link rel="prefetch" href="/mr-muggle/assets/js/12.262bc424.js"><link rel="prefetch" href="/mr-muggle/assets/js/13.701f9444.js"><link rel="prefetch" href="/mr-muggle/assets/js/14.f5836d8f.js"><link rel="prefetch" href="/mr-muggle/assets/js/15.f6ae0270.js"><link rel="prefetch" href="/mr-muggle/assets/js/16.88f016bf.js"><link rel="prefetch" href="/mr-muggle/assets/js/17.2cb6dc15.js"><link rel="prefetch" href="/mr-muggle/assets/js/18.190ccd99.js"><link rel="prefetch" href="/mr-muggle/assets/js/19.5b842041.js"><link rel="prefetch" href="/mr-muggle/assets/js/20.23e5f14f.js"><link rel="prefetch" href="/mr-muggle/assets/js/21.76eb19cf.js"><link rel="prefetch" href="/mr-muggle/assets/js/22.9a998e87.js"><link rel="prefetch" href="/mr-muggle/assets/js/23.d79bc80a.js"><link rel="prefetch" href="/mr-muggle/assets/js/24.68b1ece9.js"><link rel="prefetch" href="/mr-muggle/assets/js/25.0536eb3c.js"><link rel="prefetch" href="/mr-muggle/assets/js/26.e1e22d1b.js"><link rel="prefetch" href="/mr-muggle/assets/js/27.10fbd948.js"><link rel="prefetch" href="/mr-muggle/assets/js/28.9d8bf67a.js"><link rel="prefetch" href="/mr-muggle/assets/js/29.959e32d1.js"><link rel="prefetch" href="/mr-muggle/assets/js/3.4c2c33d8.js"><link rel="prefetch" href="/mr-muggle/assets/js/31.c3717be1.js"><link rel="prefetch" href="/mr-muggle/assets/js/32.04594faa.js"><link rel="prefetch" href="/mr-muggle/assets/js/33.cbdbae4d.js"><link rel="prefetch" href="/mr-muggle/assets/js/34.112b9f11.js"><link rel="prefetch" href="/mr-muggle/assets/js/35.b52ec603.js"><link rel="prefetch" href="/mr-muggle/assets/js/36.6a59af48.js"><link rel="prefetch" href="/mr-muggle/assets/js/37.7974b0c2.js"><link rel="prefetch" href="/mr-muggle/assets/js/38.f998387a.js"><link rel="prefetch" href="/mr-muggle/assets/js/39.89abf77c.js"><link rel="prefetch" href="/mr-muggle/assets/js/4.8c3e511b.js"><link rel="prefetch" href="/mr-muggle/assets/js/40.ec4c57c4.js"><link rel="prefetch" href="/mr-muggle/assets/js/41.ef41848b.js"><link rel="prefetch" href="/mr-muggle/assets/js/42.8538a508.js"><link rel="prefetch" href="/mr-muggle/assets/js/43.c712f5fa.js"><link rel="prefetch" href="/mr-muggle/assets/js/44.7e2435a1.js"><link rel="prefetch" href="/mr-muggle/assets/js/45.633f2d43.js"><link rel="prefetch" href="/mr-muggle/assets/js/46.1bd7c05d.js"><link rel="prefetch" href="/mr-muggle/assets/js/47.e5df90ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/48.cd6c7156.js"><link rel="prefetch" href="/mr-muggle/assets/js/49.90631ebb.js"><link rel="prefetch" href="/mr-muggle/assets/js/5.6834c560.js"><link rel="prefetch" href="/mr-muggle/assets/js/50.9f214f89.js"><link rel="prefetch" href="/mr-muggle/assets/js/51.99a8dd78.js"><link rel="prefetch" href="/mr-muggle/assets/js/52.aec5051a.js"><link rel="prefetch" href="/mr-muggle/assets/js/53.7b621de8.js"><link rel="prefetch" href="/mr-muggle/assets/js/54.aa323f86.js"><link rel="prefetch" href="/mr-muggle/assets/js/55.63b233d9.js"><link rel="prefetch" href="/mr-muggle/assets/js/56.2cc8fe7b.js"><link rel="prefetch" href="/mr-muggle/assets/js/57.2a7a35c6.js"><link rel="prefetch" href="/mr-muggle/assets/js/58.3ef9ff2d.js"><link rel="prefetch" href="/mr-muggle/assets/js/59.4194402f.js"><link rel="prefetch" href="/mr-muggle/assets/js/6.ad05d8e5.js"><link rel="prefetch" href="/mr-muggle/assets/js/60.01275a59.js"><link rel="prefetch" href="/mr-muggle/assets/js/61.d314066d.js"><link rel="prefetch" href="/mr-muggle/assets/js/62.68ce6bc5.js"><link rel="prefetch" href="/mr-muggle/assets/js/63.34dea9e0.js"><link rel="prefetch" href="/mr-muggle/assets/js/64.9aaf5e00.js"><link rel="prefetch" href="/mr-muggle/assets/js/65.e4ce25ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/66.5d9f1db5.js"><link rel="prefetch" href="/mr-muggle/assets/js/67.c914fc65.js"><link rel="prefetch" href="/mr-muggle/assets/js/68.5ee52c48.js"><link rel="prefetch" href="/mr-muggle/assets/js/69.680accb1.js"><link rel="prefetch" href="/mr-muggle/assets/js/7.0c092304.js"><link rel="prefetch" href="/mr-muggle/assets/js/70.cf4408b5.js"><link rel="prefetch" href="/mr-muggle/assets/js/71.33ad3ca9.js"><link rel="prefetch" href="/mr-muggle/assets/js/72.87880929.js"><link rel="prefetch" href="/mr-muggle/assets/js/73.11b998f6.js"><link rel="prefetch" href="/mr-muggle/assets/js/74.5a75b187.js"><link rel="prefetch" href="/mr-muggle/assets/js/75.5301781a.js"><link rel="prefetch" href="/mr-muggle/assets/js/76.c446bc20.js"><link rel="prefetch" href="/mr-muggle/assets/js/77.4eaa9052.js"><link rel="prefetch" href="/mr-muggle/assets/js/78.3b98b54f.js"><link rel="prefetch" href="/mr-muggle/assets/js/79.60b9a9ba.js"><link rel="prefetch" href="/mr-muggle/assets/js/8.471386f2.js"><link rel="prefetch" href="/mr-muggle/assets/js/80.7b067e03.js"><link rel="prefetch" href="/mr-muggle/assets/js/81.8274f49e.js"><link rel="prefetch" href="/mr-muggle/assets/js/82.b72070ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/83.4651609d.js"><link rel="prefetch" href="/mr-muggle/assets/js/84.fffdd780.js"><link rel="prefetch" href="/mr-muggle/assets/js/85.10865df0.js"><link rel="prefetch" href="/mr-muggle/assets/js/86.5b4b0452.js"><link rel="prefetch" href="/mr-muggle/assets/js/87.a270ec2b.js"><link rel="prefetch" href="/mr-muggle/assets/js/88.8bb08b0f.js"><link rel="prefetch" href="/mr-muggle/assets/js/89.3826a944.js"><link rel="prefetch" href="/mr-muggle/assets/js/9.d8124a2e.js"><link rel="prefetch" href="/mr-muggle/assets/js/90.dbf7dede.js"><link rel="prefetch" href="/mr-muggle/assets/js/91.0823b62f.js"><link rel="prefetch" href="/mr-muggle/assets/js/92.8ec406ed.js">
    <link rel="stylesheet" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-6 ant-col-xl-5 ant-col-xxl-4"><a href="/mr-muggle/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Knowledge</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="nav-space-between ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-18 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mr-muggle/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          后端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          前端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          数据库
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          消息队列
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          搜索引擎
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          项目部署与运维
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          办公软件
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <ul class="extra-group"><!----> <!----></ul></nav></div></div> <!----></header> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/mr-muggle/数据库/Redis/初识Redis.html" title="初识 Redis" class="sidebar-link">初识 Redis</a></li><li><a href="/mr-muggle/数据库/Redis/API的理解和使用.html" title="API的理解和使用" class="active sidebar-link">API的理解和使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#全局命令" title="全局命令" class="sidebar-link">全局命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#keys-查看所有键" title="keys-查看所有键" class="sidebar-link">keys-查看所有键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#dbsize-统计键总数" title="dbsize-统计键总数" class="sidebar-link">dbsize-统计键总数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#exists-检查键是否存在" title="exists-检查键是否存在" class="sidebar-link">exists-检查键是否存在</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#del-删除键" title="del-删除键" class="sidebar-link">del-删除键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#expire-键过期" title="expire-键过期" class="sidebar-link">expire-键过期</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#type-返回键的数据结构类型" title="type-返回键的数据结构类型" class="sidebar-link">type-返回键的数据结构类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#数据结构和内部编码" title="数据结构和内部编码" class="sidebar-link">数据结构和内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis的单线程架构" title="Redis的单线程架构" class="sidebar-link">Redis的单线程架构</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis数据结构-字符串" title="Redis数据结构-字符串" class="sidebar-link">Redis数据结构-字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-设置值" title="常用命令-设置值" class="sidebar-link">常用命令-设置值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-获取值" title="常用命令-获取值" class="sidebar-link">常用命令-获取值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-计数" title="常用命令-计数" class="sidebar-link">常用命令-计数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#不常用命令-追加值" title="不常用命令-追加值" class="sidebar-link">不常用命令-追加值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#不常用命令-计算字符串长度" title="不常用命令-计算字符串长度" class="sidebar-link">不常用命令-计算字符串长度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#不常用命令-设置并返回原值" title="不常用命令-设置并返回原值" class="sidebar-link">不常用命令-设置并返回原值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#不常用命令-设置指定位置的字符" title="不常用命令-设置指定位置的字符" class="sidebar-link">不常用命令-设置指定位置的字符</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#不常用命令-获取部分字符串" title="不常用命令-获取部分字符串" class="sidebar-link">不常用命令-获取部分字符串</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#字符串类型命令时间复杂度" title="字符串类型命令时间复杂度" class="sidebar-link">字符串类型命令时间复杂度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#字符串类型的内部编码" title="字符串类型的内部编码" class="sidebar-link">字符串类型的内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#字符串的典型应用场景" title="字符串的典型应用场景" class="sidebar-link">字符串的典型应用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis数据结构-哈希" title="Redis数据结构-哈希" class="sidebar-link">Redis数据结构-哈希</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-设置值-2" title="常用命令-设置值" class="sidebar-link">常用命令-设置值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-获取值-2" title="常用命令-获取值" class="sidebar-link">常用命令-获取值</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-删除field" title="常用命令-删除field" class="sidebar-link">常用命令-删除field</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-计算field个数" title="常用命令-计算field个数" class="sidebar-link">常用命令-计算field个数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-批量设置或获取field-value" title="常用命令-批量设置或获取field-value" class="sidebar-link">常用命令-批量设置或获取field-value</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-判断field是否存在" title="常用命令-判断field是否存在" class="sidebar-link">常用命令-判断field是否存在</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-获取所有field" title="常用命令-获取所有field" class="sidebar-link">常用命令-获取所有field</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-获取所有value" title="常用命令-获取所有value" class="sidebar-link">常用命令-获取所有value</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-获取所有的field-value" title="常用命令-获取所有的field-value" class="sidebar-link">常用命令-获取所有的field-value</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-计数-2" title="常用命令-计数" class="sidebar-link">常用命令-计数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-计算value的字符串长度" title="常用命令-计算value的字符串长度" class="sidebar-link">常用命令-计算value的字符串长度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#哈希命令类型的时间复杂度" title="哈希命令类型的时间复杂度" class="sidebar-link">哈希命令类型的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#哈希类型的内部编码" title="哈希类型的内部编码" class="sidebar-link">哈希类型的内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#哈希的使用场景" title="哈希的使用场景" class="sidebar-link">哈希的使用场景</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#三种缓存用户信息的优缺点" title="三种缓存用户信息的优缺点" class="sidebar-link">三种缓存用户信息的优缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis数据结构-列表" title="Redis数据结构-列表" class="sidebar-link">Redis数据结构-列表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表的主要特点" title="列表的主要特点" class="sidebar-link">列表的主要特点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表的四种操作类型" title="列表的四种操作类型" class="sidebar-link">列表的四种操作类型</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-添加" title="常用命令-添加" class="sidebar-link">常用命令-添加</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-查找" title="常用命令-查找" class="sidebar-link">常用命令-查找</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-删除" title="常用命令-删除" class="sidebar-link">常用命令-删除</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#常用命令-阻塞操作" title="常用命令-阻塞操作" class="sidebar-link">常用命令-阻塞操作</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表命令时间复杂度" title="列表命令时间复杂度" class="sidebar-link">列表命令时间复杂度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表类型的内部编码" title="列表类型的内部编码" class="sidebar-link">列表类型的内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表的使用场景" title="列表的使用场景" class="sidebar-link">列表的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis数据结构-集合" title="Redis数据结构-集合" class="sidebar-link">Redis数据结构-集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-添加元素" title="集合内操作-添加元素" class="sidebar-link">集合内操作-添加元素</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-删除元素" title="集合内操作-删除元素" class="sidebar-link">集合内操作-删除元素</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-计算元素个数" title="集合内操作-计算元素个数" class="sidebar-link">集合内操作-计算元素个数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-判断元素是否在集合中" title="集合内操作-判断元素是否在集合中" class="sidebar-link">集合内操作-判断元素是否在集合中</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-随机从集合返回指定个数元素。" title="集合内操作-随机从集合返回指定个数元素。" class="sidebar-link">集合内操作-随机从集合返回指定个数元素。</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-从集合随机弹出元素" title="集合内操作-从集合随机弹出元素" class="sidebar-link">集合内操作-从集合随机弹出元素</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-获取所有元素" title="集合内操作-获取所有元素" class="sidebar-link">集合内操作-获取所有元素</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-求多个集合的交集" title="集合间操作-求多个集合的交集" class="sidebar-link">集合间操作-求多个集合的交集</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-求多个集合的并集" title="集合间操作-求多个集合的并集" class="sidebar-link">集合间操作-求多个集合的并集</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-求多个集合的差集" title="集合间操作-求多个集合的差集" class="sidebar-link">集合间操作-求多个集合的差集</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-将交集、并集、差集的结果保存" title="集合间操作-将交集、并集、差集的结果保存" class="sidebar-link">集合间操作-将交集、并集、差集的结果保存</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合常用命令时间复杂度" title="集合常用命令时间复杂度" class="sidebar-link">集合常用命令时间复杂度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合类型的内部编码" title="集合类型的内部编码" class="sidebar-link">集合类型的内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合的使用场景" title="集合的使用场景" class="sidebar-link">集合的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis数据结构-有序集合" title="Redis数据结构-有序集合" class="sidebar-link">Redis数据结构-有序集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#列表、集合和有序集合三者的异同点" title="列表、集合和有序集合三者的异同点" class="sidebar-link">列表、集合和有序集合三者的异同点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-添加成员" title="集合内操作-添加成员" class="sidebar-link">集合内操作-添加成员</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-计算成员个数" title="集合内操作-计算成员个数" class="sidebar-link">集合内操作-计算成员个数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-计算某个成员的分数" title="集合内操作-计算某个成员的分数" class="sidebar-link">集合内操作-计算某个成员的分数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-计算成员的排名" title="集合内操作-计算成员的排名" class="sidebar-link">集合内操作-计算成员的排名</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-删除成员" title="集合内操作-删除成员" class="sidebar-link">集合内操作-删除成员</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-增加成员分数" title="集合内操作-增加成员分数" class="sidebar-link">集合内操作-增加成员分数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-返回指定排名范围的成员" title="集合内操作-返回指定排名范围的成员" class="sidebar-link">集合内操作-返回指定排名范围的成员</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-返回指定分数范围的成员" title="集合内操作-返回指定分数范围的成员" class="sidebar-link">集合内操作-返回指定分数范围的成员</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-返回指定分数范围成员个数" title="集合内操作-返回指定分数范围成员个数" class="sidebar-link">集合内操作-返回指定分数范围成员个数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-删除指定排名内的升序元素" title="集合内操作-删除指定排名内的升序元素" class="sidebar-link">集合内操作-删除指定排名内的升序元素</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合内操作-删除指定分数范围的成员" title="集合内操作-删除指定分数范围的成员" class="sidebar-link">集合内操作-删除指定分数范围的成员</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-求多个集合的交集-2" title="集合间操作-求多个集合的交集" class="sidebar-link">集合间操作-求多个集合的交集</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#集合间操作-求多个集合的并集-2" title="集合间操作-求多个集合的并集" class="sidebar-link">集合间操作-求多个集合的并集</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#有序集合命令的时间复杂度" title="有序集合命令的时间复杂度" class="sidebar-link">有序集合命令的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#有序集合内部编码" title="有序集合内部编码" class="sidebar-link">有序集合内部编码</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#有序集合的使用场景" title="有序集合的使用场景" class="sidebar-link">有序集合的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#redis键管理" title="Redis键管理" class="sidebar-link">Redis键管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-键重命名管理" title="单个键管理-键重命名管理" class="sidebar-link">单个键管理-键重命名管理</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-随机返回一个键" title="单个键管理-随机返回一个键" class="sidebar-link">单个键管理-随机返回一个键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-键过期" title="单个键管理-键过期" class="sidebar-link">单个键管理-键过期</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-move-redis内部键迁移" title="单个键管理-move-Redis内部键迁移" class="sidebar-link">单个键管理-move-Redis内部键迁移</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-dump-restore-redis实例间键迁移" title="单个键管理-dump+restore-Redis实例间键迁移" class="sidebar-link">单个键管理-dump+restore-Redis实例间键迁移</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-migrate-redis实例间键迁移" title="单个键管理-migrate-Redis实例间键迁移" class="sidebar-link">单个键管理-migrate-Redis实例间键迁移</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#单个键管理-move、dump-restore、migrate三个命令比较" title="单个键管理-move、dump+restore、migrate三个命令比较" class="sidebar-link">单个键管理-move、dump+restore、migrate三个命令比较</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#遍历键-全量遍历键" title="遍历键-全量遍历键" class="sidebar-link">遍历键-全量遍历键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#遍历键-渐进式遍历" title="遍历键-渐进式遍历" class="sidebar-link">遍历键-渐进式遍历</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#数据库管理之切换数据库" title="数据库管理之切换数据库" class="sidebar-link">数据库管理之切换数据库</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/数据库/Redis/API的理解和使用.html#数据库管理之清除数据库" title="数据库管理之清除数据库" class="sidebar-link">数据库管理之清除数据库</a></li></ul></li></ul></li><li><a href="/mr-muggle/数据库/Redis/Redis的一些有用的小功能.html" title="Redis的一些有用的小功能" class="sidebar-link">Redis的一些有用的小功能</a></li><li><a href="/mr-muggle/数据库/Redis/Redis客户端.html" title="Redis客户端" class="sidebar-link">Redis客户端</a></li><li><a href="/mr-muggle/数据库/Redis/Redis的两种持久化机制.html" title="Redis的两种持久化机制" class="sidebar-link">Redis的两种持久化机制</a></li><li><a href="/mr-muggle/数据库/Redis/Redis复制配置与原理.html" title="Redis复制配置与原理" class="sidebar-link">Redis复制配置与原理</a></li><li><a href="/mr-muggle/数据库/Redis/Redis阻塞原因与处理.html" title="Redis阻塞原因与处理" class="sidebar-link">Redis阻塞原因与处理</a></li><li><a href="/mr-muggle/数据库/Redis/Redis内存管理与优化.html" title="Redis内存管理与优化" class="sidebar-link">Redis内存管理与优化</a></li></ul> </aside> <main class="page has-page-anchor"> <div class="theme-antdocs-content content__default"><h2 id="全局命令"><a href="#全局命令" class="header-anchor">#</a> 全局命令</h2> <p>Redis提供了5种数据结构，理解每种数据结构的特点对于Redis开发运维非常重要，同时掌握Redis的单线程命令处理机制，会使数据结构和命令的选择事半功倍。在此之前，我们先要了解一下Redis的一些全局命令、数据结构和内部编码以及单线程命令处理机制。</p> <h3 id="keys-查看所有键"><a href="#keys-查看所有键" class="header-anchor">#</a> <code>keys</code>-查看所有键</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>keys *
</code></pre></div><p>为了演示这个命令的效果，我们先插入3条数据。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> <span class="token function">java</span> jedis
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> python redis-py
OK
</code></pre></div><p>keys*命令会将所有的键输出。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;python&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre></div><h3 id="dbsize-统计键总数"><a href="#dbsize-统计键总数" class="header-anchor">#</a> <code>dbsize</code>-统计键总数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>dbsize
</code></pre></div><p>下面，我们插入一个列表类型的键值对（值是由多个元素组成）</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush mylist a b c d e f g
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
</code></pre></div><p>dbsize命令会返回当前数据库中键的总数。例如当前数据库有4个键，分别是hello、java、python、mylist，所以dbsize的结果是4。即</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> dbsize
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以dbsize命令的时间复杂度是O（1）。而keys命令会遍历所有键，所以它的时间复杂度是O（n），<strong>当Redis保存了大量键时，线上环境禁止使用。</strong></p></div> <h3 id="exists-检查键是否存在"><a href="#exists-检查键是否存在" class="header-anchor">#</a> <code>exists</code>-检查键是否存在</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>exists key
</code></pre></div><p>如果键存在则返回1，不存在则返回0,例如，下面这个例子</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists <span class="token function">java</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists not_exists_key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><h3 id="del-删除键"><a href="#del-删除键" class="header-anchor">#</a> <code>del</code>-删除键</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>del key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p><strong>del是一个通用命令，无论值是什么数据结构类型，del命令都可以将其删除，例如下面将字符串类型的键java和列表类型的键mylist分别删除</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del <span class="token function">java</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists <span class="token function">java</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del mulist
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del mylist
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists mylist
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><p>返回结果为成功删除键的个数，假设删除一个不存在的键，就会返回0。</p> <p><strong>同时del命令可以支持删除多个键</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a <span class="token number">1</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> b <span class="token number">2</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> c <span class="token number">3</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre></div><h3 id="expire-键过期"><a href="#expire-键过期" class="header-anchor">#</a> <code>expire</code>-键过期</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>expire key seconds
</code></pre></div><p>Redis支持对键添加过期时间，当超过过期时间后，会自动删除键，例如为键hello设置了10秒过期时间。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire hello <span class="token number">10</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p><code>ttl</code>命令会返回键的剩余过期时间，它有3种返回值:</p> <ul><li>大于等于0的整数：键剩余的过期时间</li> <li>-1：键没设置过期时间</li> <li>-2：键不存在</li></ul> <h3 id="type-返回键的数据结构类型"><a href="#type-返回键的数据结构类型" class="header-anchor">#</a> <code>type</code>-返回键的数据结构类型</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">type</span> key
</code></pre></div><p>假设键hello是字符串类型，则返回string，键mylist是列表类型，返回结果为list。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a b
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> a
string
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush mylist a b c d e f g
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> mylist
list
</code></pre></div><p>如果键不存在，则返回none。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>  <span class="token builtin class-name">type</span> not_exsit_key
none
</code></pre></div><h2 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="header-anchor">#</a> 数据结构和内部编码</h2> <p><strong>type命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是Redis对外的数据结构。</strong></p> <p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码，可以通过<code>object encoding</code>命令查询数据类型的内部编码。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding hello
<span class="token string">&quot;embstr&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding mylist
<span class="token string">&quot;quicklist&quot;</span>
</code></pre></div><p>使用内部编码的好处：</p> <ul><li>改进内部编码，对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令</li> <li>多种内部编码实现可以在不同场景下发挥各自的优势</li></ul> <h2 id="redis的单线程架构"><a href="#redis的单线程架构" class="header-anchor">#</a> Redis的单线程架构</h2> <p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p> <p>现在我们同时开启多个redis-cli客户端同时执行命令，对于客户端来说，每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。</p> <p>其中第二个过程即执行命令过程是相当关键的，因为Redis是单线程来处理命令的，所以一条命令从客户端到达服务端不会被立即执行，所有的命令都会进入一个队列中，然后被逐个执行。所以三个客户端执行命令的先后顺序是不确定的。但是可以确定不会有两条命令被同时执行，不会产生并发问题，这就是<strong>Redis单线程的基本模型</strong>。但是对像发送命令、返回结果、命令排队这些过程的处理，Redis使用了I/O多路复用技术来解决I/O的问题。</p> <p>通常来讲，单线程处理能力要比多线程差，Redis使用单线程模型会达到每秒万级别的处理能力。究其原因，可以归为以下几个方面：</p> <ul><li><strong>纯内存访问</strong>，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。</li> <li><strong>非阻塞I/O</strong>，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</li> <li><strong>单线程避免了线程切换和竞态产生的消耗</strong>，但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果
某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库。</li></ul> <h2 id="redis数据结构-字符串"><a href="#redis数据结构-字符串" class="header-anchor">#</a> Redis数据结构-字符串</h2> <p><strong>字符串类型是Redis最基础的数据结构。</strong> 首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的，所以字符串类型能为其他四种数据结构的学习奠定基础。</p> <p>字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是<strong>值最大不能超过512MB</strong>。</p> <p>字符串类型的命令比较多，本小节将按照常用和不常用两个维度进行说明。</p> <h3 id="常用命令-设置值"><a href="#常用命令-设置值" class="header-anchor">#</a> 常用命令-设置值</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">set</span> key value <span class="token punctuation">[</span>ex seconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>px milliseconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>nx<span class="token operator">|</span>xx<span class="token punctuation">]</span>
</code></pre></div><p>下面操作设置键为hello，值为world的键值对，返回结果为OK代表设置成功。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
</code></pre></div><p>下面是set命令几个常用的选项</p> <table><thead><tr><th style="text-align:center;">命令格式</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">ex seconds</td> <td style="text-align:center;">为键设置秒级过期时间</td></tr> <tr><td style="text-align:center;">px milliseconds</td> <td style="text-align:center;">为键设置毫秒级过期时间</td></tr> <tr><td style="text-align:center;">nx</td> <td style="text-align:center;">键必须不存在，才可以设置成功，若键存在，则设置失败</td></tr> <tr><td style="text-align:center;">xx</td> <td style="text-align:center;">与nx相反，键必须存在，才可以设置成功，用于更新。</td></tr></tbody></table> <p>除了set选项外，Redis还提供了setex和setnx两个命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>setex key seconds value
setnx key value
</code></pre></div><p>它们的作用和ex和nx选项是一样的。清除字符串类型的hello字符串，重新设置字符串hello的值为world</p> <div class="language-bash extra-class"><pre class="language-bash"><code> <span class="token builtin class-name">set</span> hello world
</code></pre></div><p>因为键hello已存在，所以setnx失败，返回结果为0</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setnx hello redis
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><p>因为键hello已存在，所以set xx成功，返回结果为OK。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello jedis xx
OK
</code></pre></div><p><strong>由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。</strong></p> <h3 id="常用命令-获取值"><a href="#常用命令-获取值" class="header-anchor">#</a> 常用命令-获取值</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>get key
</code></pre></div><p>例如下面，我们来获取键hello的值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get hello
<span class="token string">&quot;jedis&quot;</span>
</code></pre></div><p>如果要获取的键不存在，则返回nil（空）</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get not_exist_key
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div><p>当然，我们也可以批量设置值或批量获取值，批量获取值的命令格式如下。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>mset key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>下面操作通过<code>mset</code>命令一次性设置4个键值对</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> mset a <span class="token number">1</span> b <span class="token number">2</span> c <span class="token number">3</span> d <span class="token number">4</span>
OK
</code></pre></div><p>批量获取值的命令格式如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>mget key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>下面操作批量获取了键a、b、c、d的值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> mget a b c d
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;2&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;3&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;4&quot;</span>
</code></pre></div><p>如果有些键不存在，那么它的值为nil（空），结果是按照传入键的顺序返回</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> mget a f c d
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;3&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;4&quot;</span>
</code></pre></div><p>其中，键f是不存在的，所以返回<code>nil</code>（空）。</p> <p>Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，学会使用批量操作，有助于提高业务处理效率，但是要注意的是每次批量操作所发送的命令数不是无节制的，如果数量过多可能造成Redis阻塞或者网络拥塞。</p> <h3 id="常用命令-计数"><a href="#常用命令-计数" class="header-anchor">#</a> 常用命令-计数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>incr key
</code></pre></div><p>incr命令用于对值做自增操作，返回结果分为三种情况：</p> <ul><li>值不是整数，返回错误</li> <li>值是整数，返回自增后的结果</li> <li><strong>键不存在，按照值为0自增，返回结果为1</strong></li></ul> <p>例如对一个不存在的键执行incr操作后，返回结果是1。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> incr key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>再次对键执行incr命令，返回结果是2。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> incr key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre></div><p>如果值不是整数，则返回一个错误。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> incr hello
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer or out of range
</code></pre></div><p>除了incr命令，Redis提供了decr（自减）、incrby（自增指定数字）、decrby（自减指定数字）、incrbyfloat（自增浮点数）。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>decr key
incrby key increment
decrby key decrement
incrbyfloat key increment
</code></pre></div><p>很多存储系统和编程语言内部使用CAS机制实现计数功能，会有一定的CPU开销，但在Redis中完全不存在这个问题，因为Redis是单线程架构，任何命令到了Redis服务端都要顺序执行。</p> <h3 id="不常用命令-追加值"><a href="#不常用命令-追加值" class="header-anchor">#</a> 不常用命令-追加值</h3> <p>追加值的命令为<code>append</code>，其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>append key value
</code></pre></div><p>append可以向字符串尾部追加值，并返回追加后的字符串总长度。例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get hello
<span class="token string">&quot;jedis&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> append hello client
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get hello
<span class="token string">&quot;jedisclient&quot;</span>
</code></pre></div><h3 id="不常用命令-计算字符串长度"><a href="#不常用命令-计算字符串长度" class="header-anchor">#</a> 不常用命令-计算字符串长度</h3> <p>计算字符串长度的命令为<code>strlen</code>，其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>strlen key
</code></pre></div><p>例如，字符串hello的当前值为jedisclient，其长度为11，所以使用strlen命令返回值11。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> strlen hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
</code></pre></div><p><strong>对于中文来说，每个字符占用三个字节</strong>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello 世界 xx
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> strlen hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
</code></pre></div><h3 id="不常用命令-设置并返回原值"><a href="#不常用命令-设置并返回原值" class="header-anchor">#</a> 不常用命令-设置并返回原值</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>getset key value
</code></pre></div><p><strong>getset和set一样会设置值，但是不同的是，它同时会返回键原来的值</strong>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> getset hello world
<span class="token string">&quot;<span class="token entity" title="\xe4">\xe4</span><span class="token entity" title="\xb8">\xb8</span><span class="token entity" title="\x96">\x96</span><span class="token entity" title="\xe7">\xe7</span><span class="token entity" title="\x95">\x95</span><span class="token entity" title="\x8c">\x8c</span>&quot;</span>
</code></pre></div><p><code>\xe4\xb8\x96\xe7\x95\x8c</code>其实就是中文&quot;世界&quot;。</p> <h3 id="不常用命令-设置指定位置的字符"><a href="#不常用命令-设置指定位置的字符" class="header-anchor">#</a> 不常用命令-设置指定位置的字符</h3> <p>设置指定位置的字符命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>setrange key offeset value
</code></pre></div><p>例如，我们将下面的键redis的值由pest改为best。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> redis pest
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setrange redis <span class="token number">0</span> b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get redis
<span class="token string">&quot;best&quot;</span>
</code></pre></div><h3 id="不常用命令-获取部分字符串"><a href="#不常用命令-获取部分字符串" class="header-anchor">#</a> 不常用命令-获取部分字符串</h3> <p>获取部分字符串的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>getrange key start end
</code></pre></div><p>start和end分别是开始和结束的偏移量，偏移量从0开始计算。例如下面的命令获取键redis的前两个字符。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> getrange redis <span class="token number">0</span> <span class="token number">1</span>
<span class="token string">&quot;be&quot;</span>
</code></pre></div><h3 id="字符串类型命令时间复杂度"><a href="#字符串类型命令时间复杂度" class="header-anchor">#</a> 字符串类型命令时间复杂度</h3> <p>下表展示了字符串类型命令的时间复杂度，开发人员可以参考此表，结合自身业务需求和数据大小选择适合的命令。</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">set key value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">get key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">del key [key...]</td> <td style="text-align:center;">O(k)，k是键的个数</td></tr> <tr><td style="text-align:center;">mset key value [key value....]</td> <td style="text-align:center;">O(k)，k是键的个数</td></tr> <tr><td style="text-align:center;">mget key [key....]</td> <td style="text-align:center;">O(k)，k是键的个数</td></tr> <tr><td style="text-align:center;">incr key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">decr key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">incrby  key increment</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">decrby key increment</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">incrbyfloat key increment</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">append key value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">strlen key value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">setrange key offset value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">getrange key start end</td> <td style="text-align:center;">O(n)，n是字符串长度，由于获取字符串非常快，所以如果字符串不是很长，可以视为O(1)</td></tr></tbody></table> <h3 id="字符串类型的内部编码"><a href="#字符串类型的内部编码" class="header-anchor">#</a> 字符串类型的内部编码</h3> <p>字符串类型的内部编码有3种：</p> <ul><li>int：8个字节的长整型。</li> <li>embstr：小于等于39个字节的字符串(3.2版本以前)，在3.2版本之后，则变成了44字节。</li> <li>raw：大于39个字节的字符串，(3.2版本以前)，在3.2版本之后，则变成了44字节。</li></ul> <p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p> <p>整型类型示例：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key <span class="token number">8653</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">&quot;int&quot;</span>
</code></pre></div><p>短字符串示例如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key <span class="token string">&quot;hello,world&quot;</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">&quot;embstr&quot;</span>
</code></pre></div><p>长字符串示例如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key <span class="token string">&quot;one string greater than 39 byte..............&quot;</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">&quot;raw&quot;</span>
</code></pre></div><h3 id="字符串的典型应用场景"><a href="#字符串的典型应用场景" class="header-anchor">#</a> 字符串的典型应用场景</h3> <ul><li><strong>缓存功能：</strong> 将数据缓存在redis中，避免频繁访问数据库。</li> <li><strong>计数：</strong> 可能用于统计视频播放次数，每播放一次则递增1。</li> <li><strong>共享session：</strong> 在分布式web服务时，使用Redis将用户的Session进行集中管理，避免用户重复登录。</li> <li><strong>限速：</strong> 很多应用出于安全的考虑，会在每次进行登录时，让用户输入手机验证码，从而确定是否是用户本人。但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率。</li></ul> <h2 id="redis数据结构-哈希"><a href="#redis数据结构-哈希" class="header-anchor">#</a> Redis数据结构-哈希</h2> <p>几乎所有的编程语言都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组。<strong>在Redis中，哈希类型是指键值本身又是一个键值对结构</strong> 。</p> <p>哈希类型中的映射关系叫作field-value，这里的value是指field对应的值，不是键对应的值，请注意value在不同上下文的作用。</p> <h3 id="常用命令-设置值-2"><a href="#常用命令-设置值-2" class="header-anchor">#</a> 常用命令-设置值</h3> <p>设置值的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hset key field value
</code></pre></div><p>下面为user：1添加一对field-value</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset user:1 name tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>如果设置成功会返回1，反之会返回0。此外Redis提供了hsetnx命令，它们的关系就像set和setnx命令一样，只不过作用域由键变为field。</p> <h3 id="常用命令-获取值-2"><a href="#常用命令-获取值-2" class="header-anchor">#</a> 常用命令-获取值</h3> <p>获取值的命令格式如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hget key field
</code></pre></div><p>例如，下面操作获取user:1的name域（属性）对应的值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hget user:1 name
<span class="token string">&quot;tom&quot;</span>
</code></pre></div><p>如果键或field不存在，会返回nil。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hget user:2 name
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hget user:1 age
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div><h3 id="常用命令-删除field"><a href="#常用命令-删除field" class="header-anchor">#</a> 常用命令-删除field</h3> <p>和前面的类似，删除field的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hdel key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>hdel会删除一个或多个field，<strong>返回结果为成功删除field的个数</strong>，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hdel user:1 name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hdel user:1 age
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><h3 id="常用命令-计算field个数"><a href="#常用命令-计算field个数" class="header-anchor">#</a> 常用命令-计算field个数</h3> <p>计算filed个数的命令格式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>hlen key
</code></pre></div><p>例如user:1有3个field：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset user:1 name tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset user:1 age <span class="token number">23</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset user:1 city tianjin
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hlen user:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre></div><h3 id="常用命令-批量设置或获取field-value"><a href="#常用命令-批量设置或获取field-value" class="header-anchor">#</a> 常用命令-批量设置或获取field-value</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>hmget key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
hmset key field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p><code>hmset</code>和<code>hmget</code>命令分别是批量设置和获取field-value，<code>hmset</code>需要的参数是key和多对field-value，<code>hmget</code>需要的参数是key和多个field。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hmset user:1 name mike age <span class="token number">12</span> city tianjin
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hmget user:1 name city
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;tianjin&quot;</span>
</code></pre></div><h3 id="常用命令-判断field是否存在"><a href="#常用命令-判断field是否存在" class="header-anchor">#</a> 常用命令-判断field是否存在</h3> <p>判断field是否存在的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hexists key field
</code></pre></div><p>例如，user:1包含name域，所以返回结果为1，不包含时返回0。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hexists user:1 name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><h3 id="常用命令-获取所有field"><a href="#常用命令-获取所有field" class="header-anchor">#</a> 常用命令-获取所有field</h3> <p>获取所有field的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hkeys key
</code></pre></div><p><code>hkeys</code>命令应该叫<code>hfields</code>更为恰当，它返回指定哈希键所有的field，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hkeys user:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;city&quot;</span>
</code></pre></div><h3 id="常用命令-获取所有value"><a href="#常用命令-获取所有value" class="header-anchor">#</a> 常用命令-获取所有value</h3> <p>获取所有value的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hvals key
</code></pre></div><p>下面的命令获取user:1全部value</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hvals user:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;12&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;tianjin&quot;</span>
</code></pre></div><h3 id="常用命令-获取所有的field-value"><a href="#常用命令-获取所有的field-value" class="header-anchor">#</a> 常用命令-获取所有的field-value</h3> <p>获取所有field-value的命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hgetall key
</code></pre></div><p>下面操作获取user:1所有的field-value</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hgetall user:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;12&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;city&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;tianjin&quot;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在使用<code>hgetall</code>命令时，如果哈希元素个数比较多，会存在阻塞Redis的可能。如果开发人员只需要获取部分field，可以使用<code>hmget</code>命令，如果一定要获取全部field-value，可以使用<code>hscan</code>命令，该命令会渐进式遍历哈希类型。</p></div> <h3 id="常用命令-计数-2"><a href="#常用命令-计数-2" class="header-anchor">#</a> 常用命令-计数</h3> <p>计数命令和字符串的计数命令类似，其命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hincrby key field
hincrbyfloat key field
</code></pre></div><p><code>hincrby</code>和<code>hincrbyfloat</code>命令，就像<code>incrby</code>和<code>incrbyfloat</code>命令一样，但是<strong>它们的作用域是filed</strong>。</p> <h3 id="常用命令-计算value的字符串长度"><a href="#常用命令-计算value的字符串长度" class="header-anchor">#</a> 常用命令-计算value的字符串长度</h3> <p>若我们需要计算value的字符串长度，可以使用如下命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hstrlen key field
</code></pre></div><p>例如<code>hget user:1 name</code>的value是mike，那么hstrlen的返回结果是3：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hstrlen user:1 name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre></div><h3 id="哈希命令类型的时间复杂度"><a href="#哈希命令类型的时间复杂度" class="header-anchor">#</a> 哈希命令类型的时间复杂度</h3> <p>下表是哈希类型命令的时间复杂度，开发人员可以参考此表选择适合的命令。</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">hset key field value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hget key field</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hdel key field [field...]</td> <td style="text-align:center;">O(k)，k是field的个数</td></tr> <tr><td style="text-align:center;">hlen key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hgetall key</td> <td style="text-align:center;">O(n)，n是field的个数</td></tr> <tr><td style="text-align:center;">hmget field [field...]</td> <td style="text-align:center;">O(k)，k是field的个数</td></tr> <tr><td style="text-align:center;">hmset key field value  [field value...]</td> <td style="text-align:center;">O(k)，k是field的个数</td></tr> <tr><td style="text-align:center;">hexists  key field</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hkeys key</td> <td style="text-align:center;">O(n)，n是field的个数</td></tr> <tr><td style="text-align:center;">hvals key</td> <td style="text-align:center;">O(n)，n是field的个数</td></tr> <tr><td style="text-align:center;">hsetnx key field value</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hincrby key field increment</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hincrbyfloat key field increment</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">hstrlen key field</td> <td style="text-align:center;">O(1)</td></tr></tbody></table> <h3 id="哈希类型的内部编码"><a href="#哈希类型的内部编码" class="header-anchor">#</a> 哈希类型的内部编码</h3> <p>哈希类型的内部编码实现有两种：</p> <ul><li><strong>ziplist（压缩列表）</strong>：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li> <li><strong>hashtable（哈希表）</strong>：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O(1)。</li></ul> <h3 id="哈希的使用场景"><a href="#哈希的使用场景" class="header-anchor">#</a> 哈希的使用场景</h3> <p>与使用字符串序列化缓存用户信息相比，哈希类型变得更加直观，并且在更新操作上会更加便捷。可以将每个用户的id定义为键后缀，多对fieldvalue对应每个用户的属性，类似如下伪代码。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">UserInfo</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 用户id作为key后缀</span>
userRedisKey <span class="token operator">=</span> <span class="token string">&quot;user:info:&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>
<span class="token comment">// 使用hgetall获取所有用户信息映射关系</span>
userInfoMap <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span>userRedisKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">UserInfo</span> userInfo<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>userInfoMap <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 将映射关系转换为UserInfo</span>
userInfo <span class="token operator">=</span> <span class="token function">transferMapToUserInfo</span><span class="token punctuation">(</span>userInfoMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">// 从MySQL中获取用户信息</span>
userInfo <span class="token operator">=</span> mysql<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将userInfo变为映射关系使用hmset保存到Redis中</span>
redis<span class="token punctuation">.</span><span class="token function">hmset</span><span class="token punctuation">(</span>userRedisKey<span class="token punctuation">,</span> <span class="token function">transferUserInfoToMap</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 添加过期时间</span>
redis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>userRedisKey<span class="token punctuation">,</span> <span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> userInfo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是需要注意的是哈希类型和关系型数据库有两点不同之处：</p> <ul><li><strong>哈希类型是稀疏的，而关系型数据库是完全结构化的</strong>，例如哈希类型
每个键可以有不同的field，而关系型数据库一旦添加新的列，所有行都要为其设置值（即使为NULL）</li> <li><strong>关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发困难，维护成本高。</strong></li></ul> <h3 id="三种缓存用户信息的优缺点"><a href="#三种缓存用户信息的优缺点" class="header-anchor">#</a> 三种缓存用户信息的优缺点</h3> <ol><li><strong>原生字符串类型</strong>：每个属性一个键。
<ul><li>优点：简单直观，每个属性都支持更新操作。</li> <li>缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以<strong>此种方案一般不会在生产环境使用。</strong></li></ul></li> <li><strong>序列化字符串类型</strong>：将用户信息序列化后用一个键保存。
<ul><li>优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。</li> <li>缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</li></ul></li> <li><strong>哈希类型</strong>：每个用户属性使用一对field-value，但是只用一个键保存。
<ul><li>优点：简单直观，如果使用合理可以减少内存空间的使用。</li> <li>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</li></ul></li></ol> <h2 id="redis数据结构-列表"><a href="#redis数据结构-列表" class="header-anchor">#</a> Redis数据结构-列表</h2> <p>列表（list）类型是用来存储多个有序的字符串，例如，a、b、c、d、e五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element）。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。</p> <p><strong>列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</strong></p> <h3 id="列表的主要特点"><a href="#列表的主要特点" class="header-anchor">#</a> 列表的主要特点</h3> <p>列表主要有两个比较重要的特点：</p> <ul><li><strong>列表中的元素是有序的</strong>，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</li> <li><strong>列表中的元素可以是重复的</strong>。</li></ul> <p>总而言之，列表中的元素是有序且可重复的。</p> <h3 id="列表的四种操作类型"><a href="#列表的四种操作类型" class="header-anchor">#</a> 列表的四种操作类型</h3> <p>下面将按照对列表的5种操作类型对命令进行介绍。</p> <table><thead><tr><th style="text-align:center;">操作类型</th> <th style="text-align:center;">操作</th></tr></thead> <tbody><tr><td style="text-align:center;">添加</td> <td style="text-align:center;">rpush、lpush、linsert</td></tr> <tr><td style="text-align:center;">查</td> <td style="text-align:center;">lrange、lindex、llen</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">lpop、rpop、lrem、ltrim</td></tr> <tr><td style="text-align:center;">修改</td> <td style="text-align:center;">lset</td></tr> <tr><td style="text-align:center;">阻塞操作</td> <td style="text-align:center;">blpop、brpop</td></tr></tbody></table> <h3 id="常用命令-添加"><a href="#常用命令-添加" class="header-anchor">#</a> 常用命令-添加</h3> <ol><li><p>从右边插入元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>rpush key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>下面我们从右向左插入元素c、b、a。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush listkey c b a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre></div><p><code>lrange 0 -1</code>命令可以从左到右获取列表的所有元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange listkey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li> <li><p>从左边插入元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lpush key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>使用方法和<code>rpush</code>命令相同，只不过从左侧插入。</p></li> <li><p>向某个元素前或者后插入元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>linsert key before<span class="token operator">|</span>after pivot value
</code></pre></div><p><code>linsert</code>命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入一个新的元素value，例如下面操作会在列表的元素b前插入java。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> linsert listkey before b <span class="token function">java</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre></div><p>返回的结果为4，代表当前列表的长度，当前列表包含以下元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>  lrange listkey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li></ol> <h3 id="常用命令-查找"><a href="#常用命令-查找" class="header-anchor">#</a> 常用命令-查找</h3> <ol><li><p>获取指定范围内的元素列表</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lrange key start end
</code></pre></div></li></ol> <p><code>lrange</code>命令操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p> <ul><li><p>索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N</p></li> <li><p><code>lrange</code>命令中的end选项包含了自身，这个和很多编程语言不包含end不太相同，例如想获取列表的第2到第4个元素，可以执行如下操作：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange listkey <span class="token number">1</span> <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li></ul> <ol start="2"><li><p>获取列表指定索引下标的元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code> lindex key index
</code></pre></div><p>例如当前列表最后一个元素为a，我们按照上面的命令格式获取最后一个元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>   <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lindex listkey <span class="token parameter variable">-1</span>
   <span class="token string">&quot;a&quot;</span>
</code></pre></div></li> <li><p>获取列表长度</p> <div class="language-bash extra-class"><pre class="language-bash"><code>llen key
</code></pre></div><p>例如我们想获取当前列表的长度</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> llen listkey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre></div></li></ol> <h3 id="常用命令-删除"><a href="#常用命令-删除" class="header-anchor">#</a> 常用命令-删除</h3> <ol><li><p>从列表左侧弹出元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lpop key
</code></pre></div><p>如下操作将列表最左侧的元素c弹出，弹出后列表变为java、b、a。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> lpop listkey
<span class="token string">&quot;c&quot;</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> lrange listkey <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li> <li><p>从列表右侧弹出</p> <div class="language-bash extra-class"><pre class="language-bash"><code>rpop key
</code></pre></div><p>它的使用方法和lpop是一样的，只不过从列表右侧弹出。</p></li> <li><p>删除指定元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lrem key count value
</code></pre></div><p><code>lrem</code>命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况:</p> <ul><li>count&gt;0，从左到右，删除最多count个元素。</li> <li>count&lt;0，从右到左，删除最多count绝对值个元素。</li> <li>count=0，删除所有。</li></ul> <p>例如向列表从左向右插入5个a，那么当前列表变为“a a a a a java b a”，下面操作将从列表左边开始删除4个为a的元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lpush listkey a a a a a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">8</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrem listkey <span class="token number">4</span> a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange listkey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li> <li><p>按照索引范围修剪列表</p> <div class="language-bash extra-class"><pre class="language-bash"><code>ltrim key start end
</code></pre></div><p>例如，下面操作会只保留列表listkey第2个到第4个元素：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ltrim listkey <span class="token number">1</span> <span class="token number">3</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange listkey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre></div></li> <li><p>修改指定索引下标的元素</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lset key index newValue
</code></pre></div><p>下面操作会将列表listkey中的第3个元素设置为python：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lset listkey <span class="token number">2</span> python
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange listkey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;python&quot;</span>
</code></pre></div></li></ol> <h3 id="常用命令-阻塞操作"><a href="#常用命令-阻塞操作" class="header-anchor">#</a> 常用命令-阻塞操作</h3> <p>阻塞式弹出命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>blpop key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
brpop key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
</code></pre></div><p><code>blpop</code>和<code>brpop</code>是<code>lpop</code>和<code>rpop</code>命令的阻塞版本，它们除了弹出方向不同，使用方法基本相同，所以下面以<code>brpop</code>命令进行说明，<code>brpop</code>命令包含两个参数。</p> <ul><li><strong>key [key...]：</strong> 多个列表的键。</li> <li><strong>timeout：</strong> 阻塞时间（单位：秒）</li></ul> <p>下面分列表是否为空两种情况讨论。</p> <ol><li><p>若列表为空：如果timeout=3，那么客户端要等到3秒后返回，如果timeout=0，那么客户端一直阻塞等下去。</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; brpop list:test 3
(nil)
(3.03s)
127.0.0.1:6379&gt; brpop list:test 0
...一直阻塞...
</code></pre></div><p>如果此期间添加了数据element1，客户端立即返回。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> brpop list:test <span class="token number">0</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;list:test&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;element1&quot;</span>
<span class="token punctuation">(</span><span class="token number">85</span>.04s<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>列表不为空：客户端会立即返回。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lpush list:test a b c d e f g
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
</code></pre></div><p>再执行<code>bprop</code>命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> brpop list:test <span class="token number">0</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;list:test&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
</code></pre></div><p>此时，客户端立即返回了。</p></li></ol> <p>在使用brpop时，我们需要注意以下两点：</p> <ul><li><p>第一点，如果是多个键，那么brpop会从左至右遍历键，一旦有一个键，能弹出元素，客户端立即返回。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> brpop list:1 list:2 list:3 <span class="token number">0</span>
<span class="token punctuation">..</span>.阻塞<span class="token punctuation">..</span>.
</code></pre></div><p>此时另一个客户端分别向list：2和list：3插入元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lpush list:2 element2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lpush list:3 element3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>客户端会立即返回list:2中的element2，因为list:2最先有可以弹出的元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> brpop list:1 list:2 list:3 <span class="token number">0</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;list:2&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;element2&quot;</span>
<span class="token punctuation">(</span><span class="token number">22</span>.88s<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>第二点，如果多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取到弹出的值。</p> <p>客户端1：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>client-<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> brpop list:test <span class="token number">0</span>
<span class="token punctuation">..</span>.阻塞<span class="token punctuation">..</span>.
</code></pre></div><p>客户端2：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>client-<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> brpop list:test <span class="token number">0</span>
<span class="token punctuation">..</span>.阻塞<span class="token punctuation">..</span>.
</code></pre></div><p>客户端3：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>client-<span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span> brpop list:test <span class="token number">0</span>
<span class="token punctuation">..</span>.阻塞<span class="token punctuation">..</span>.
</code></pre></div><p>此时另一个客户端lpush一个元素到list:test列表中。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>client-lpush<span class="token operator">&gt;</span> lpush list:test element
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>那么客户端1最会获取到元素，因为客户端1最先执行brpop，而客户端2和客户端3继续阻塞。</p></li></ul> <h3 id="列表命令时间复杂度"><a href="#列表命令时间复杂度" class="header-anchor">#</a> 列表命令时间复杂度</h3> <p>下面我们根据不同的命令类型分贝列出命令及其复杂度数据。</p> <ul><li><p>添加命令时间复杂度</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">rpush key value [value...]</td> <td style="text-align:center;">O(k)，k是元素个数</td></tr> <tr><td style="text-align:center;">lpush key value [value...]</td> <td style="text-align:center;">O(k)，k是元素个数</td></tr> <tr><td style="text-align:center;">linsert key before | after pivot value</td> <td style="text-align:center;">O(n)，n是距离列表头或尾的距离</td></tr></tbody></table></li> <li><p>查找命令时间复杂度</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">lrange key start end</td> <td style="text-align:center;">O(s+n)，s是start的偏移量，n是start到end的范围</td></tr> <tr><td style="text-align:center;">lindex key index</td> <td style="text-align:center;">O(n)，n是索引的偏移量</td></tr> <tr><td style="text-align:center;">llen key</td> <td style="text-align:center;">O(1)</td></tr></tbody></table></li> <li><p>删除命令时间复杂度</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">lpop key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">rpop key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">lrem key count value</td> <td style="text-align:center;">O(n)，n是列表长度</td></tr> <tr><td style="text-align:center;">ltrim key start end</td> <td style="text-align:center;">O(n)，n是要裁剪的元素总数</td></tr></tbody></table></li> <li><p>修改命令时间复杂度</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">lset key index value</td> <td style="text-align:center;">O(n)，n是索引的偏移量</td></tr></tbody></table></li> <li><p>阻塞命令时间复杂度</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">brpop blpop</td> <td style="text-align:center;">O(1)</td></tr></tbody></table></li></ul> <h3 id="列表类型的内部编码"><a href="#列表类型的内部编码" class="header-anchor">#</a> 列表类型的内部编码</h3> <p>列表类型的内部编码有两种：</p> <ul><li><strong>ziplist（压缩列表）：</strong> 当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li> <li><strong>linkedlist（链表）：</strong> 当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现。</p></div> <h3 id="列表的使用场景"><a href="#列表的使用场景" class="header-anchor">#</a> 列表的使用场景</h3> <ul><li><strong>消息队列</strong>：Redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</li> <li><strong>文章列表</strong>：每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p> <ul><li>lpush+lpop=Stack（栈）</li> <li>lpush+rpop=Queue（队列）</li> <li>·lpsh+ltrim=Capped Collection（有限集合）</li> <li>lpush+brpop=Message Queue（消息队列）</li></ul></div> <h2 id="redis数据结构-集合"><a href="#redis数据结构-集合" class="header-anchor">#</a> Redis数据结构-集合</h2> <p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p> <p>下面将按照集合内和集合间两个维度对集合的常用命令进行介绍。</p> <h3 id="集合内操作-添加元素"><a href="#集合内操作-添加元素" class="header-anchor">#</a> 集合内操作-添加元素</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>sadd key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>返回结果为添加成功的元素个数，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> exists myset
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd myset a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd myset a b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><p>当我们重复添加重复元素时，无法再添加进集合里。</p> <h3 id="集合内操作-删除元素"><a href="#集合内操作-删除元素" class="header-anchor">#</a> 集合内操作-删除元素</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>srem key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>返回结果为成功删除元素个数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> srem myset a b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> srem myset hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><h3 id="集合内操作-计算元素个数"><a href="#集合内操作-计算元素个数" class="header-anchor">#</a> 集合内操作-计算元素个数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>scard key
</code></pre></div><p>scard的时间复杂度为O（1），它不会遍历集合所有元素，而是直接用
Redis内部的变量，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> scard myset
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><h3 id="集合内操作-判断元素是否在集合中"><a href="#集合内操作-判断元素是否在集合中" class="header-anchor">#</a> 集合内操作-判断元素是否在集合中</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>sismember key element
</code></pre></div><p>如果给定元素element在集合内返回1，反之返回0，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sismember myset c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><h3 id="集合内操作-随机从集合返回指定个数元素。"><a href="#集合内操作-随机从集合返回指定个数元素。" class="header-anchor">#</a> 集合内操作-随机从集合返回指定个数元素。</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>srandmember key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre></div><p>count是可选参数，如果不写默认为1，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; sadd myset a b
(integer) 2
127.0.0.1:6379&gt; srandmember myset 2
1) &quot;b&quot;
2) &quot;c&quot;
127.0.0.1:6379&gt; srandmember myset
&quot;a&quot;
127.0.0.1:6379&gt;
</code></pre></div><h3 id="集合内操作-从集合随机弹出元素"><a href="#集合内操作-从集合随机弹出元素" class="header-anchor">#</a> 集合内操作-从集合随机弹出元素</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>spop key
</code></pre></div><p><code>spop</code>命令操作可以从集合中随机弹出一个元素。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> spop myset
<span class="token string">&quot;a&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers myset
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
</code></pre></div><p>需要注意的是Redis从3.2版本开始，<code>spop</code>命令也支持[count]参数。其命令格式和前面的命令类似，若不写，则默认为弹出一个。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>spop key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>srandmember</code>和<code>spop</code>都是随机从集合选出元素，两者不同的是<code>spop</code>命令执行后，元素会从集合中删除，而<code>srandmember</code>命令不会。</p></div> <h3 id="集合内操作-获取所有元素"><a href="#集合内操作-获取所有元素" class="header-anchor">#</a> 集合内操作-获取所有元素</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>smembers key
</code></pre></div><p>下面代码获取集合myset所有元素，并且返回结果是无序的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers myset
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p><code>smembers</code>和<code>lrange</code>、<code>hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用<code>sscan</code>来完成。</p></div> <h3 id="集合间操作-求多个集合的交集"><a href="#集合间操作-求多个集合的交集" class="header-anchor">#</a> 集合间操作-求多个集合的交集</h3> <p>现在有两个集合，它们分别是user:1:follow和user:2:follow。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd user:1:follow it music his sports
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd user:2:follow it news ent sports
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre></div><p>若我们想求多个集合的交集，则可以使用下面形式的命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>sinter key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>例如下面代码是求user:1:follow和user:2:follow两个集合的交集，返回结果是sports、it。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sinter user:1:follow user:2:follow
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;sports&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;it&quot;</span>
</code></pre></div><h3 id="集合间操作-求多个集合的并集"><a href="#集合间操作-求多个集合的并集" class="header-anchor">#</a> 集合间操作-求多个集合的并集</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>suinon key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>例如下面代码是求user:1:follow和user:2:follow两个集合的并集，返回结果是sports、it、his、news、music、ent。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sunion user:1:follow user:2:follow
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;his&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;news&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;music&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;ent&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;sports&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;it&quot;</span>
</code></pre></div><h3 id="集合间操作-求多个集合的差集"><a href="#集合间操作-求多个集合的差集" class="header-anchor">#</a> 集合间操作-求多个集合的差集</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">sdiff</span> key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>例如下面代码是求user:1:follow和user:2:follow两个集合的差集，返回结果是music和his。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers user:1:follow
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;music&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;sports&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;it&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;his&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers user:2:follow
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;ent&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;sports&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;it&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;news&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">sdiff</span> user:1:follow user:2:follow
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;music&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;his&quot;</span>
</code></pre></div><h3 id="集合间操作-将交集、并集、差集的结果保存"><a href="#集合间操作-将交集、并集、差集的结果保存" class="header-anchor">#</a> 集合间操作-将交集、并集、差集的结果保存</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>sinterstore destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
suionstore destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
sdiffstore destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p><strong>集合间的运算在元素较多的情况下会比较耗时，所以Redis提供了上面三个命令（原命令+store）将集合间交集、并集、差集的结果保存在destination key中。</strong></p> <p>例如下面操作将user:1:follow和user:2:follow两个集合的交集结果保存在user:1_2:inter中，user:1_2:inter本身也是集合类型：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sinterstore user:1_2:inter user:1:follow user:2:follow
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> user:1_2:inter
<span class="token builtin class-name">set</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> smembers user:1_2:inter
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;it&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;sports&quot;</span>
</code></pre></div><h3 id="集合常用命令时间复杂度"><a href="#集合常用命令时间复杂度" class="header-anchor">#</a> 集合常用命令时间复杂度</h3> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">sadd  key element [element...]</td> <td style="text-align:center;">O(k)，k是元素个数</td></tr> <tr><td style="text-align:center;">srem key elememt  [element...]</td> <td style="text-align:center;">O(k)，k是元素个数</td></tr> <tr><td style="text-align:center;">scard key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">sismember key element</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">srandmember key [count]</td> <td style="text-align:center;">O(count)</td></tr> <tr><td style="text-align:center;">spop key</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">smembers key</td> <td style="text-align:center;">O(n)，n是元素总数</td></tr> <tr><td style="text-align:center;">sinter key [key....]或</td> <td style="text-align:center;">O(m*k)，k是多个集合中元素最少的集合的元素个数，m是键个数</td></tr> <tr><td style="text-align:center;">sunion key [key...]或</td> <td style="text-align:center;">O(k)，k是多个集合元素个数和</td></tr> <tr><td style="text-align:center;">sdiff key [key...]</td> <td style="text-align:center;">O(k)，k是多个集合元素个数和</td></tr></tbody></table> <h3 id="集合类型的内部编码"><a href="#集合类型的内部编码" class="header-anchor">#</a> 集合类型的内部编码</h3> <p>集合类型的内部编码有两种：</p> <ul><li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li> <li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li></ul> <h3 id="集合的使用场景"><a href="#集合的使用场景" class="header-anchor">#</a> 集合的使用场景</h3> <p>集合类型比较典型的使用场景是标签（tag）。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。</p> <h2 id="redis数据结构-有序集合"><a href="#redis数据结构-有序集合" class="header-anchor">#</a> Redis数据结构-有序集合</h2> <p>有序集合，它保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素可以排序。<strong>但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。</strong></p> <p>有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>有序集合中的元素不能重复，但是score可以重复，就和一个班里的同学学号不能重复，但是考试成绩可以相同。</p></div> <h3 id="列表、集合和有序集合三者的异同点"><a href="#列表、集合和有序集合三者的异同点" class="header-anchor">#</a> 列表、集合和有序集合三者的异同点</h3> <table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">是否允许重复元素</th> <th style="text-align:center;">是否有序</th> <th style="text-align:center;">有序实现方式</th> <th style="text-align:center;">应用场景</th></tr></thead> <tbody><tr><td style="text-align:center;">列表</td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td> <td style="text-align:center;">索引下标</td> <td style="text-align:center;">时间轴、消息队列等</td></tr> <tr><td style="text-align:center;">集合</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td> <td style="text-align:center;">无</td> <td style="text-align:center;">标签、社交等</td></tr> <tr><td style="text-align:center;">有序集合</td> <td style="text-align:center;">否</td> <td style="text-align:center;">是</td> <td style="text-align:center;">分值</td> <td style="text-align:center;">排行榜系统、社交等</td></tr></tbody></table> <h3 id="集合内操作-添加成员"><a href="#集合内操作-添加成员" class="header-anchor">#</a> 集合内操作-添加成员</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zadd key score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>下面操作向有序集合user:ranking添加用户tom和他的分数251。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd user:ranking <span class="token number">251</span> tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>返回结果代表成功添加成员的个数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd user:ranking <span class="token number">1</span> kris <span class="token number">91</span> mike <span class="token number">200</span> frank <span class="token number">220</span> tim <span class="token number">250</span> martin
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre></div><p>Redis3.2为zadd命令添加了nx、xx、ch、incr四个选项</p> <ul><li>nx：member必须不存在，才可以设置成功，用于添加。</li> <li>xx：member必须存在，才可以设置成功，用于更新。</li> <li>ch：返回此次操作后，有序集合元素和分数发生变化的个数。</li> <li>incr：对score做增加，相当于后面介绍的zincrby。</li></ul> <p>:: : tip</p> <p>有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时间复杂度为O（log（n）），sadd的时间复杂度为O（1）。</p> <p>:::</p> <h3 id="集合内操作-计算成员个数"><a href="#集合内操作-计算成员个数" class="header-anchor">#</a> 集合内操作-计算成员个数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zcard key
</code></pre></div><p>例如下面操作返回有序集合user:ranking的成员数为5，和集合类型的<code>scard</code>命令一样，<code>zcard</code>的时间复杂度为O(1)。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zcard user:ranking
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
</code></pre></div><h3 id="集合内操作-计算某个成员的分数"><a href="#集合内操作-计算某个成员的分数" class="header-anchor">#</a> 集合内操作-计算某个成员的分数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zscore key member
</code></pre></div><p>tom的分数为251，如果成员不存在则返回nil：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zscore user:ranking tom
<span class="token string">&quot;251&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zscore user <span class="token builtin class-name">test</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div><h3 id="集合内操作-计算成员的排名"><a href="#集合内操作-计算成员的排名" class="header-anchor">#</a> 集合内操作-计算成员的排名</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zrank key member
zrevrank key member
</code></pre></div><p><strong>zrank是从分数从低到高返回排名</strong>，zrevrank反之。例如下面操作中，tom在zrank和zrevrank分别排名第5和第0（排名从0开始计算）。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrank user:ranking tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrevrank user:ranking tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><h3 id="集合内操作-删除成员"><a href="#集合内操作-删除成员" class="header-anchor">#</a> 集合内操作-删除成员</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zrem key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>下面操作将成员mike从有序集合user:ranking中删除。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrem user:ranking mike
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>返回结果为成功删除的个数。</p> <h3 id="集合内操作-增加成员分数"><a href="#集合内操作-增加成员分数" class="header-anchor">#</a> 集合内操作-增加成员分数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zincrby key increment member
</code></pre></div><p>下面操作给tom增加了9分，分数变为了260分。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zincrby user:ranking <span class="token number">9</span> tom
<span class="token string">&quot;260&quot;</span>
</code></pre></div><h3 id="集合内操作-返回指定排名范围的成员"><a href="#集合内操作-返回指定排名范围的成员" class="header-anchor">#</a> 集合内操作-返回指定排名范围的成员</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zrange key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span>
zrevrange key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span>
</code></pre></div><p>有序集合是按照分值排名的，<code>zrange</code>命令是从低到高返回，<code>zrevrange</code>命令反之。下面代码返回排名最低的是三个成员，如果加上<code>withscores</code>选项，同时会返回成员的分数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrange user:ranking  <span class="token number">0</span> <span class="token number">2</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;kris&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;frank&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrevrange user:ranking <span class="token number">0</span> <span class="token number">2</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;tom&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;260&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;martin&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;250&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
</code></pre></div><h3 id="集合内操作-返回指定分数范围的成员"><a href="#集合内操作-返回指定分数范围的成员" class="header-anchor">#</a> 集合内操作-返回指定分数范围的成员</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zrangebyscore key min max <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
zrevrangebyscore key max min <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
</code></pre></div><p>其中<code>zrangebyscore</code>按照分数从低到高返回，<code>zrevrangebyscore</code>反之。例如下面操作从低到高返回200到221分的成员，withscores选项会同时返回每个成员的分数。[limit offset count]选项可以限制输出的起始位置和个数：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrangebyscore user:ranking <span class="token number">200</span> <span class="token number">221</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;frank&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrevrangebyscore user:ranking <span class="token number">221</span> <span class="token number">200</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;frank&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
</code></pre></div><p><strong>同时min和max还支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大。</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrangebyscore user:ranking <span class="token punctuation">(</span><span class="token number">200</span> +inf withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;martin&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;250&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;tom&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;260&quot;</span>
</code></pre></div><h3 id="集合内操作-返回指定分数范围成员个数"><a href="#集合内操作-返回指定分数范围成员个数" class="header-anchor">#</a> 集合内操作-返回指定分数范围成员个数</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zcount key min max
</code></pre></div><p>下面的命令返回200到221分的成员的个数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zcount user:ranking <span class="token number">200</span> <span class="token number">221</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre></div><h3 id="集合内操作-删除指定排名内的升序元素"><a href="#集合内操作-删除指定排名内的升序元素" class="header-anchor">#</a> 集合内操作-删除指定排名内的升序元素</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zremrangebyrank key start end
</code></pre></div><p>下面操作删除第start到第end名的成员：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zremrangebyrank user:ranking <span class="token number">0</span> <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre></div><h3 id="集合内操作-删除指定分数范围的成员"><a href="#集合内操作-删除指定分数范围的成员" class="header-anchor">#</a> 集合内操作-删除指定分数范围的成员</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zremrangebyscore key min max
</code></pre></div><p>下面操作将250分以上的成员全部删除，返回结果为成功删除的个数：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zremrangebyscore user:ranking <span class="token punctuation">(</span><span class="token number">250</span> +inf
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>现在，我们先添加两个集合user:ranking:1和user:ranking:2。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd user:ranking:1 <span class="token number">1</span> kris <span class="token number">91</span> mike <span class="token number">200</span> frank <span class="token number">220</span> tim <span class="token number">250</span> martin
<span class="token number">251</span> tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd user:ranking:2 <span class="token number">8</span> james <span class="token number">77</span> mike <span class="token number">625</span> martin <span class="token number">888</span> tom
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre></div><h3 id="集合间操作-求多个集合的交集-2"><a href="#集合间操作-求多个集合的交集-2" class="header-anchor">#</a> 集合间操作-求多个集合的交集</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zinterstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>weights weight <span class="token punctuation">[</span>weight <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>aggregate <span class="token function">sum</span><span class="token operator">|</span>min<span class="token operator">|</span>max<span class="token punctuation">]</span>
</code></pre></div><p>这个命令参数较多，下面分别进行说明：</p> <ul><li>destination：交集计算结果保存到这个键</li> <li>numkeys：需要做交集计算键的个数</li> <li>key[key...]：需要做交集计算的键</li> <li>weights weight [weight...]：每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1</li> <li>aggregate sum|min|max：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum。</li></ul> <p>下面操作对user:ranking:1和user:ranking:2做交集，weights和aggregate使用了默认配置，可以看到目标键user:ranking:1_inter_2对分值做了sum操作。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zinterstore user:ranking:1_inter_2 <span class="token number">2</span> user:ranking:1 user:ranking:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrange user:ranking:1_inter_2 <span class="token number">0</span> <span class="token parameter variable">-1</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;168&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;martin&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;875&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;tom&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;1139&quot;</span>
</code></pre></div><p>如果想让user:ranking:2的权重变为0.5，并且聚合效果使用max，可以执行如下操作：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zinterstore user:ranking:1_inter_2 <span class="token number">2</span> user:ranking:1 user:ranking:2 weights <span class="token number">1</span> <span class="token number">0.5</span> aggregate max
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrange user:ranking:1_inter_2 <span class="token number">0</span> <span class="token parameter variable">-1</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;91&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;martin&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;312.5&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;tom&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;444&quot;</span>
</code></pre></div><h3 id="集合间操作-求多个集合的并集-2"><a href="#集合间操作-求多个集合的并集-2" class="header-anchor">#</a> 集合间操作-求多个集合的并集</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>zunionstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>weights weight <span class="token punctuation">[</span>weight <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>aggregate <span class="token function">sum</span><span class="token operator">|</span>min<span class="token operator">|</span>max<span class="token punctuation">]</span>
</code></pre></div><p>该命令的所有参数和zinterstore是一致的，只不过是做并集计算，例如下面操作是计算user:ranking:1和user:ranking:2的并集，weights和aggregate使用了默认配置，可以看到目标键user:ranking:1_union_2对分值做了sum操作。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zunionstore user:ranking:1_union_2 <span class="token number">2</span> user:ranking:1 user:ranking:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zrange user:ranking:1_union_2 <span class="token number">0</span> <span class="token parameter variable">-1</span> withscores
 <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;kris&quot;</span>
 <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
 <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;james&quot;</span>
 <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;8&quot;</span>
 <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;mike&quot;</span>
 <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;168&quot;</span>
 <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">&quot;frank&quot;</span>
 <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
 <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">&quot;tim&quot;</span>
<span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">&quot;220&quot;</span>
<span class="token number">11</span><span class="token punctuation">)</span> <span class="token string">&quot;martin&quot;</span>
<span class="token number">12</span><span class="token punctuation">)</span> <span class="token string">&quot;875&quot;</span>
<span class="token number">13</span><span class="token punctuation">)</span> <span class="token string">&quot;tom&quot;</span>
<span class="token number">14</span><span class="token punctuation">)</span> <span class="token string">&quot;1139&quot;</span>
</code></pre></div><p>开发人员在使用对应的命令进行开发时，不仅要考虑功能性，还要了解相应的时间复杂度，防止由于使用不当造成应用方效率下降以及Redis阻塞。</p> <h3 id="有序集合命令的时间复杂度"><a href="#有序集合命令的时间复杂度" class="header-anchor">#</a> 有序集合命令的时间复杂度</h3> <p><img src="/redis-develop-operations/zset-time-complexity.jpg" alt="有序集合复杂度"></p> <h3 id="有序集合内部编码"><a href="#有序集合内部编码" class="header-anchor">#</a> 有序集合内部编码</h3> <p>有序集合类型的内部编码有两种：</p> <ul><li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplistentries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li> <li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul> <h3 id="有序集合的使用场景"><a href="#有序集合的使用场景" class="header-anchor">#</a> 有序集合的使用场景</h3> <p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p> <h2 id="redis键管理"><a href="#redis键管理" class="header-anchor">#</a> Redis键管理</h2> <p>本节将按照单个键、遍历键、数据库管理三个维度对一些通用命令进行介绍。</p> <h3 id="单个键管理-键重命名管理"><a href="#单个键管理-键重命名管理" class="header-anchor">#</a> 单个键管理-键重命名管理</h3> <p>针对单个键的命令，前面几节已经介绍过一部分了，例如<code>type</code>、<code>del</code>、<code>object</code>、<code>exists</code>、<code>expire</code>等，下面将介绍剩余的几个重要命令。</p> <p>键重命名管理</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">rename</span> key newkey
</code></pre></div><p>例如现有一个键值对，键为python，值为jedis，下面将键python重命名为java：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> python jedis
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">rename</span> python <span class="token function">java</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get python
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get <span class="token function">java</span>
<span class="token string">&quot;jedis&quot;</span>
</code></pre></div><p>如果在rename之前，键java已经存在，那么它的值也将被覆盖，如下所示：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a b
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> c d
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">rename</span> a c
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get a
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get c
<span class="token string">&quot;b&quot;</span>
</code></pre></div><p>此时原来，键为c，值为d的字符串类型数据被覆盖。</p> <p><strong>为了防止被强行<code>rename</code>，Redis提供了<code>renamenx</code>命令，确保只有newKey不存在时候才被覆盖，例如下面操作<code>renamenx</code>时，newkey=python已经存在，返回结果是0代表没有完成重命名，所以键java和python的值没变：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get <span class="token function">java</span>
<span class="token string">&quot;jedis&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> python redis-py
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> renamenx <span class="token function">java</span> python
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get <span class="token function">java</span>
<span class="token string">&quot;jedis&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get python
<span class="token string">&quot;redis-py&quot;</span>
</code></pre></div><p>在使用重命名命令时，有两点需要注意：</p> <ul><li>由于重命名键期间会执行del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能性，这点不要忽视。</li> <li>如果<code>rename</code>和<code>renamenx</code>中的key和newkey如果是相同的，在Redis3.2和之前版本返回结果略有不同。Redis3.2中会返回OK，Redis3.2之前的版本会提示错误。</li></ul> <h3 id="单个键管理-随机返回一个键"><a href="#单个键管理-随机返回一个键" class="header-anchor">#</a> 单个键管理-随机返回一个键</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>randomkey
</code></pre></div><p>下面，我们随机返回一个键。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> randomkey
<span class="token string">&quot;listkey&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> randomkey
<span class="token string">&quot;user:ranking:1_inter_2&quot;</span>
</code></pre></div><h3 id="单个键管理-键过期"><a href="#单个键管理-键过期" class="header-anchor">#</a> 单个键管理-键过期</h3> <p>前面简单介绍键过期功能，它可以自动将带有过期时间的键删除，在许多应用场景都非常有帮助。除了<code>expire</code>、<code>ttl</code>命令以外，Redis还提供了<code>expireat</code>、<code>pexpire</code>、<code>pexpireat</code>、<code>pttl</code>、<code>persist</code>等一系列命令，下面分别进行说明。</p> <ul><li><code>expire key seconds</code>：键在seconds秒后过期</li> <li><code>expireat key timestamp</code>：键在秒级时间戳timestamp后过期</li></ul> <p>下面为键hello设置了10秒的过期时间，然后通过ttl观察它的过期剩余时间（单位：秒），随着时间的推移，ttl逐渐变小，最终变为-2：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire hello <span class="token number">10</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token parameter variable">-2</span>
</code></pre></div><p><code>ttl</code>命令和<code>pttl</code>都可以查询键的剩余过期时间，但是<code>pttl</code>精度更高可以达到毫秒级别，有3种返回值：</p> <ul><li>大于等于0的整数：键剩余的过期时间（ttl是秒，pttl是毫秒）</li> <li>-1：键没有设置过期时间</li> <li>-2：键不存在</li></ul> <p><code>expireat</code>命令可以设置键的秒级过期时间戳，除此之外，Redis2.6版本后提供了毫秒级的过期方案：</p> <ul><li><code>pexpire key milliseconds</code>：键在milliseconds毫秒后过期。</li> <li><code>pexpireat key milliseconds-timestamp</code>：键在毫秒级时间戳timestamp后过期。</li></ul> <p>在使用Redis相关过期命令时，需要注意以下几点。</p> <ul><li><p>如果expire key的键不存在，返回结果为0</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire not_exists_key <span class="token number">30</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div></li> <li><p>如果过期时间为负值，键会立即被删除，犹如使用del命令一样</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire hello <span class="token parameter variable">-2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get hello
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><code>persist</code>命令可以将键的过期时间清除：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset fv1 f1 v1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire fv1 <span class="token number">50</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl fv1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">43</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> persist fv1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token parameter variable">-1</span>
</code></pre></div></li> <li><p><strong>对于字符串类型键，执行set命令会去掉过期时间，这个问题很容易在开发中被忽视。</strong></p> <p>下面的例子证实了set会导致过期时间失效，因为ttl变为-1：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire hello <span class="token number">50</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">41</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> hello world
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token parameter variable">-1</span>
</code></pre></div></li> <li><p>Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置。</p></li> <li><p><code>setex</code>命令作为set+expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。</p></li></ul> <h3 id="单个键管理-move-redis内部键迁移"><a href="#单个键管理-move-redis内部键迁移" class="header-anchor">#</a> 单个键管理-<code>move</code>-Redis内部键迁移</h3> <p>迁移键功能非常重要，因为有时候我们只想把部分数据由一个Redis迁移到另一个Redis（例如从生产环境迁移到测试环境），Redis发展历程中提供了<code>move</code>、<code>dump+restore</code>、<code>migrate</code>三组迁移键的方法，它们的实现方式以及使用的场景不太相同。</p> <p>move`-Redis内部进行数据迁移</p> <div class="language-bash extra-class"><pre class="language-bash"><code>move key db
</code></pre></div><p>move命令用于在Redis内部进行数据迁移，Redis内部可以有多个数据库，彼此在数据上是相互隔离的，<code>move key db</code>就是把指定的键从源数据库移动到目标数据库中，<strong>但不建议在生产环境使用，所以这个命令读者知道即可。</strong></p> <h3 id="单个键管理-dump-restore-redis实例间键迁移"><a href="#单个键管理-dump-restore-redis实例间键迁移" class="header-anchor">#</a> 单个键管理-<code>dump+restore</code>-Redis实例间键迁移</h3> <p><code>dump+restore</code>-在不同的Redis实例之间进行数据迁移</p> <p>整个迁移的过程分为两步：</p> <ul><li><p>在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>dump key
</code></pre></div></li> <li><p>在目标Redis上，restore命令将上面序列化的值进行复原，其中<code>ttl</code>参数代表过期时间，如果ttl=0代表没有过期时间。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>restore key ttl value
</code></pre></div></li></ul> <p>有关<code>dump+restore</code>有两点需要注意：</p> <ul><li>整个迁移过程并非原子性的，而是通过客户端分步完成的。</li> <li>迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输。</li></ul> <h3 id="单个键管理-migrate-redis实例间键迁移"><a href="#单个键管理-migrate-redis实例间键迁移" class="header-anchor">#</a> 单个键管理-<code>migrate</code>-Redis实例间键迁移</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>migrate <span class="token function">host</span> port key<span class="token operator">|</span><span class="token string">&quot;&quot;</span> destination-db <span class="token function">timeout</span> <span class="token punctuation">[</span>copy<span class="token punctuation">]</span> <span class="token punctuation">[</span>replace<span class="token punctuation">]</span> <span class="token punctuation">[</span>keys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.
</code></pre></div><p><code>migrate</code>命令也是用于在Redis实例间进行数据迁移的，实际上<code>migrate</code>命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程。migrate命令具有原子性，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率。</p> <p><code>migrate</code>实现过程和<code>dump+restore</code>基本类似，但是有3点不太相同：</p> <ul><li>整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行<code>migrate</code>命令即可。</li> <li><code>migrate</code>命令的数据传输直接在源Redis和目标Redis上完成的。</li> <li>目标Redis完成<code>restore</code>后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否
在源Redis上删除对应的键。</li></ul> <p>下面对migrate的参数进行逐个说明：</p> <ul><li>host：目标Redis的IP地址。</li> <li>port：目标Redis的端口。</li> <li>key|&quot;&quot;：在Redis3.0.6版本之前，<code>migrate</code>只支持迁移一个键，所以此处是要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串&quot;&quot;。</li> <li>destination-db：目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</li> <li>timeout：迁移的超时时间（单位为毫秒）</li> <li>[replace]：如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</li> <li>[keys key[key...]]：迁移多个键，例如要迁移key1、key2、key3，此处填写“keys key1 key2 key3”。</li></ul> <h3 id="单个键管理-move、dump-restore、migrate三个命令比较"><a href="#单个键管理-move、dump-restore、migrate三个命令比较" class="header-anchor">#</a> 单个键管理-<code>move</code>、<code>dump+restore</code>、<code>migrate</code>三个命令比较</h3> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">作用域</th> <th style="text-align:center;">原子性</th> <th style="text-align:center;">支持多个键</th></tr></thead> <tbody><tr><td style="text-align:center;">move</td> <td style="text-align:center;">Redis实例内部</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">dump+restore</td> <td style="text-align:center;">Redis实例之间</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">migrate</td> <td style="text-align:center;">Redis实例之间</td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td></tr></tbody></table> <h3 id="遍历键-全量遍历键"><a href="#遍历键-全量遍历键" class="header-anchor">#</a> 遍历键-全量遍历键</h3> <p>Redis提供了两个命令遍历所有的键，分别是keys和scan，本节将对它们介绍并简要分析。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>keys pattern
</code></pre></div><p>事实上，<code>keys</code>命令支持glob风格的通配符：</p> <ul><li>*****：代表匹配任意字符。</li> <li><strong>?</strong>：匹配一个字符。</li> <li><strong>[]</strong>：代表匹配部分字符，例如[1，3]代表匹配1，3，[1-10]代表匹配1到10的任意数字。</li> <li><strong>\x</strong>：用来做转义，例如要匹配星号、问号需要进行转义。</li></ul> <p>下面操作匹配以j，r开头，紧跟edis字符串的所有键：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span> keys <span class="token punctuation">[</span>j,r<span class="token punctuation">]</span>edis
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;redis&quot;</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>当需要遍历所有键时（例如检测过期或闲置时间、寻找大对象等），<code>keys</code>是一个很有帮助的命令。但是如果考虑到Redis的单线程架构就不那么美妙了，如果Redis包含了大量的键，执行keys命令很可能会造成Redis阻塞，所以一般建议不要在生产环境下使用keys命令。</p></div> <p>若实在有遍历键的需求，可以在以下三种情况使用：</p> <ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但是会影响到主从复制。</li> <li>如果确认键值总数确实比较少，可以执行该命令。</li> <li>使用下面要介绍的<code>scan</code>命令渐进式的遍历所有键，可以有效防止阻塞。</li></ul> <h3 id="遍历键-渐进式遍历"><a href="#遍历键-渐进式遍历" class="header-anchor">#</a> 遍历键-渐进式遍历</h3> <p>Redis从2.8版本后，提供了一个新的命令<code>scan</code>，它能有效的解决<code>keys</code>命令存在的问题。和<code>keys</code>命令执行时会遍历所有键不同，<code>scan</code>采用渐进式遍历的方式来解决<code>keys</code>命令可能带来的阻塞问题，每次<code>scan</code>命令的时间复杂度是O（1），但是要真正实现keys的功能，需要执行多次<code>scan</code>。</p> <p>scan的使用方法如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>scan cursor <span class="token punctuation">[</span>match pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>count number<span class="token punctuation">]</span>
</code></pre></div><p>其参数含义如下：</p> <ul><li><p>cursor是必需参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</p></li> <li><p>match pattern是可选参数，它的作用的是做模式的匹配，这点和keys的模式匹配很像。</p></li> <li><p>count number是可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</p></li></ul> <p>现有一个Redis有41个键，现在要遍历所有的键，使用scan命令效果的操作如下。第一次执行<code>scan 0</code>，返回结果分为两个部分：第一个部分30，就是下次<code>scan</code>需要的cursor，第二个部分是这次遍历的key。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span> scan <span class="token number">0</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;30&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span>  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;user:1:follow&quot;</span>
    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
    <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
    <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;user:ranking:1_union_2&quot;</span>
    <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;fv1&quot;</span>
    <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;user:ranking:1_inter_2&quot;</span>
    <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">&quot;python&quot;</span>
    <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
    <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">&quot;list:3&quot;</span>
   <span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">&quot;user:ranking&quot;</span>
   <span class="token number">11</span><span class="token punctuation">)</span> <span class="token string">&quot;myset&quot;</span>
</code></pre></div><p>此时，使用新的cursor=“30”，执行<code>scan 30</code>命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code> scan <span class="token number">30</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;27&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span>  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mylist&quot;</span>
    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;listkey&quot;</span>
    <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;user:2:follow&quot;</span>
    <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
    <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
    <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;list:test&quot;</span>
    <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">&quot;key&quot;</span>
    <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">&quot;redis&quot;</span>
    <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">&quot;user:1&quot;</span>
   <span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">&quot;user:ranking:2&quot;</span>
</code></pre></div><p>这次得到cursor=“27”，继续执行<code>scan 27</code>命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>scan <span class="token number">27</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;0&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;user:1_2:inter&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;user:ranking:1&quot;</span>
</code></pre></div><p>此时，cursor=“0”，表示所有的键已经被遍历过了。</p> <p>除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如<code>hgetall</code>、<code>smembers</code>、<code>zrange</code>可能产生的阻塞问题，对应的命令分别是<code>hscan</code>、<code>sscan</code>、<code>zscan</code>，它们的用法和scan基本类似。</p> <p>渐进式遍历的并非没有缺点：渐进式遍历可以有效的解决keys命令可能产生的阻塞问题，但是scan并非完美无瑕，如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会碰到如下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键，这些是我们在开发时需要考虑的。</p> <h3 id="数据库管理之切换数据库"><a href="#数据库管理之切换数据库" class="header-anchor">#</a> 数据库管理之切换数据库</h3> <p>Redis提供了几个面向Redis数据库的操作，它们分别是<code>dbsize</code>、<code>select</code>、<code>flushdb/flushall</code>命令，本节将通过具体的使用场景介绍这些命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">select</span> dbIndex
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>许多关系型数据库，例如MySQL支持在一个实例下有多个数据库存在的，但是与关系型数据库用字符来区分不同数据库名不同，Redis只是用数字作为多个数据库的实现。Redis默认配置中是有16个数据库，各个数据库之间数据是相互隔离的，没有任何关联。</p></div> <p>当使用<code>rediscli-h{ip}-p{port}</code>连接Redis时，默认使用的就是0号数据库，当选择其他数据库时，会有[index]的前缀标识，其中index就是数据库的索引下标。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys hell*
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get hello
<span class="token string">&quot;world&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token keyword">select</span> <span class="token number">15</span>
OK
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> get hello
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div><p>Redis3.0中已经逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，只不过为了向下兼容老版本的数据库功能，该功能没有完全废弃掉。究其原因无非以下三点：</p> <ul><li>Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响的。</li> <li>多数据库的使用方式，会让调试和运维不同业务的数据库变的困难，假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困难。</li> <li>部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱。</li></ul> <p>如果要使用多个数据库功能，完全可以在一台机器上部署多个Redis实例，彼此用端口来做区分，因为现代计算机或者服务器通常是有多个CPU的。这样既保证了业务之间不会受到影响，又合理地使用了CPU资源。</p> <h3 id="数据库管理之清除数据库"><a href="#数据库管理之清除数据库" class="header-anchor">#</a> 数据库管理之清除数据库</h3> <p><code>flushdb/flushall</code>命令用于清除数据库，两者的区别的是<code>flushdb</code>只清除当前数据库，<code>flushall</code>会清除所有数据库。</p> <p><code>flushdb/flushall</code>命令可以非常方便的清理数据，但是也带来两个问题：</p> <ul><li><code>flushdb/flushall</code>命令会将所有数据清除，一旦误操作后果不堪设想。</li> <li>如果当前数据库键值数量比较多，<code>flushdb/flushall</code>存在阻塞Redis的可能性。</li></ul> <p><strong>总而言之，慎重使用<code>flushdb/flushall</code>。</strong></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">LastUpdated:</span> <span class="time">3/11/2021, 7:31:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mr-muggle/数据库/Redis/初识Redis.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        初识 Redis
      </a></span> <span class="next"><a href="/mr-muggle/数据库/Redis/Redis的一些有用的小功能.html">
        Redis的一些有用的小功能
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> <div class="page-anchor"><div class="ant-space ant-space-vertical" style="width:100%;"><div class="ant-space-item"><div class="page-anchor-offset"><div><div class="ant-anchor-wrapper" style="max-height:100vh;"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a href="#全局命令" title="全局命令" class="ant-anchor-link-title">全局命令</a><div class="ant-anchor-link"><a href="#keys-查看所有键" title="keys-查看所有键" class="ant-anchor-link-title">keys-查看所有键</a></div><div class="ant-anchor-link"><a href="#dbsize-统计键总数" title="dbsize-统计键总数" class="ant-anchor-link-title">dbsize-统计键总数</a></div><div class="ant-anchor-link"><a href="#exists-检查键是否存在" title="exists-检查键是否存在" class="ant-anchor-link-title">exists-检查键是否存在</a></div><div class="ant-anchor-link"><a href="#del-删除键" title="del-删除键" class="ant-anchor-link-title">del-删除键</a></div><div class="ant-anchor-link"><a href="#expire-键过期" title="expire-键过期" class="ant-anchor-link-title">expire-键过期</a></div><div class="ant-anchor-link"><a href="#type-返回键的数据结构类型" title="type-返回键的数据结构类型" class="ant-anchor-link-title">type-返回键的数据结构类型</a></div></div><div class="ant-anchor-link"><a href="#数据结构和内部编码" title="数据结构和内部编码" class="ant-anchor-link-title">数据结构和内部编码</a></div><div class="ant-anchor-link"><a href="#redis的单线程架构" title="Redis的单线程架构" class="ant-anchor-link-title">Redis的单线程架构</a></div><div class="ant-anchor-link"><a href="#redis数据结构-字符串" title="Redis数据结构-字符串" class="ant-anchor-link-title">Redis数据结构-字符串</a><div class="ant-anchor-link"><a href="#常用命令-设置值" title="常用命令-设置值" class="ant-anchor-link-title">常用命令-设置值</a></div><div class="ant-anchor-link"><a href="#常用命令-获取值" title="常用命令-获取值" class="ant-anchor-link-title">常用命令-获取值</a></div><div class="ant-anchor-link"><a href="#常用命令-计数" title="常用命令-计数" class="ant-anchor-link-title">常用命令-计数</a></div><div class="ant-anchor-link"><a href="#不常用命令-追加值" title="不常用命令-追加值" class="ant-anchor-link-title">不常用命令-追加值</a></div><div class="ant-anchor-link"><a href="#不常用命令-计算字符串长度" title="不常用命令-计算字符串长度" class="ant-anchor-link-title">不常用命令-计算字符串长度</a></div><div class="ant-anchor-link"><a href="#不常用命令-设置并返回原值" title="不常用命令-设置并返回原值" class="ant-anchor-link-title">不常用命令-设置并返回原值</a></div><div class="ant-anchor-link"><a href="#不常用命令-设置指定位置的字符" title="不常用命令-设置指定位置的字符" class="ant-anchor-link-title">不常用命令-设置指定位置的字符</a></div><div class="ant-anchor-link"><a href="#不常用命令-获取部分字符串" title="不常用命令-获取部分字符串" class="ant-anchor-link-title">不常用命令-获取部分字符串</a></div><div class="ant-anchor-link"><a href="#字符串类型命令时间复杂度" title="字符串类型命令时间复杂度" class="ant-anchor-link-title">字符串类型命令时间复杂度</a></div><div class="ant-anchor-link"><a href="#字符串类型的内部编码" title="字符串类型的内部编码" class="ant-anchor-link-title">字符串类型的内部编码</a></div><div class="ant-anchor-link"><a href="#字符串的典型应用场景" title="字符串的典型应用场景" class="ant-anchor-link-title">字符串的典型应用场景</a></div></div><div class="ant-anchor-link"><a href="#redis数据结构-哈希" title="Redis数据结构-哈希" class="ant-anchor-link-title">Redis数据结构-哈希</a><div class="ant-anchor-link"><a href="#常用命令-设置值-2" title="常用命令-设置值" class="ant-anchor-link-title">常用命令-设置值</a></div><div class="ant-anchor-link"><a href="#常用命令-获取值-2" title="常用命令-获取值" class="ant-anchor-link-title">常用命令-获取值</a></div><div class="ant-anchor-link"><a href="#常用命令-删除field" title="常用命令-删除field" class="ant-anchor-link-title">常用命令-删除field</a></div><div class="ant-anchor-link"><a href="#常用命令-计算field个数" title="常用命令-计算field个数" class="ant-anchor-link-title">常用命令-计算field个数</a></div><div class="ant-anchor-link"><a href="#常用命令-批量设置或获取field-value" title="常用命令-批量设置或获取field-value" class="ant-anchor-link-title">常用命令-批量设置或获取field-value</a></div><div class="ant-anchor-link"><a href="#常用命令-判断field是否存在" title="常用命令-判断field是否存在" class="ant-anchor-link-title">常用命令-判断field是否存在</a></div><div class="ant-anchor-link"><a href="#常用命令-获取所有field" title="常用命令-获取所有field" class="ant-anchor-link-title">常用命令-获取所有field</a></div><div class="ant-anchor-link"><a href="#常用命令-获取所有value" title="常用命令-获取所有value" class="ant-anchor-link-title">常用命令-获取所有value</a></div><div class="ant-anchor-link"><a href="#常用命令-获取所有的field-value" title="常用命令-获取所有的field-value" class="ant-anchor-link-title">常用命令-获取所有的field-value</a></div><div class="ant-anchor-link"><a href="#常用命令-计数-2" title="常用命令-计数" class="ant-anchor-link-title">常用命令-计数</a></div><div class="ant-anchor-link"><a href="#常用命令-计算value的字符串长度" title="常用命令-计算value的字符串长度" class="ant-anchor-link-title">常用命令-计算value的字符串长度</a></div><div class="ant-anchor-link"><a href="#哈希命令类型的时间复杂度" title="哈希命令类型的时间复杂度" class="ant-anchor-link-title">哈希命令类型的时间复杂度</a></div><div class="ant-anchor-link"><a href="#哈希类型的内部编码" title="哈希类型的内部编码" class="ant-anchor-link-title">哈希类型的内部编码</a></div><div class="ant-anchor-link"><a href="#哈希的使用场景" title="哈希的使用场景" class="ant-anchor-link-title">哈希的使用场景</a></div><div class="ant-anchor-link"><a href="#三种缓存用户信息的优缺点" title="三种缓存用户信息的优缺点" class="ant-anchor-link-title">三种缓存用户信息的优缺点</a></div></div><div class="ant-anchor-link"><a href="#redis数据结构-列表" title="Redis数据结构-列表" class="ant-anchor-link-title">Redis数据结构-列表</a><div class="ant-anchor-link"><a href="#列表的主要特点" title="列表的主要特点" class="ant-anchor-link-title">列表的主要特点</a></div><div class="ant-anchor-link"><a href="#列表的四种操作类型" title="列表的四种操作类型" class="ant-anchor-link-title">列表的四种操作类型</a></div><div class="ant-anchor-link"><a href="#常用命令-添加" title="常用命令-添加" class="ant-anchor-link-title">常用命令-添加</a></div><div class="ant-anchor-link"><a href="#常用命令-查找" title="常用命令-查找" class="ant-anchor-link-title">常用命令-查找</a></div><div class="ant-anchor-link"><a href="#常用命令-删除" title="常用命令-删除" class="ant-anchor-link-title">常用命令-删除</a></div><div class="ant-anchor-link"><a href="#常用命令-阻塞操作" title="常用命令-阻塞操作" class="ant-anchor-link-title">常用命令-阻塞操作</a></div><div class="ant-anchor-link"><a href="#列表命令时间复杂度" title="列表命令时间复杂度" class="ant-anchor-link-title">列表命令时间复杂度</a></div><div class="ant-anchor-link"><a href="#列表类型的内部编码" title="列表类型的内部编码" class="ant-anchor-link-title">列表类型的内部编码</a></div><div class="ant-anchor-link"><a href="#列表的使用场景" title="列表的使用场景" class="ant-anchor-link-title">列表的使用场景</a></div></div><div class="ant-anchor-link"><a href="#redis数据结构-集合" title="Redis数据结构-集合" class="ant-anchor-link-title">Redis数据结构-集合</a><div class="ant-anchor-link"><a href="#集合内操作-添加元素" title="集合内操作-添加元素" class="ant-anchor-link-title">集合内操作-添加元素</a></div><div class="ant-anchor-link"><a href="#集合内操作-删除元素" title="集合内操作-删除元素" class="ant-anchor-link-title">集合内操作-删除元素</a></div><div class="ant-anchor-link"><a href="#集合内操作-计算元素个数" title="集合内操作-计算元素个数" class="ant-anchor-link-title">集合内操作-计算元素个数</a></div><div class="ant-anchor-link"><a href="#集合内操作-判断元素是否在集合中" title="集合内操作-判断元素是否在集合中" class="ant-anchor-link-title">集合内操作-判断元素是否在集合中</a></div><div class="ant-anchor-link"><a href="#集合内操作-随机从集合返回指定个数元素。" title="集合内操作-随机从集合返回指定个数元素。" class="ant-anchor-link-title">集合内操作-随机从集合返回指定个数元素。</a></div><div class="ant-anchor-link"><a href="#集合内操作-从集合随机弹出元素" title="集合内操作-从集合随机弹出元素" class="ant-anchor-link-title">集合内操作-从集合随机弹出元素</a></div><div class="ant-anchor-link"><a href="#集合内操作-获取所有元素" title="集合内操作-获取所有元素" class="ant-anchor-link-title">集合内操作-获取所有元素</a></div><div class="ant-anchor-link"><a href="#集合间操作-求多个集合的交集" title="集合间操作-求多个集合的交集" class="ant-anchor-link-title">集合间操作-求多个集合的交集</a></div><div class="ant-anchor-link"><a href="#集合间操作-求多个集合的并集" title="集合间操作-求多个集合的并集" class="ant-anchor-link-title">集合间操作-求多个集合的并集</a></div><div class="ant-anchor-link"><a href="#集合间操作-求多个集合的差集" title="集合间操作-求多个集合的差集" class="ant-anchor-link-title">集合间操作-求多个集合的差集</a></div><div class="ant-anchor-link"><a href="#集合间操作-将交集、并集、差集的结果保存" title="集合间操作-将交集、并集、差集的结果保存" class="ant-anchor-link-title">集合间操作-将交集、并集、差集的结果保存</a></div><div class="ant-anchor-link"><a href="#集合常用命令时间复杂度" title="集合常用命令时间复杂度" class="ant-anchor-link-title">集合常用命令时间复杂度</a></div><div class="ant-anchor-link"><a href="#集合类型的内部编码" title="集合类型的内部编码" class="ant-anchor-link-title">集合类型的内部编码</a></div><div class="ant-anchor-link"><a href="#集合的使用场景" title="集合的使用场景" class="ant-anchor-link-title">集合的使用场景</a></div></div><div class="ant-anchor-link"><a href="#redis数据结构-有序集合" title="Redis数据结构-有序集合" class="ant-anchor-link-title">Redis数据结构-有序集合</a><div class="ant-anchor-link"><a href="#列表、集合和有序集合三者的异同点" title="列表、集合和有序集合三者的异同点" class="ant-anchor-link-title">列表、集合和有序集合三者的异同点</a></div><div class="ant-anchor-link"><a href="#集合内操作-添加成员" title="集合内操作-添加成员" class="ant-anchor-link-title">集合内操作-添加成员</a></div><div class="ant-anchor-link"><a href="#集合内操作-计算成员个数" title="集合内操作-计算成员个数" class="ant-anchor-link-title">集合内操作-计算成员个数</a></div><div class="ant-anchor-link"><a href="#集合内操作-计算某个成员的分数" title="集合内操作-计算某个成员的分数" class="ant-anchor-link-title">集合内操作-计算某个成员的分数</a></div><div class="ant-anchor-link"><a href="#集合内操作-计算成员的排名" title="集合内操作-计算成员的排名" class="ant-anchor-link-title">集合内操作-计算成员的排名</a></div><div class="ant-anchor-link"><a href="#集合内操作-删除成员" title="集合内操作-删除成员" class="ant-anchor-link-title">集合内操作-删除成员</a></div><div class="ant-anchor-link"><a href="#集合内操作-增加成员分数" title="集合内操作-增加成员分数" class="ant-anchor-link-title">集合内操作-增加成员分数</a></div><div class="ant-anchor-link"><a href="#集合内操作-返回指定排名范围的成员" title="集合内操作-返回指定排名范围的成员" class="ant-anchor-link-title">集合内操作-返回指定排名范围的成员</a></div><div class="ant-anchor-link"><a href="#集合内操作-返回指定分数范围的成员" title="集合内操作-返回指定分数范围的成员" class="ant-anchor-link-title">集合内操作-返回指定分数范围的成员</a></div><div class="ant-anchor-link"><a href="#集合内操作-返回指定分数范围成员个数" title="集合内操作-返回指定分数范围成员个数" class="ant-anchor-link-title">集合内操作-返回指定分数范围成员个数</a></div><div class="ant-anchor-link"><a href="#集合内操作-删除指定排名内的升序元素" title="集合内操作-删除指定排名内的升序元素" class="ant-anchor-link-title">集合内操作-删除指定排名内的升序元素</a></div><div class="ant-anchor-link"><a href="#集合内操作-删除指定分数范围的成员" title="集合内操作-删除指定分数范围的成员" class="ant-anchor-link-title">集合内操作-删除指定分数范围的成员</a></div><div class="ant-anchor-link"><a href="#集合间操作-求多个集合的交集-2" title="集合间操作-求多个集合的交集" class="ant-anchor-link-title">集合间操作-求多个集合的交集</a></div><div class="ant-anchor-link"><a href="#集合间操作-求多个集合的并集-2" title="集合间操作-求多个集合的并集" class="ant-anchor-link-title">集合间操作-求多个集合的并集</a></div><div class="ant-anchor-link"><a href="#有序集合命令的时间复杂度" title="有序集合命令的时间复杂度" class="ant-anchor-link-title">有序集合命令的时间复杂度</a></div><div class="ant-anchor-link"><a href="#有序集合内部编码" title="有序集合内部编码" class="ant-anchor-link-title">有序集合内部编码</a></div><div class="ant-anchor-link"><a href="#有序集合的使用场景" title="有序集合的使用场景" class="ant-anchor-link-title">有序集合的使用场景</a></div></div><div class="ant-anchor-link"><a href="#redis键管理" title="Redis键管理" class="ant-anchor-link-title">Redis键管理</a><div class="ant-anchor-link"><a href="#单个键管理-键重命名管理" title="单个键管理-键重命名管理" class="ant-anchor-link-title">单个键管理-键重命名管理</a></div><div class="ant-anchor-link"><a href="#单个键管理-随机返回一个键" title="单个键管理-随机返回一个键" class="ant-anchor-link-title">单个键管理-随机返回一个键</a></div><div class="ant-anchor-link"><a href="#单个键管理-键过期" title="单个键管理-键过期" class="ant-anchor-link-title">单个键管理-键过期</a></div><div class="ant-anchor-link"><a href="#单个键管理-move-redis内部键迁移" title="单个键管理-move-Redis内部键迁移" class="ant-anchor-link-title">单个键管理-move-Redis内部键迁移</a></div><div class="ant-anchor-link"><a href="#单个键管理-dump-restore-redis实例间键迁移" title="单个键管理-dump+restore-Redis实例间键迁移" class="ant-anchor-link-title">单个键管理-dump+restore-Redis实例间键迁移</a></div><div class="ant-anchor-link"><a href="#单个键管理-migrate-redis实例间键迁移" title="单个键管理-migrate-Redis实例间键迁移" class="ant-anchor-link-title">单个键管理-migrate-Redis实例间键迁移</a></div><div class="ant-anchor-link"><a href="#单个键管理-move、dump-restore、migrate三个命令比较" title="单个键管理-move、dump+restore、migrate三个命令比较" class="ant-anchor-link-title">单个键管理-move、dump+restore、migrate三个命令比较</a></div><div class="ant-anchor-link"><a href="#遍历键-全量遍历键" title="遍历键-全量遍历键" class="ant-anchor-link-title">遍历键-全量遍历键</a></div><div class="ant-anchor-link"><a href="#遍历键-渐进式遍历" title="遍历键-渐进式遍历" class="ant-anchor-link-title">遍历键-渐进式遍历</a></div><div class="ant-anchor-link"><a href="#数据库管理之切换数据库" title="数据库管理之切换数据库" class="ant-anchor-link-title">数据库管理之切换数据库</a></div><div class="ant-anchor-link"><a href="#数据库管理之清除数据库" title="数据库管理之清除数据库" class="ant-anchor-link-title">数据库管理之清除数据库</a></div></div></div></div></div></div></div></div></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/mr-muggle/assets/js/app.03b0f33a.js" defer></script><script src="/mr-muggle/assets/js/2.c49e4524.js" defer></script><script src="/mr-muggle/assets/js/30.98fcced0.js" defer></script>
  </body>
</html>