(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{700:function(t,v,_){"use strict";_.r(v);var a=_(74),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"什么是spring框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring框架"}},[t._v("#")]),t._v(" 什么是Spring框架？")]),t._v(" "),v("p",[t._v("Spring是一种轻量级的开发框架，旨在提高开发人员的开发效率以及系统的可维护性。我们一般情况下说的Spring框架是指Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。")]),t._v(" "),v("p",[t._v("Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC和DI功能。")]),t._v(" "),v("p",[t._v("Spring Aspects：该模块为与AspectJ的集成提供支持。")]),t._v(" "),v("p",[t._v("Spring AOP：提供面向切面的编程实现。")]),t._v(" "),v("p",[t._v("Spring JDBC：Java数据库连接。")]),t._v(" "),v("p",[t._v("Spring JMS：Java消息服务。")]),t._v(" "),v("p",[t._v("Spring ORM：用于支持Hibernate等ORM工具。")]),t._v(" "),v("p",[t._v("Spring Web：为创建Web应用程序提供支持。")]),t._v(" "),v("p",[t._v("Spring Test：提供了对JUnit和TestNG测试的支持。")]),t._v(" "),v("h2",{attrs:{id:"spring框架的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring框架的优点"}},[t._v("#")]),t._v(" Spring框架的优点")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("轻量：")]),t._v(" Spring 是轻量的，基本的版本大约2MB")]),t._v(" "),v("li",[t._v("**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们")]),t._v(" "),v("li",[t._v("**面向切面的编程(AOP)：**Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开")]),t._v(" "),v("li",[t._v("**容器：**Spring 包含并管理应用中对象的生命周期和配置")]),t._v(" "),v("li",[t._v("**MVC框架：**Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品")]),t._v(" "),v("li",[t._v("**事务管理：**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）")]),t._v(" "),v("li",[t._v("**异常处理：**Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常")])]),t._v(" "),v("h2",{attrs:{id:"spring的bean生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring的bean生命周期"}},[t._v("#")]),t._v(" Spring的Bean生命周期")]),t._v(" "),v("ol",[v("li",[t._v("Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化")]),t._v(" "),v("li",[t._v("Bean实例化后对将Bean的引入和值注入到Bean的属性中")]),t._v(" "),v("li",[t._v("如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法")]),t._v(" "),v("li",[t._v("如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入")]),t._v(" "),v("li",[t._v("如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。")]),t._v(" "),v("li",[t._v("如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。")]),t._v(" "),v("li",[t._v("如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用")]),t._v(" "),v("li",[t._v("如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。")]),t._v(" "),v("li",[t._v("此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。")]),t._v(" "),v("li",[t._v("如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。")])]),t._v(" "),v("h2",{attrs:{id:"谈谈你对控制反转的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对控制反转的理解"}},[t._v("#")]),t._v(" 谈谈你对控制反转的理解")]),t._v(" "),v("p",[t._v("Ioc，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；"),v("strong",[t._v("谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。")])])]),t._v(" "),v("li",[v("p",[t._v("为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？"),v("strong",[t._v("因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。")])])])]),t._v(" "),v("p",[t._v("IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。")]),t._v(" "),v("h2",{attrs:{id:"applicationcontext通常的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext通常的实现"}},[t._v("#")]),t._v(" ApplicationContext通常的实现")]),t._v(" "),v("p",[v("code",[t._v("ApplicationContext")]),t._v("通常有三种实现方式："),v("code",[t._v("FileSystemXmlApplicationContext")]),t._v("、"),v("code",[t._v("ClassPathXmlApplicationContext")]),t._v("、"),v("code",[t._v("WebXmlApplicationContext")]),t._v("。")]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("FileSystemXmlApplicationContext")]),t._v("：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("ClassPathXmlApplicationContext")]),t._v("：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("WebXmlApplicationContext")]),t._v("：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。")])])]),t._v(" "),v("h2",{attrs:{id:"spring-bean作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean作用域"}},[t._v("#")]),t._v(" Spring Bean作用域")]),t._v(" "),v("p",[t._v("Spring 3 中为 Bean 定义了 5 种作用域，分别为 singleton（单例）、prototype（原型）、 request、session 和 global session，5 种作用域说明如下：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("singleton")]),t._v("：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个 Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是 Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为：")]),t._v(" "),v("div",{staticClass:"language-xml extra-class"},[v("pre",{pre:!0,attrs:{class:"language-xml"}},[v("code",[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("bean")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("userDao"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("class")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("com.ioc.UserDaoImpl"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("scope")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("singleton"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("prototype")]),t._v("：原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("request")]),t._v("：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的Bean，而且该bean仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean 实例也将会被销毁。")]),t._v(" "),v("div",{staticClass:"language-xml extra-class"},[v("pre",{pre:!0,attrs:{class:"language-xml"}},[v("code",[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("bean")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("loginAction"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("class")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("com.cnblogs.Login"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("scope")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("request"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("session")]),t._v("：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请 求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次 session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求 内有效，请求结束，则实例将被销毁。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("global Session")]),t._v("：在一个全局的Http Session中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。")])])]),t._v(" "),v("h2",{attrs:{id:"谈谈你对mvc的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对mvc的理解"}},[t._v("#")]),t._v(" 谈谈你对MVC的理解")]),t._v(" "),v("p",[t._v("MVC是Model—View—Controler的简称。即模型—视图—控制器。MVC是一种设计模式，它强制性的把应用程序的输入、处理和输出分开。")]),t._v(" "),v("p",[t._v("MVC中的模型、视图、控制器它们分别担负着不同的任务。")]),t._v(" "),v("p",[t._v("视图: 视图是用户看到并与之交互的界面。视图向用户显示相关的数据，并接受用户的输入。视图不进行任何业务逻辑处理。")]),t._v(" "),v("p",[t._v("模型: 模型表示业务数据和业务处理。相当于JavaBean。一个模型能为多个视图提供数据。这提高了应用程序的重用性")]),t._v(" "),v("p",[t._v("控制器: 当用户单击Web页面中的提交按钮时,控制器接受请求并调用相应的模型去处理请求。")]),t._v(" "),v("p",[t._v("然后根据处理的结果调用相应的视图来显示处理的结果。")]),t._v(" "),v("p",[t._v("MVC的处理过程：首先，控制器接受用户的请求，调用相应的模型来进行业务处理，并返回数据给控制器。控制器调用相应的视图来显示处理的结果。并通过视图呈现给用户。")]),t._v(" "),v("h2",{attrs:{id:"spring-mvc-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-原理"}},[t._v("#")]),t._v(" Spring MVC 原理")]),t._v(" "),v("p",[t._v("Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet 会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染 等，甚至还能支持文件上传。")]),t._v(" "),v("ol",[v("li",[t._v("客户端（浏览器）发送请求，直接请求到 "),v("code",[t._v("DispatcherServlet")]),t._v("。")]),t._v(" "),v("li",[v("code",[t._v("DispatcherServlet")]),t._v(" 根据请求信息调用 "),v("code",[t._v("HandlerMapping")]),t._v("，解析请求对应的 "),v("code",[t._v("Handler")]),t._v("。")]),t._v(" "),v("li",[t._v("解析到对应的 "),v("code",[t._v("Handler")]),t._v("（也就是我们平常说的 "),v("code",[t._v("Controller")]),t._v(" 控制器）后，开始由 "),v("code",[t._v("HandlerAdapter")]),t._v(" 适配器处理。")]),t._v(" "),v("li",[v("code",[t._v("HandlerAdapter")]),t._v(" 会根据 "),v("code",[t._v("Handler")]),t._v("来调用真正的处理器开处理请求，并处理相应的业务逻辑。")]),t._v(" "),v("li",[t._v("处理器处理完业务后，会返回一个 "),v("code",[t._v("ModelAndView")]),t._v(" 对象，"),v("code",[t._v("Model")]),t._v(" 是返回的数据对象，"),v("code",[t._v("View")]),t._v(" 是个逻辑上的 "),v("code",[t._v("View")]),t._v("。")]),t._v(" "),v("li",[v("code",[t._v("ViewResolver")]),t._v(" 会根据逻辑 "),v("code",[t._v("View")]),t._v(" 查找实际的 "),v("code",[t._v("View")]),t._v("。")]),t._v(" "),v("li",[v("code",[t._v("DispaterServlet")]),t._v(" 把返回的 "),v("code",[t._v("Model")]),t._v(" 传给 "),v("code",[t._v("View")]),t._v("（视图渲染）。")]),t._v(" "),v("li",[t._v("最后，"),v("code",[t._v("DispacherServlet把")]),t._v(" "),v("code",[t._v("View")]),t._v(" 返回给请求者（浏览器）")])]),t._v(" "),v("h2",{attrs:{id:"spring-mvc中注解及作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc中注解及作用"}},[t._v("#")]),t._v(" Spring MVC中注解及作用")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("@Controller")]),t._v("：用于标识控制层组件，标识这个类是一个控制器，分发处理器会扫描使用了该注解的类的方法，并检测该方法是否使用了"),v("code",[t._v("@RequestMapping")]),t._v("注解。")]),t._v(" "),v("li",[v("code",[t._v("@RestController")]),t._v("：相当于"),v("code",[t._v("@Controller")]),t._v("和"),v("code",[t._v("@ResponseBody")]),t._v("的效果")]),t._v(" "),v("li",[v("code",[t._v("@Component")]),t._v("：泛指组件，当组件不好归类时，我们可以使用这个组件进行标注")]),t._v(" "),v("li",[v("code",[t._v("@Respository")]),t._v("：用于注解dao层，在daoImpl实现类上面注解")]),t._v(" "),v("li",[v("code",[t._v("@Service")]),t._v("：用于标注业务层组件")]),t._v(" "),v("li",[v("code",[t._v("@RequestMapping")]),t._v("：一个用来处理请求地址映射的注解，可以用于方法或者类上，用于类上，表示类中所有响应请求的方法都以该方法作为父路径。")]),t._v(" "),v("li",[v("code",[t._v("@Autowired")]),t._v("：它可以对类成员变量、方法或构造函数进行标注，完成自动装配的工作。通过"),v("code",[t._v("@Autowired")]),t._v("注解可以消除set、get方法。")]),t._v(" "),v("li",[v("code",[t._v("@ResponseBody")]),t._v("：将java对象转成json，并且发送给客户端")]),t._v(" "),v("li",[v("code",[t._v("@RequestBody")]),t._v("：将客户端请求过来的json转成java对象")]),t._v(" "),v("li",[v("code",[t._v("@RequestParam")]),t._v("：当表单参数和方法形参名字不一致时，做一个名字映射")]),t._v(" "),v("li",[v("code",[t._v("@PathVarible")]),t._v("：用于获取uri中的参数,比如user/1中1的值")]),t._v(" "),v("li",[v("code",[t._v("@Valid")]),t._v("：实现数据校验，可以结合hibernate validator一起使用")]),t._v(" "),v("li",[v("code",[t._v("@CookieValue")]),t._v("：用来获取Cookie中的值")]),t._v(" "),v("li",[v("code",[t._v("@RequestHeader")]),t._v("：用来把Request请求header部分的值绑定到参数上")])]),t._v(" "),v("h2",{attrs:{id:"将一个类声明为spring的bean的注解有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#将一个类声明为spring的bean的注解有哪些"}},[t._v("#")]),t._v(" 将一个类声明为Spring的bean的注解有哪些")]),t._v(" "),v("p",[t._v("我们一般使用"),v("code",[t._v("@Autowired")]),t._v("注解去自动装配bean。而想要把一个类标识为可以用"),v("code",[t._v("@Autowired")]),t._v("注解自动装配的bean，可以采用以下的注解实现：")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v("@Component")]),t._v("注解。通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪一个层，可以使用@Component注解标注。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("@Controller")]),t._v("注解。对应Spring MVC的控制层，即Controller层，主要用于接受用户请求并调用Service层的方法返回数据给前端页面。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("@Service")]),t._v("注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("@Repository")]),t._v("注解。对应持久层，即Dao层，主要用于数据库相关操作。")])])]),t._v(" "),v("h2",{attrs:{id:"srping事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#srping事务"}},[t._v("#")]),t._v(" Srping事务")]),t._v(" "),v("h3",{attrs:{id:"spring事务的定义与特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务的定义与特性"}},[t._v("#")]),t._v(" Spring事务的定义与特性")]),t._v(" "),v("p",[t._v("事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败。")]),t._v(" "),v("p",[v("strong",[t._v("原子性 （atomicity）")]),t._v(":强调事务的不可分割.\n"),v("strong",[t._v("一致性 （consistency）")]),t._v(":事务的执行的前后数据的完整性保持一致.\n"),v("strong",[t._v("隔离性 （isolation）")]),t._v(":一个事务执行的过程中,不应该受到其他事务的干扰\n"),v("strong",[t._v("持久性（durability）")]),t._v(" :事务一旦结束,数据就持久到数据库")]),t._v(" "),v("h3",{attrs:{id:"spring事务中的隔离级别有哪几种"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务中的隔离级别有哪几种"}},[t._v("#")]),t._v(" Spring事务中的隔离级别有哪几种")]),t._v(" "),v("p",[t._v("在"),v("code",[t._v("TransactionDefinition")]),t._v("接口中定义了五个表示隔离级别的常量：")]),t._v(" "),v("p",[v("code",[t._v("ISOLATION_DEFAULT")]),t._v("：使用后端数据库默认的隔离级别，Mysql默认采用的"),v("code",[t._v("REPEATABLE_READ")]),t._v("隔离级别；Oracle默认采用的"),v("code",[t._v("READ_COMMITTED")]),t._v("隔离级别。")]),t._v(" "),v("p",[v("code",[t._v("ISOLATION_READ_UNCOMMITTED")]),t._v("：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。")]),t._v(" "),v("p",[v("code",[t._v("ISOLATION_READ_COMMITTED")]),t._v("：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。")]),t._v(" "),v("p",[v("code",[t._v("ISOLATION_REPEATABLE_READ")]),t._v("：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),t._v(" "),v("p",[v("code",[t._v("ISOLATION_SERIALIZABLE")]),t._v("：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。")]),t._v(" "),v("h3",{attrs:{id:"spring事务中的脏读、不可重复读、幻读是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务中的脏读、不可重复读、幻读是什么"}},[t._v("#")]),t._v(" Spring事务中的脏读、不可重复读、幻读是什么")]),t._v(" "),v("p",[v("strong",[t._v("脏读")]),t._v(" :一个事务读到了另一个事务的未提交的数据。\n"),v("strong",[t._v("不可重复读")]),t._v(" :一个事务读到了另一个事务已经提交的"),v("code",[t._v("update")]),t._v(" 的数据导致多次查询结果不一致。\n"),v("strong",[t._v("幻读")]),t._v(" :一个事务读到了另一个事务已经提交的"),v("code",[t._v("insert")]),t._v(" 的数据导致多次查询结果不一致。")]),t._v(" "),v("h3",{attrs:{id:"spring事务中有哪几种事务传播行为"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务中有哪几种事务传播行为"}},[t._v("#")]),t._v(" Spring事务中有哪几种事务传播行为")]),t._v(" "),v("p",[t._v("事务传播行为指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。")]),t._v(" "),v("p",[t._v("在"),v("code",[t._v("TransactionDefinition")]),t._v("接口中定义了7个表示事务传播行为的常量。")]),t._v(" "),v("p",[t._v("支持当前事务的情况：")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_REQUIRED")]),t._v("：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_SUPPORTS")]),t._v("： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_MANDATORY")]),t._v("： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（"),v("code",[t._v("mandatory")]),t._v("：强制性）。")]),t._v(" "),v("p",[t._v("不支持当前事务的情况：")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_REQUIRES_NEW")]),t._v("： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_NOT_SUPPORTED")]),t._v("： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_NEVER")]),t._v("： 以非事务方式运行，如果当前存在事务，则抛出异常。")]),t._v(" "),v("p",[t._v("其他情况：")]),t._v(" "),v("p",[v("code",[t._v("PROPAGATION_NESTED")]),t._v("： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于"),v("code",[t._v("PROPAGATION_REQUIRED")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"spring支持的事务管理类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring支持的事务管理类型"}},[t._v("#")]),t._v(" Spring支持的事务管理类型")]),t._v(" "),v("p",[t._v("Spring支持两种类型的事务管理：编程式事务管理和声明式事务管理")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("编程式事务管理")]),t._v("：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。")]),t._v(" "),v("li",[v("strong",[t._v("声明式事务管理")]),t._v("：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。")])]),t._v(" "),v("h3",{attrs:{id:"transactional失效场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#transactional失效场景"}},[t._v("#")]),t._v(" Transactional失效场景")]),t._v(" "),v("p",[t._v("Transactional失效场景可以分为三种：")]),t._v(" "),v("ol",[v("li",[t._v("第一种Transactional注解标注方法修饰符为非public时，"),v("code",[t._v("@Transactional")]),t._v("注解将会不起作用。")]),t._v(" "),v("li",[t._v("在类内部调用调用类内部"),v("code",[t._v("@Transactional")]),t._v("标注的方法。这种情况下也会导致事务不开启。")]),t._v(" "),v("li",[t._v("事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。")])]),t._v(" "),v("h2",{attrs:{id:"spring-aop基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop基本概念"}},[t._v("#")]),t._v(" Spring AOP基本概念")]),t._v(" "),v("p",[v("code",[t._v("AOP")]),t._v("（Aspect Orient Programming）,直译过来就是面向切面编程。AOP 是一种编程思想，是面向对象编程（"),v("code",[t._v("OOP")]),t._v("）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。")]),t._v(" "),v("p",[v("code",[t._v("AOP")]),t._v("把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。")]),t._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/spring%E6%A1%86%E6%9E%B6/aop/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B.png",alt:"核心关注点和横切关注点"}})]),t._v(" "),v("p",[t._v("从该图可以很形象地看出，所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。")]),t._v(" "),v("p",[t._v("通过AOP，我们可以在不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码。")]),t._v(" "),v("h3",{attrs:{id:"aop的应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop的应用场景"}},[t._v("#")]),t._v(" AOP的应用场景")]),t._v(" "),v("ul",[v("li",[t._v("日志处理")]),t._v(" "),v("li",[t._v("用户登录")]),t._v(" "),v("li",[t._v("权限（Authentication ）")]),t._v(" "),v("li",[t._v("性能优化（Performance optimization）")]),t._v(" "),v("li",[t._v("事务（Transactions ）")]),t._v(" "),v("li",[t._v("记录跟踪　优化　校准（logging, tracing, profiling and monitoring）")]),t._v(" "),v("li",[t._v("调试（Debugging）")]),t._v(" "),v("li",[t._v("懒加载（Lazy loading）")]),t._v(" "),v("li",[t._v("错误处理（Error handling）")]),t._v(" "),v("li",[t._v("资源池（Resource pooling）")]),t._v(" "),v("li",[t._v("同步（Synchronization）")])]),t._v(" "),v("h3",{attrs:{id:"aop的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop的优点"}},[t._v("#")]),t._v(" AOP的优点")]),t._v(" "),v("ul",[v("li",[t._v("降低模块之间的耦合度。")]),t._v(" "),v("li",[t._v("使系统容易扩展。")]),t._v(" "),v("li",[t._v("更好的代码复用。")])]),t._v(" "),v("h3",{attrs:{id:"aop的底层实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop的底层实现"}},[t._v("#")]),t._v(" AOP的底层实现")]),t._v(" "),v("p",[t._v("AOP 实现的关键在于**[代理模式]**,AOP 主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理的代表为 Spring AOP。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，它会在编译阶段将 AspectJ（切面）weaving（织入）到 Java 字节码中，运行的时候就是增强之后的 AOP 对象。")])]),t._v(" "),v("li",[v("p",[t._v("所谓动态代理，就是 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并调回原对象。")])])]),t._v(" "),v("h3",{attrs:{id:"aop实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop实现方式"}},[t._v("#")]),t._v(" AOP实现方式")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("原理")]),t._v(" "),v("th",[t._v("优点")]),t._v(" "),v("th",[t._v("缺点")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[t._v("静态AOP")])]),t._v(" "),v("td",[t._v("在编译期，切面直接以字节码的形式编译到目标字节 码文件中。"),v("br"),v("strong",[t._v("AspectJ")]),t._v("属于静态AOP，是在编译时进行增强，会在编译的时候"),v("br"),t._v("将AOP逻辑织入到代码中，需要专有的编译器和织入器。")]),t._v(" "),v("td",[t._v("被织入的类性能不受影响。")]),t._v(" "),v("td",[t._v("不够灵活")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("动态AOP(JDK动态代理)")])]),t._v(" "),v("td",[t._v("在运行期，目标类加载后，为接口动态生成代理类，将切面植入到代理类中。"),v("br"),t._v("Java从"),v("strong",[t._v("1.3")]),t._v("引入动态代理。实现原理是为被代理的业务接口生成代理类，"),v("br"),t._v("将AOP逻辑写入到代理类中，在运行时动态织入AOP，使用反射执行织入的逻辑。"),v("br"),t._v("主要实现方式依赖java.lang.reflect包下的InvocationHandler和Proxy类。")]),t._v(" "),v("td",[t._v("Java标准库原生支持，使用简单"),v("br"),t._v("，无需引用额外的包。相对于静态AOP更灵活。")]),t._v(" "),v("td",[t._v("被代理的类必须是接口，灵活性受到一些限制；使用反射会影响一些性能。")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("动态代码字节生成（CGLib）")])]),t._v(" "),v("td",[t._v("在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中。")]),t._v(" "),v("td",[t._v("没有接口也可以织入，灵活性高。")]),t._v(" "),v("td",[t._v("扩展类的实例方法为final时，则无法进行织入")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("自定义类加载器")])]),t._v(" "),v("td",[t._v("在运行期，目标加载前，将切面逻辑加到目标字节码中。")]),t._v(" "),v("td",[t._v("可以对绝大部分类织入。")]),t._v(" "),v("td",[t._v("如果用到了其他类加载器，则这些类将不被织入")])])])]),t._v(" "),v("h3",{attrs:{id:"aop常用术语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop常用术语"}},[t._v("#")]),t._v(" AOP常用术语")]),t._v(" "),v("p",[t._v("AOP 领域中的特性术语：")]),t._v(" "),v("ul",[v("li",[t._v("通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。")]),t._v(" "),v("li",[t._v("连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。")]),t._v(" "),v("li",[t._v("切点（PointCut）: 可以插入增强处理的连接点。")]),t._v(" "),v("li",[t._v("切面（Aspect）: 切面是通知和切点的结合。")]),t._v(" "),v("li",[t._v("引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。")]),t._v(" "),v("li",[t._v("织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。")])]),t._v(" "),v("h3",{attrs:{id:"spring-aop通知类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop通知类型"}},[t._v("#")]),t._v(" Spring AOP通知类型")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("注解")]),t._v(" "),v("th",[t._v("通知")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("@Before")]),t._v(" "),v("td",[t._v("通知方法在目标方法调用前执行")])]),t._v(" "),v("tr",[v("td",[t._v("@After")]),t._v(" "),v("td",[t._v("通知方法在目标方法返回或异常后执行")])]),t._v(" "),v("tr",[v("td",[t._v("@AfterReturning")]),t._v(" "),v("td",[t._v("通知方法在目标方法返回后执行")])]),t._v(" "),v("tr",[v("td",[t._v("@AfterThrowing")]),t._v(" "),v("td",[t._v("通知方法在目标方法异常后执行")])]),t._v(" "),v("tr",[v("td",[t._v("@Around")]),t._v(" "),v("td",[t._v("通知方法将目标方法封装起来")])])])]),t._v(" "),v("h3",{attrs:{id:"spring-aop切点指示器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop切点指示器"}},[t._v("#")]),t._v(" Spring AOP切点指示器")]),t._v(" "),v("p",[t._v("Spring AOP 所支持的 AspectJ 切点指示器")]),t._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/spring%E6%A1%86%E6%9E%B6/aop/%E5%88%87%E7%82%B9%E6%8C%87%E7%A4%BA%E5%99%A8.png",alt:"切点指示器"}})]),t._v(" "),v("p",[t._v("在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。")]),t._v(" "),v("p",[t._v("当我们查看上面展示的这些spring支持的指示器时，注意只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器，在此基础上，我们使用其他指示器来限制所匹配的切点。")]),t._v(" "),v("p",[t._v("下图的切点表达式表示当Instrument的play方法执行时会触发通知。\n"),v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/spring%E6%A1%86%E6%9E%B6/aop/%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%93%E6%9E%84.png",alt:"切点表达式结构"}}),t._v("\n我们使用execution指示器选择Instrument的play方法，方法表达式以 "),v("code",[t._v("*")]),t._v(" 号开始，标识我们不关心方法的返回值类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用 "),v("code",[t._v("..")]),t._v(" 标识切点选择任意的play方法，无论该方法的入参是什么。\n多个匹配之间我们可以使用链接符 "),v("code",[t._v("&&")]),t._v("、"),v("code",[t._v("||")]),t._v("、"),v("code",[t._v("！")]),t._v("来表示 “且”、“或”、“非”的关系。但是在使用 XML 文件配置时，这些符号有特殊的含义，所以我们使用 “and”、“or”、“not”来表示。")]),t._v(" "),v("h3",{attrs:{id:"spring-aop使用示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop使用示例"}},[t._v("#")]),t._v(" Spring AOP使用示例")]),t._v(" "),v("p",[t._v("参考链接 "),v("a",{attrs:{href:"https://www.cnblogs.com/joy99/p/10941543.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用案例"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);