(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{695:function(t,a,s){"use strict";s.r(a);var e=s(74),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是mybatis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是mybatis"}},[t._v("#")]),t._v(" 什么是Mybatis？")]),t._v(" "),a("p",[t._v("1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。")]),t._v(" "),a("p",[t._v("2、MyBatis可以使用 XML或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。")]),t._v(" "),a("p",[t._v("3、通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。")]),t._v(" "),a("h2",{attrs:{id:"mybatis的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的优缺点"}},[t._v("#")]),t._v(" Mybatis的优缺点")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("MyBatis的优点\n1、基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。")]),t._v(" "),a("p",[t._v("2、与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；")]),t._v(" "),a("p",[t._v("3、很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。")]),t._v(" "),a("p",[t._v("4、能够与Spring很好的集成，方便功能开发")]),t._v(" "),a("p",[t._v("5、提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。")])]),t._v(" "),a("li",[a("p",[t._v("MyBatis的缺点")]),t._v(" "),a("p",[t._v("1、SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。\n2、SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。")])])]),t._v(" "),a("h2",{attrs:{id:"mybatis适用的场合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis适用的场合"}},[t._v("#")]),t._v(" MyBatis适用的场合")]),t._v(" "),a("p",[t._v("1、MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。")]),t._v(" "),a("p",[t._v("2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。")]),t._v(" "),a("h2",{attrs:{id:"mybatis与hibernate有哪些不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis与hibernate有哪些不同"}},[t._v("#")]),t._v(" MyBatis与Hibernate有哪些不同？")]),t._v(" "),a("p",[t._v("1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。")]),t._v(" "),a("p",[t._v("2、Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。")]),t._v(" "),a("p",[t._v("3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。")]),t._v(" "),a("h2",{attrs:{id:"mybatis执行流程详情"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis执行流程详情"}},[t._v("#")]),t._v(" MyBatis执行流程详情")]),t._v(" "),a("p",[t._v("我们都知道MyBatis是对JDBC的简易封装，它的出现某种程度了是为了消除所有的JDBC代码和参数的手工设置以及结果集的封装问题；不管怎样，JDBC的那一套还是不会变的，只是做了抽象、封装、归类等；所以想要理解MyBatis的执行流程，那就不得不先回顾一下JDBC的执行流程。")]),t._v(" "),a("ol",[a("li",[t._v("JDBC执行六部走\n"),a("ol",[a("li",[t._v("注册驱动")]),t._v(" "),a("li",[t._v("获取Connection连接")]),t._v(" "),a("li",[t._v("执行预编译")]),t._v(" "),a("li",[t._v("执行SQL")]),t._v(" "),a("li",[t._v("封装结果集")]),t._v(" "),a("li",[t._v("释放资源")])])])]),t._v(" "),a("p",[t._v("以上就是JDBC操作数据的流程步骤，然后我看下ＭyBatis的执行流程图。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/mybatis/MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"MyBatis执行流程图"}})]),t._v(" "),a("p",[t._v("上面流程就是MyBatis内部核心流程，根据图中步骤，我们可以将这个执行流程分成了8个步骤。")]),t._v(" "),a("p",[t._v("1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。")]),t._v(" "),a("p",[t._v("2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。")]),t._v(" "),a("p",[t._v("3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。")]),t._v(" "),a("p",[t._v("4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。")]),t._v(" "),a("p",[t._v("5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。")]),t._v(" "),a("p",[t._v("6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。")]),t._v(" "),a("p",[t._v("7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。")]),t._v(" "),a("p",[t._v("8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。")]),t._v(" "),a("h2",{attrs:{id:"和-的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别是什么"}},[t._v("#")]),t._v(" #{}和${}的区别是什么？")]),t._v(" "),a("p",[a("code",[t._v("#{}")]),t._v("是预编译处理，"),a("code",[t._v("${}")]),t._v("是字符串替换。")]),t._v(" "),a("p",[t._v("Mybatis在处理"),a("code",[t._v("#{}")]),t._v("时，会将sql中的"),a("code",[t._v("#{}")]),t._v("替换为?号，调用PreparedStatement的set方法来赋值；")]),t._v(" "),a("p",[t._v("Mybatis在处理"),a("code",[t._v("${}")]),t._v("时，就是把"),a("code",[t._v("${}")]),t._v("替换成变量的值。")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("#{}")]),t._v("可以有效的防止SQL注入，提高系统安全性。")]),t._v(" "),a("h2",{attrs:{id:"当实体类中的属性名和表中的字段名不一样-怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当实体类中的属性名和表中的字段名不一样-怎么办"}},[t._v("#")]),t._v(" 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？")]),t._v(" "),a("p",[t._v("第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。")]),t._v(" "),a("div",{staticClass:"language-xml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”selectorder”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("parametertype")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”int”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("resultetype")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”me.gacl.domain.order”")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n       select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("select")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("第2种： 通过 "),a("code",[t._v("<resultMap>")]),t._v("来映射字段名和实体类属性名的一一对应的关系。")]),t._v(" "),a("div",{staticClass:"language-xml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("getOrder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("parameterType")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("resultMap")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("orderresultmap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\tselect * from orders where order_id=#{id}\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("select")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("resultMap")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("type")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”me.gacl.domain.order”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”orderresultmap”")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("!–用id属性来映射主键字段–")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("   \n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("id")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("property")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”id”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("column")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”order_id”")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("    \n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("result")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("property")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("“orderno”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("column")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”order_no”/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("result")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("property")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”price”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("column")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("”order_price”/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("reslutMap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("h2",{attrs:{id:"模糊查询like语句该怎么写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模糊查询like语句该怎么写"}},[t._v("#")]),t._v(" 模糊查询like语句该怎么写?")]),t._v(" "),a("p",[t._v("第1种：在Java代码中添加sql通配符。")]),t._v(" "),a("p",[t._v("第2种：在sql语句中拼接通配符，会引起sql注入")]),t._v(" "),a("h2",{attrs:{id:"通常一个xml映射文件-都会写一个dao接口与之对应-请问-这个dao接口的工作原理是什么-dao接口里的方法-参数不同时-方法能重载吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通常一个xml映射文件-都会写一个dao接口与之对应-请问-这个dao接口的工作原理是什么-dao接口里的方法-参数不同时-方法能重载吗"}},[t._v("#")]),t._v(" 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？")]),t._v(" "),a("p",[t._v("Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。")]),t._v(" "),a("p",[t._v("Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个 "),a("code",[t._v("<select>、<insert>、<update>、<delete>")]),t._v("标签，都会被解析为一个MapperStatement对象。")]),t._v(" "),a("p",[t._v("举例： "),a("code",[t._v("com.mybatis3.mappers.StudentDao.findStudentById")]),t._v("，可以唯一找到namespace为 "),a("code",[t._v("com.mybatis3.mappers.StudentDao")]),t._v("下面 id 为 findStudentById 的 MapperStatement。")]),t._v(" "),a("p",[t._v("Mapper接口里的方法，是不能重载的，因为是使用全限名+方法名保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。")]),t._v(" "),a("h2",{attrs:{id:"mybatis是如何进行分页的-分页插件的原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis是如何进行分页的-分页插件的原理是什么"}},[t._v("#")]),t._v(" Mybatis是如何进行分页的？分页插件的原理是什么？")]),t._v(" "),a("p",[t._v("Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。")]),t._v(" "),a("p",[t._v("分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。")]),t._v(" "),a("h2",{attrs:{id:"mybatis是如何将sql执行结果封装为目标对象并返回的-都有哪些映射形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis是如何将sql执行结果封装为目标对象并返回的-都有哪些映射形式"}},[t._v("#")]),t._v(" Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？")]),t._v(" "),a("p",[t._v("第一种是使用 "),a("code",[t._v("<resultMap>")]),t._v("标签，逐一定义数据库列名和对象属性名之间的映射关系。")]),t._v(" "),a("p",[t._v("第二种是使用sql列的别名功能，将列的别名书写为对象属性名。有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。")]),t._v(" "),a("h2",{attrs:{id:"mybatis动态sql有什么用-执行原理-有哪些动态sql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis动态sql有什么用-执行原理-有哪些动态sql"}},[t._v("#")]),t._v(" Mybatis动态sql有什么用？执行原理？有哪些动态sql？")]),t._v(" "),a("p",[t._v("Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值完成逻辑判断并动态拼接sql的功能。\nMybatis提供了9种动态sql标签： trim|where|set|foreach|if|choose|when|otherwise|bind。")]),t._v(" "),a("h2",{attrs:{id:"xml映射文件中-除了常见的select-insert-updae-delete标签之外-还有哪些标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xml映射文件中-除了常见的select-insert-updae-delete标签之外-还有哪些标签"}},[t._v("#")]),t._v(" Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？")]),t._v(" "),a("p",[a("code",[t._v("<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>")]),t._v("，加上动态sql的9个标签，其中 "),a("code",[t._v("<sql>")]),t._v("为sql片段标签，通过 "),a("code",[t._v("<include>")]),t._v("标签引入sql片段， "),a("code",[t._v("<selectKey>")]),t._v("为不支持自增的主键生成策略标签。")]),t._v(" "),a("h2",{attrs:{id:"mybatis实现一对一有几种方式-具体怎么操作的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis实现一对一有几种方式-具体怎么操作的"}},[t._v("#")]),t._v(" MyBatis实现一对一有几种方式?具体怎么操作的？")]),t._v(" "),a("p",[t._v("有联合查询和嵌套查询，联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；")]),t._v(" "),a("p",[t._v("嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。")]),t._v(" "),a("h2",{attrs:{id:"mybatis实现一对多有几种方式-怎么操作的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis实现一对多有几种方式-怎么操作的"}},[t._v("#")]),t._v(" MyBatis实现一对多有几种方式,怎么操作的？")]),t._v(" "),a("p",[t._v("有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的结果的外键id，再去另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。")]),t._v(" "),a("h2",{attrs:{id:"mybatis是否支持延迟加载-如果支持-它的实现原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis是否支持延迟加载-如果支持-它的实现原理是什么"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？")])]),t._v(" "),a("p",[t._v("Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。")]),t._v(" "),a("p",[t._v("它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。")]),t._v(" "),a("p",[t._v("当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。")]),t._v(" "),a("h2",{attrs:{id:"mybatis的一级、二级缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的一级、二级缓存"}},[t._v("#")]),t._v(" Mybatis的一级、二级缓存")]),t._v(" "),a("p",[t._v("1、一级缓存: 一级缓存是SqlSession级别的缓存，每个SqlSession对象都有一个哈希表用于缓存数据，不同SqlSession对象之间缓存不共享。同一个SqlSession对象对象执行2遍相同的SQL查询，在第一次查询执行完毕后将结果缓存起来，这样第二遍查询就不用向数据库查询了，直接返回缓存结果即可。MyBatis默认是开启一级缓存的。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。")]),t._v(" "),a("p",[t._v("2、二级缓存是mapper级别的缓存，二级缓存是跨SqlSession的，多个SqlSession对象可以共享同一个二级缓存。不同的SqlSession对象执行两次相同的SQL语句，第一次会将查询结果进行缓存，第二次查询直接返回二级缓存中的结果即可。MyBatis默认是不开启二级缓存的，可以在配置文件中使用如下配置来开启二级缓存：")]),t._v(" "),a("div",{staticClass:"language-xml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("settings")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("setting")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("cacheEnabled"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("true"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("settings")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("3、对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。")]),t._v(" "),a("h2",{attrs:{id:"什么是mybatis的接口绑定-有哪些实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是mybatis的接口绑定-有哪些实现方式"}},[t._v("#")]),t._v(" 什么是MyBatis的接口绑定？有哪些实现方式？")]),t._v(" "),a("p",[t._v("接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来SqlSession提供的方法我们可以有更加灵活的选择和设置。")]),t._v(" "),a("p",[t._v("接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。")]),t._v(" "),a("h2",{attrs:{id:"使用mybatis的mapper接口调用时有哪些要求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用mybatis的mapper接口调用时有哪些要求"}},[t._v("#")]),t._v(" 使用MyBatis的mapper接口调用时有哪些要求？")]),t._v(" "),a("p",[t._v("1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同；")]),t._v(" "),a("p",[t._v("2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；")]),t._v(" "),a("p",[t._v("3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；")]),t._v(" "),a("p",[t._v("4、Mapper.xml文件中的namespace即是mapper接口的类路径。")]),t._v(" "),a("h2",{attrs:{id:"简述mybatis的插件运行原理-以及如何编写一个插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述mybatis的插件运行原理-以及如何编写一个插件"}},[t._v("#")]),t._v(" 简述Mybatis的插件运行原理，以及如何编写一个插件")]),t._v(" "),a("p",[t._v("Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。")]),t._v(" "),a("p",[t._v("编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。")])])}),[],!1,null,null,null);a.default=r.exports}}]);