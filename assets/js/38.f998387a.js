(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{686:function(v,t,_){"use strict";_.r(t);var r=_(74),o=Object(r.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"dubbo是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo是什么"}},[v._v("#")]),v._v(" Dubbo是什么")]),v._v(" "),t("p",[v._v("Dubbo是一个高性能的远程服务调用的分布式框架。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("集群容错")]),v._v("：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("远程通讯")]),v._v("：提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("自动发现")]),v._v("：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。")])])]),v._v(" "),t("h2",{attrs:{id:"dubbo能做什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo能做什么"}},[v._v("#")]),v._v(" Dubbo能做什么")]),v._v(" "),t("p",[v._v("透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。")]),v._v(" "),t("p",[v._v("软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。")]),v._v(" "),t("p",[v._v("服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。")]),v._v(" "),t("h2",{attrs:{id:"dubbo节点角色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo节点角色"}},[v._v("#")]),v._v(" Dubbo节点角色")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("节点")]),v._v(" "),t("th",[v._v("角色说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("Provider")]),v._v(" "),t("td",[v._v("服务提供者")])]),v._v(" "),t("tr",[t("td",[v._v("Consumer")]),v._v(" "),t("td",[v._v("服务消费者")])]),v._v(" "),t("tr",[t("td",[v._v("Registry")]),v._v(" "),t("td",[v._v("服务注册与发现中心")])]),v._v(" "),t("tr",[t("td",[v._v("Monitor")]),v._v(" "),t("td",[v._v("统计服务的调用次数和调用时间的监控中心")])]),v._v(" "),t("tr",[t("td",[v._v("Container")]),v._v(" "),t("td",[v._v("服务运行容器")])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo核心配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo核心配置"}},[v._v("#")]),v._v(" Dubbo核心配置")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("配置")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("code",[v._v("dubbo:service")])]),v._v(" "),t("td",[v._v("服务配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:reference")])]),v._v(" "),t("td",[v._v("引用配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:protocol")])]),v._v(" "),t("td",[v._v("协议配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:application")])]),v._v(" "),t("td",[v._v("应用配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:module")])]),v._v(" "),t("td",[v._v("模块配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:registry")])]),v._v(" "),t("td",[v._v("注册中心配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:monitor")])]),v._v(" "),t("td",[v._v("监控中心配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:provider")])]),v._v(" "),t("td",[v._v("提供者配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:consumer")])]),v._v(" "),t("td",[v._v("消费者配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:method")])]),v._v(" "),t("td",[v._v("方法配置")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("dubbo:argument")])]),v._v(" "),t("td",[v._v("参数配置")])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo协议"}},[v._v("#")]),v._v(" Dubbo协议")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("协议名称")]),v._v(" "),t("th",[v._v("实现描述")]),v._v(" "),t("th",[v._v("连接")]),v._v(" "),t("th",[v._v("使用场景")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("dubbo")]),v._v(" "),t("td",[v._v("传输：mina、netty、grizzy  序列化：dubbo、hessian2、java、json")]),v._v(" "),t("td",[v._v("dubbo缺省采用单一长连接和NIO异步通讯")]),v._v(" "),t("td",[v._v("1.传入传出参数数据包较小"),t("br"),v._v("  2.消费者比提供者多 "),t("br"),v._v(" 3.常规远程服务方法调用  "),t("br"),v._v("4.不适合传送大数据量的服务，比如文件、传视频")])]),v._v(" "),t("tr",[t("td",[v._v("rmi")]),v._v(" "),t("td",[v._v("传输：java rmi  序列化：java 标准序列化")]),v._v(" "),t("td",[v._v("连接个数：多连接  连接方式：短连接  传输协议：TCP/IP  传输方式：BIO")]),v._v(" "),t("td",[v._v("1.常规RPC调用  "),t("br"),v._v("2.与原RMI客户端互操作  "),t("br"),v._v("3.可传文件  "),t("br"),v._v("4.不支持防火墙穿透")])]),v._v(" "),t("tr",[t("td",[v._v("hessian")]),v._v(" "),t("td",[v._v("传输：Serverlet容器  序列化：hessian二进制序列化")]),v._v(" "),t("td",[v._v("连接个数：多连接   连接方式：短连接   传输协议：HTTP   传输方式：同步传输")]),v._v(" "),t("td",[v._v("1.提供者比消费者多  "),t("br"),v._v("2.可传文件 "),t("br"),v._v(" 3.跨语言传输")])]),v._v(" "),t("tr",[t("td",[v._v("http")]),v._v(" "),t("td",[v._v("传输：servlet容器  序列化：表单序列化")]),v._v(" "),t("td",[v._v("连接个数：多连接   连接方式：短连接   传输协议：HTTP   传输方式：同步传输")]),v._v(" "),t("td",[v._v("1.提供者多于消费者  "),t("br"),v._v("2.数据包混合")])]),v._v(" "),t("tr",[t("td",[v._v("webservice")]),v._v(" "),t("td",[v._v("传输：HTTP  序列化：SOAP文件序列化")]),v._v(" "),t("td",[v._v("连接个数：多连接   连接方式：短连接   传输协议：HTTP   传输方式：同步传输")]),v._v(" "),t("td",[v._v("1.系统集成  "),t("br"),v._v("2.跨语言调用")])]),v._v(" "),t("tr",[t("td",[v._v("thrift")]),v._v(" "),t("td",[v._v("与thrift RPC实现集成，并在基础上修改了报文头")]),v._v(" "),t("td",[v._v("长连接、NIO异步传输")]),v._v(" "),t("td")])])]),v._v(" "),t("h2",{attrs:{id:"dubbo支持的序列化方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo支持的序列化方式"}},[v._v("#")]),v._v(" Dubbo支持的序列化方式")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("序列化方式")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("dubbo序列化")]),v._v(" "),t("td",[v._v("阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它")])]),v._v(" "),t("tr",[t("td",[v._v("hessian2序列化(默认推荐)")]),v._v(" "),t("td",[v._v("hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式")])]),v._v(" "),t("tr",[t("td",[v._v("json序列化")]),v._v(" "),t("td",[v._v("目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。")])]),v._v(" "),t("tr",[t("td",[v._v("java序列化")]),v._v(" "),t("td",[v._v("主要是采用JDK自带的Java序列化实现，性能很不理想。")])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo集群容错方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo集群容错方案"}},[v._v("#")]),v._v(" Dubbo集群容错方案")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("方案")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("code",[v._v("FailOver Cluster")])]),v._v(" "),t("td",[v._v("失败自动切换，自动尝试其它服务器（默认）")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("Failfast Cluster")])]),v._v(" "),t("td",[v._v("快速失败，立即报错")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("Failsafe Cluster")])]),v._v(" "),t("td",[v._v("失败安全，出现异常直接忽略")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("Failback Cluster")])]),v._v(" "),t("td",[v._v("失败自动恢复，记录失败请求，定时重发")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("Forking Cluster")])]),v._v(" "),t("td",[v._v("并行调用多个服务器，只要有一个成功即返回")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("Broadcast Cluster")])]),v._v(" "),t("td",[v._v("广播逐个调用所有服务提供者，任意一个报错即报错")])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo负载均衡方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo负载均衡方案"}},[v._v("#")]),v._v(" Dubbo负载均衡方案")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("负载均衡方案")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("code",[v._v("Random LoadBalance")])]),v._v(" "),t("td",[v._v("随机，按权重设置随机概率")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("RoundRobin LoadBalance")])]),v._v(" "),t("td",[v._v("轮询，按公约后的权重设置轮询比例")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("LeastActive LoadBalance")])]),v._v(" "),t("td",[v._v("最少活跃数调用，相同活跃数的随机")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("ConsistentHash LoadBalance")])]),v._v(" "),t("td",[v._v("一致性hash，相同参数的请求总是发送到同一提供者")])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo使用的设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo使用的设计模式"}},[v._v("#")]),v._v(" Dubbo使用的设计模式")]),v._v(" "),t("h3",{attrs:{id:"责任链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式"}},[v._v("#")]),v._v(" 责任链模式")]),v._v(" "),t("p",[v._v("责任链模式在Dubbo中发挥的作用举足轻重，就像是Dubbo框架的骨架。Dubbo的调用链组织是用责任链模式串连起来的。责任链中的每个节点实现"),t("code",[v._v("Filter")]),v._v("接口，然后由"),t("code",[v._v("ProtocolFilterWrapper")]),v._v("，将所有"),t("code",[v._v("Filter")]),v._v("串连起来。Dubbo的许多功能都是通过"),t("code",[v._v("Filter")]),v._v("扩展实现的，比如监控、日志、缓存、安全、telnet以及RPC本身都是。如果把Dubbo比作一列火车，责任链就像是火车的各车厢，每个车厢的功能不同。如果需要加入新的功能，增加车厢就可以了，非常容易扩展。")]),v._v(" "),t("h3",{attrs:{id:"观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[v._v("#")]),v._v(" 观察者模式")]),v._v(" "),t("p",[v._v("Dubbo中使用观察者模式最典型的例子是"),t("code",[v._v("RegistryService")]),v._v("。消费者在初始化的时候回调用subscribe方法，注册一个观察者，如果观察者引用的服务地址列表发生改变，就会通过"),t("code",[v._v("NotifyListener")]),v._v("通知消费者。此外，Dubbo的"),t("code",[v._v("InvokerListener")]),v._v("、"),t("code",[v._v("ExporterListener")]),v._v(" 也实现了观察者模式，只要实现该接口，并注册，就可以接收到consumer端调用refer和provider端调用export的通知。Dubbo的注册/订阅模型和观察者模式就是天生一对。")]),v._v(" "),t("h3",{attrs:{id:"修饰器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰器模式"}},[v._v("#")]),v._v(" 修饰器模式")]),v._v(" "),t("p",[v._v("Dubbo中还大量用到了修饰器模式。比如"),t("code",[v._v("ProtocolFilterWrapper")]),v._v("类是对Protocol类的修饰。在export和refer方法中，配合责任链模式，把Filter组装成责任链，实现对Protocol功能的修饰。其他还有"),t("code",[v._v("ProtocolListenerWrapper")]),v._v("、 "),t("code",[v._v("ListenerInvokerWrapper")]),v._v("、"),t("code",[v._v("InvokerWrapper")]),v._v("等。个人感觉，修饰器模式是一把双刃剑，一方面用它可以方便地扩展类的功能，而且对用户无感，但另一方面，过多地使用修饰器模式不利于理解，因为一个类可能经过层层修饰，最终的行为已经和原始行为偏离较大。")]),v._v(" "),t("h3",{attrs:{id:"工厂方法模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[v._v("#")]),v._v(" 工厂方法模式")]),v._v(" "),t("p",[t("code",[v._v("CacheFactory")]),v._v("的实现采用的是工厂方法模式。"),t("code",[v._v("CacheFactory")]),v._v("接口定义getCache方法，然后定义一个"),t("code",[v._v("AbstractCacheFactory")]),v._v("抽象类实现"),t("code",[v._v("CacheFactory")]),v._v("，并将实际创建cache的createCache方法分离出来，并设置为抽象方法。这样具体cache的创建工作就留给具体的子类去完成。")]),v._v(" "),t("h3",{attrs:{id:"抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[v._v("#")]),v._v(" 抽象工厂模式")]),v._v(" "),t("p",[t("code",[v._v("ProxyFactory")]),v._v("及其子类是Dubbo中使用抽象工厂模式的典型例子。"),t("code",[v._v("ProxyFactory")]),v._v("提供两个方法，分别用来生产"),t("code",[v._v("Proxy")]),v._v("和"),t("code",[v._v("Invoker")]),v._v("（这两个方法签名看起来有些矛盾，因为getProxy方法需要传入一个Invoker对象，而getInvoker方法需要传入一个"),t("code",[v._v("Proxy")]),v._v("对象，看起来会形成循环依赖，但其实两个方式使用的场景不一样）。"),t("code",[v._v("AbstractProxyFactory")]),v._v("实现了"),t("code",[v._v("ProxyFactory")]),v._v("接口，作为具体实现类的抽象父类。然后定义了"),t("code",[v._v("JdkProxyFactory")]),v._v("和"),t("code",[v._v("JavassistProxyFactory")]),v._v("两个具体类，分别用来生产基于jdk代理机制和基于javassist代理机制的"),t("code",[v._v("Proxy")]),v._v("和"),t("code",[v._v("Invoker")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[v._v("#")]),v._v(" 适配器模式")]),v._v(" "),t("p",[v._v("为了让用户根据自己的需求选择日志组件，Dubbo自定义了自己的Logger接口，并为常见的日志组件（包括jcl, jdk, log4j, slf4j）提供相应的适配器。并且利用简单工厂模式提供一个"),t("code",[v._v("LoggerFactory")]),v._v("，客户可以创建抽象的Dubbo自定义"),t("code",[v._v("Logger")]),v._v("，而无需关心实际使用的日志组件类型。在LoggerFactory初始化时，客户通过设置系统变量的方式选择自己所用的日志组件，这样提供了很大的灵活性。")]),v._v(" "),t("h3",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[v._v("#")]),v._v(" 代理模式")]),v._v(" "),t("p",[v._v("Dubbo consumer使用"),t("code",[v._v("Proxy")]),v._v("类创建远程服务的本地代理，本地代理实现和远程服务一样的接口，并且屏蔽了网络通信的细节，使得用户在使用本地代理的时候，感觉和使用本地服务一样。")])])}),[],!1,null,null,null);t.default=o.exports}}]);