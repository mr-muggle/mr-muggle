(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{689:function(t,v,a){"use strict";a.r(v);var _=a(74),e=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"创建线程的三种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建线程的三种方式"}},[t._v("#")]),t._v(" 创建线程的三种方式")]),t._v(" "),v("p",[t._v("java 多线程很常见，如何使用多线程，如何创建线程，java 中有三种方式：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("通过继承Thread接口")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("通过实现Runnable接口")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("通过实现Callable接口")])])])]),t._v(" "),v("p",[t._v("上面三种方式更推荐通过实现 "),v("code",[t._v("Runnable")]),t._v("接口和实现 "),v("code",[t._v("Callable接口")]),t._v("，因为面向接口编程拓展性更好，而且可以防止 java 单继承的限制。")]),t._v(" "),v("h2",{attrs:{id:"多线程产生死锁的条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程产生死锁的条件"}},[t._v("#")]),t._v(" 多线程产生死锁的条件")]),t._v(" "),v("ul",[v("li",[t._v("互斥条件：该资源任意一个时刻只能由一个线程占用。")]),t._v(" "),v("li",[t._v("请求与保持条件：一个进程因请求资源而被阻塞时，对已获得的资源保持不放。")]),t._v(" "),v("li",[t._v("不剥夺条件：吸纳成已获得的资源在未使用完之前不能被其它线程强行剥夺，只有自己使用完毕后才释放资源。")]),t._v(" "),v("li",[t._v("循环等待条件：若干进程间形成头尾相接的循环等待资源关系。")])]),t._v(" "),v("h2",{attrs:{id:"sleep-和wait-方法得区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sleep-和wait-方法得区别"}},[t._v("#")]),t._v(" sleep()和wait()方法得区别")]),t._v(" "),v("p",[t._v("两者主要的区别：")]),t._v(" "),v("p",[t._v("sleep()方法是Thread的静态方法，而wait是Object实例方法")]),t._v(" "),v("p",[t._v("wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；")]),t._v(" "),v("p",[t._v("sleep()方法在休眠时间达到后，如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。")]),t._v(" "),v("h2",{attrs:{id:"如何避免线程死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何避免线程死锁"}},[t._v("#")]),t._v(" 如何避免线程死锁")]),t._v(" "),v("p",[t._v("我们只要破坏产生死锁的四个条件中的其中一个就可以了。")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("破坏互斥条件")]),t._v("：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("破坏请求与保持条件")]),t._v("：一次性申请所有的资源。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("破坏不剥夺条件")]),t._v("：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("破坏循环等待条件")]),t._v("：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。")])])])])}),[],!1,null,null,null);v.default=e.exports}}]);