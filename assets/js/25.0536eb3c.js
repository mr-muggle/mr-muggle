(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{678:function(t,e,l){"use strict";l.r(e);var _=l(74),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"定位慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定位慢查询"}},[t._v("#")]),t._v(" 定位慢查询")]),t._v(" "),e("p",[t._v("在工作中可能会遇到某个新功能在测试时需要很久才返回结果，这时就应该分析是不是慢查询导致的。如果确实有慢查询，又应该怎么去分析 SQL 执行效率呢？这一篇文章我们就来学习怎么找到慢查询和怎么分析 SQL 执行效率。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95.png",alt:"定位慢查询"}})]),t._v(" "),e("h2",{attrs:{id:"使用诊断工具分析慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用诊断工具分析慢查询"}},[t._v("#")]),t._v(" 使用诊断工具分析慢查询")]),t._v(" "),e("p",[t._v("定位到慢查询语句后，我们就要开始分析 SQL 执行效率了，对此，我们可以通过"),e("code",[t._v("explain")]),t._v("、"),e("code",[t._v("show profile")]),t._v(" 和 "),e("code",[t._v("trace")]),t._v(" 等诊断工具来分析慢查询。")]),t._v(" "),e("h3",{attrs:{id:"使用explain诊断工具分析慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用explain诊断工具分析慢查询"}},[t._v("#")]),t._v(" 使用"),e("code",[t._v("explain")]),t._v("诊断工具分析慢查询")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BD%BF%E7%94%A8explain%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2.png",alt:"使用explain诊断工具分析慢查询"}})]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("explain")]),t._v("各字段的含义")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("列名")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("解释")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("id")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("查询编号")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("select_type")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("查询类型：显示本行是简单还是复杂查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("table")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("涉及到的表")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("partitions")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("type")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("本次查询的表连接类型")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("possible_keys")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("可能选择的索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("key")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("实际选择的索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("key_len")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("被选择的索引长度：一般用于判断联合索引有多少列被选择了")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("ref")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("与索引比较的列")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("rows")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("filtered")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("按条件筛选的行的百分比")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("strong",[t._v("Extra")])]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("附加信息")])])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("select_type")]),t._v("各值的含义")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("select_type 的值")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("解释")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("SIMPLE")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("简单查询 (不使用关联查询或子查询)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("PRIMARY")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("如果包含关联查询或者子查询，则最外层的查询部分标记为 primary")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UNION")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("联合查询中第二个及后面的查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("DEPENDENT UNION")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("满足依赖外部的关联查询中第二个及以后的查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UNION RESULT")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("联合查询的结果")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("SUBQUERY")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("子查询中的第一个查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("DEPENDENT SUBQUERY")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("子查询中的第一个查询，并且依赖外部查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("DERIVED")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("用到派生表的查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("MATERIALIZED")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("被物化的子查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UNCACHEABLE SUBQUERY")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("一个子查询的结果不能被缓存，必须重新评估外层查询的每一行")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UNCACHEABLE UNION")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("关联查询第二个或后面的语句属于不可缓存的子查询")])])])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("type")]),t._v("各值的含义")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("type 的值")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("解释")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("system")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("查询对象表只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("const")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("基于主键或唯一索引查询，最多返回一条结果")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("eq_ref")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("表连接时基于主键或非 NULL 的唯一索引完成扫描")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("ref")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("基于普通索引的等值查询，或者表间等值连接")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("fulltext")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("全文检索")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("ref_or_null")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("index_merge")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("利用多个索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("unique_subquery")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("子查询中使用唯一索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("index_subquery")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("子查询中使用普通索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("range")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("利用索引进行范围查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("index")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("全索引扫描")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("ALL")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("全表扫描")])])])]),t._v(" "),e("p",[e("strong",[t._v("上表的这些情况，查询性能从上到下依次是最好到最差。")])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("Extra")]),t._v("各值的含义")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Extra 常见的值解释例子")]),t._v(" "),e("th",[t._v("解释")]),t._v(" "),e("th",[t._v("例子")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("Using filesort")]),t._v(" "),e("td",[t._v("将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序")]),t._v(" "),e("td",[t._v("explain select * from t1 order by create_time;")])]),t._v(" "),e("tr",[e("td",[t._v("Using temporary")]),t._v(" "),e("td",[t._v("需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时")]),t._v(" "),e("td",[t._v("explain select * from t1 group by create_time;")])]),t._v(" "),e("tr",[e("td",[t._v("Using index")]),t._v(" "),e("td",[t._v("使用覆盖索引")]),t._v(" "),e("td",[t._v("explain select a from t1 where a=111;")])]),t._v(" "),e("tr",[e("td",[t._v("Using where")]),t._v(" "),e("td",[t._v("使用 where 语句来处理结果")]),t._v(" "),e("td",[t._v("explain select * from t1 where create_time=‘2019-06-18 14:38:24’;")])]),t._v(" "),e("tr",[e("td",[t._v("Impossible WHERE")]),t._v(" "),e("td",[t._v("对 where 子句判断的结果总是 false 而不能选择任何数据")]),t._v(" "),e("td",[t._v("explain select * from t1 where 1<0;")])]),t._v(" "),e("tr",[e("td",[t._v("Using join buffer (Block Nested Loop)")]),t._v(" "),e("td",[t._v("关联查询中，被驱动表的关联字段没索引")]),t._v(" "),e("td",[t._v("explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);")])]),t._v(" "),e("tr",[e("td",[t._v("Using index condition")]),t._v(" "),e("td",[t._v("先条件过滤索引，再查数据")]),t._v(" "),e("td",[t._v("explain select * from t1 where a >900 and a like “%9”;")])]),t._v(" "),e("tr",[e("td",[t._v("Select tables optimized away")]),t._v(" "),e("td",[t._v("使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时")]),t._v(" "),e("td",[t._v("explain select max(a) from t1;")])])])])])]),t._v(" "),e("h3",{attrs:{id:"使用show-profile诊断工具分析慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用show-profile诊断工具分析慢查询"}},[t._v("#")]),t._v(" 使用"),e("code",[t._v("show profile")]),t._v("诊断工具分析慢查询")]),t._v(" "),e("p",[t._v("有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BD%BF%E7%94%A8profile%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2.png",alt:"使用诊断工具profile分析慢查询"}})]),t._v(" "),e("h3",{attrs:{id:"使用trace诊断工具分析慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用trace诊断工具分析慢查询"}},[t._v("#")]),t._v(" 使用"),e("code",[t._v("trace")]),t._v("诊断工具分析慢查询")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BD%BF%E7%94%A8trace%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2.png",alt:"使用trace诊断工具分析慢查询"}})]),t._v(" "),e("h2",{attrs:{id:"条件字段有索引-不走索引的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#条件字段有索引-不走索引的情况"}},[t._v("#")]),t._v(" 条件字段有索引，不走索引的情况")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95.png",alt:"MySQL条件字段有索引但是不走索引的情况"}})]),t._v(" "),e("h2",{attrs:{id:"数据导入速度优化思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据导入速度优化思路"}},[t._v("#")]),t._v(" 数据导入速度优化思路")]),t._v(" "),e("p",[t._v("我们有时会遇到批量数据导入的场景，而数据量稍微大点，会发现导入非常耗时间。我们可以采用以下方式优化。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("一次插入多行的值；插入行所需的时间，大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。建议"),e("strong",[t._v("有大批量导入时，推荐一条insert语句插入多行数据。")])])]),t._v(" "),e("li",[e("p",[t._v("关闭自动提交，多次插入数据的 SQL 一次提交；使用"),e("code",[t._v("SET autocommit=0;")]),t._v("命令关闭自动提交。因为批量导入大部分时间耗费在客户端与服务端通信的时间，所以多条 insert 语句合并提交可以减少客户端与服务端通信的时间，并且合并提交还可以减少数据落盘的次数。")])]),t._v(" "),e("li",[e("p",[t._v("调整参数，innodb_flush_log_at_trx_commit 和 sync_binlog 都设置为0（当然这种情况可能会丢数据）。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%BD%B1%E5%93%8DMySQL%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0.png",alt:"影响MySQL数据写入数据的两个参数.png"}})])])]),t._v(" "),e("h2",{attrs:{id:"排序-分组查询优化思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排序-分组查询优化思路"}},[t._v("#")]),t._v(" 排序，分组查询优化思路")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%AE%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%96%B9%E6%B3%95.png",alt:"让排序和分组更快的方法"}})]),t._v(" "),e("h2",{attrs:{id:"分页查询优化思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分页查询优化思路"}},[t._v("#")]),t._v(" 分页查询优化思路")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF.png",alt:"分页查询优化思路"}})]),t._v(" "),e("h2",{attrs:{id:"关联查询优化思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关联查询优化思路"}},[t._v("#")]),t._v(" 关联查询优化思路")]),t._v(" "),e("p",[t._v("我们在使用数据库查询数据时，有时一张表并不能满足我们的需求，很多时候都涉及到多张表的连接查询。今天，我们就一起研究关联查询的一些优化技巧。在说关联查询优化之前，我们先看下跟关联查询有关的几个算法：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95.png",alt:"关联查询的三种算法"}})]),t._v(" "),e("p",[t._v("通过上面的内容，我们知道了 BNL、NLJ 和 BKA 的原理，因此让 BNL变成 NLJ 或者 BKA，可以提高 join 的效率。下面我们可以采用以下方式来优化关联查询。")]),t._v(" "),e("ul",[e("li",[t._v("对被驱动表关联字段添加索引，让 BNL变成 NLJ 或者 BKA。")]),t._v(" "),e("li",[t._v("在写 SQL 时，如果确定被关联字段有索引的情况下，建议用小表做驱动表。")]),t._v(" "),e("li",[t._v("当遇到 BNL 的 join 语句，如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);