(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{681:function(s,a,t){"use strict";t.r(a);var _=t(74),v=Object(_.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"mysql中的锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql中的锁"}},[s._v("#")]),s._v(" MySQL中的锁")]),s._v(" "),a("p",[s._v("MySQL 中，锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。")]),s._v(" "),a("p",[s._v("根据加锁的范围，MySQL 中的锁可分为三类：")]),s._v(" "),a("ul",[a("li",[s._v("全局锁")]),s._v(" "),a("li",[s._v("表级锁")]),s._v(" "),a("li",[s._v("行锁")])]),s._v(" "),a("h2",{attrs:{id:"全局锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[s._v("#")]),s._v(" 全局锁")]),s._v(" "),a("p",[s._v("MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v("FLUSH "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WITH")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("简称：FTWRL，可以使用下面命令解锁：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNLOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[a("strong",[s._v("作用")]),s._v("：当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。")]),s._v(" "),a("p",[a("strong",[s._v("应用场景")]),s._v("：全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。")]),s._v(" "),a("p",[s._v("好在 mysqldump 包含一个参数 --single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。")]),s._v(" "),a("p",[s._v("而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 --master-data，可以避免使用全局锁。")]),s._v(" "),a("h2",{attrs:{id:"表级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[s._v("#")]),s._v(" 表级锁")]),s._v(" "),a("p",[s._v("表级锁有两种：表锁和元数据锁。")]),s._v(" "),a("h3",{attrs:{id:"表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[s._v("#")]),s._v(" 表锁")]),s._v(" "),a("p",[a("strong",[s._v("表锁使用场景")]),s._v("：")]),s._v(" "),a("ol",[a("li",[a("p",[a("strong",[s._v("事务需要更新某张大表的大部分或全部数据。")]),s._v(" 如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("事务涉及多个表，比较复杂")]),s._v("，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。")])])]),s._v(" "),a("p",[s._v("其中表锁又分为表读锁和表写锁，命令分别是：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("表读锁：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("lock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("tables")]),s._v(" tableName "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("read")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[a("strong",[s._v("对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。")])])]),s._v(" "),a("li",[a("p",[s._v("表写锁：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("lock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("tables")]),s._v(" tableName  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[a("strong",[s._v("对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。")])])])]),s._v(" "),a("h3",{attrs:{id:"元数据锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁"}},[s._v("#")]),s._v(" 元数据锁")]),s._v(" "),a("p",[a("strong",[s._v("元数据锁的使用场景：")])]),s._v(" "),a("p",[s._v("​\t在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 "),a("a",{attrs:{href:"https://bugs.mysql.com/bug.php?id=989",target:"_blank",rel:"noopener noreferrer"}},[s._v("bug#989"),a("OutboundLink")],1),s._v("）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）")]),s._v(" "),a("p",[a("strong",[s._v("作用：")]),s._v(" MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。")]),s._v(" "),a("p",[a("strong",[s._v("对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。")])]),s._v(" "),a("h3",{attrs:{id:"行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[s._v("#")]),s._v(" 行锁")]),s._v(" "),a("p",[s._v("MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：")]),s._v(" "),a("ul",[a("li",[s._v("InnoDB 支持事务：适合在并发条件下要求数据一致的场景。")]),s._v(" "),a("li",[s._v("InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。")])]),s._v(" "),a("p",[s._v("在讲解行锁之前，我们首先来看一下两阶段锁协议。")]),s._v(" "),a("p",[s._v("传统的关系型数据库加锁的一个原则是：两阶段锁原则。两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。")]),s._v(" "),a("p",[s._v("InnoDB 实现了以下两种类型的行锁：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；")])]),s._v(" "),a("li",[a("p",[s._v("排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。")]),s._v(" "),a("p",[s._v("对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：")])]),s._v(" "),a("li",[a("p",[s._v("共享锁（S）：select * from table_name where … lock in share mode;")])]),s._v(" "),a("li",[a("p",[s._v("排他锁（X）：select * from table_name where … for update。")])])]),s._v(" "),a("p",[s._v("InnoDB 行锁的三种算法：")]),s._v(" "),a("ul",[a("li",[s._v("Record Lock：单个记录上的索引加锁。")]),s._v(" "),a("li",[s._v("Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。")]),s._v(" "),a("li",[s._v("Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。")])]),s._v(" "),a("h2",{attrs:{id:"死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[s._v("#")]),s._v(" 死锁")]),s._v(" "),a("p",[s._v("死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。")]),s._v(" "),a("p",[s._v("InnoDB 中解决死锁问题有两种方式：")]),s._v(" "),a("ol",[a("li",[s._v("检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；")]),s._v(" "),a("li",[s._v("等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。")])]),s._v(" "),a("p",[s._v("一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。")]),s._v(" "),a("p",[s._v("出现死锁的原因：")]),s._v(" "),a("ul",[a("li",[s._v("不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁；")]),s._v(" "),a("li",[s._v("不同线程并发访问多个表时，未按顺序访问导致死锁；")]),s._v(" "),a("li",[s._v("RR 隔离级别下，由于间隙锁导致死锁。")])]),s._v(" "),a("p",[s._v("那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：")]),s._v(" "),a("ol",[a("li",[s._v("更新 SQL 的 where 条件尽量用索引；")]),s._v(" "),a("li",[s._v("基于 primary 或 unique key 更新数据；")]),s._v(" "),a("li",[s._v("减少范围更新，尤其非主键、非唯一索引上的范围更新；")]),s._v(" "),a("li",[s._v("加锁顺序一致，尽可能一次性锁定所有需要行；")]),s._v(" "),a("li",[s._v("将 RR 隔离级别调整为 RC 隔离级别。")])]),s._v(" "),a("p",[s._v("尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。")]),s._v(" "),a("p",[s._v("InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息。")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("engine")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("innodb")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("status")]),s._v("\\G\n")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);