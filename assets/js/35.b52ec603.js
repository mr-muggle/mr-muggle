(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{684:function(e,a,t){"use strict";t.r(a);var s=t(74),v=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"rdb持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化机制"}},[e._v("#")]),e._v(" RDB持久化机制")]),e._v(" "),a("p",[e._v("RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程可以分为手动触发和自动触发。")]),e._v(" "),a("p",[e._v("在Redis中，总共支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。")]),e._v(" "),a("h3",{attrs:{id:"rdb手动触发持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb手动触发持久化机制"}},[e._v("#")]),e._v(" RDB手动触发持久化机制")]),e._v(" "),a("p",[e._v("手动触发分别对应"),a("code",[e._v("save")]),e._v("和"),a("code",[e._v("bgsave")]),e._v("命令")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("save")]),e._v("命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。运行"),a("code",[e._v("save")]),e._v("命令对应 的Redis日志如下：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("* DB saved on disk\n")])])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("bgsave")]),e._v("命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。运行"),a("code",[e._v("bgsave")]),e._v("命令对应的Redis日志如下：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("* Background saving started by pid "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3151")]),e._v("\n* DB saved on disk\n* RDB: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v(" MB of memory used by copy-on-write\n* Background saving terminated with success\n")])])])])]),e._v(" "),a("p",[e._v("显然"),a("code",[e._v("bgsave")]),e._v("命令是针对"),a("code",[e._v("save")]),e._v("命令阻塞问题做的优化。"),a("strong",[e._v("因此Redis内部所有的涉及RDB的操作都采用"),a("code",[e._v("bgsave")]),e._v("的方式，而"),a("code",[e._v("save")]),e._v("命令已经废弃。")])]),e._v(" "),a("h3",{attrs:{id:"rdb自动触发持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb自动触发持久化机制"}},[e._v("#")]),e._v(" RDB自动触发持久化机制")]),e._v(" "),a("p",[e._v("除了执行命令手动触发之外，Redis内部还存在自动触发RDB的持久化 机制，例如以下场景：")]),e._v(" "),a("ul",[a("li",[e._v("使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发"),a("code",[e._v("bgsave")]),e._v("。")]),e._v(" "),a("li",[e._v("如果从节点执行全量复制操作，主节点自动执行"),a("code",[e._v("bgsave")]),e._v("生成RDB文件并发送给从节点。")]),e._v(" "),a("li",[e._v("执行"),a("code",[e._v("debug reload")]),e._v("命令重新加载Redis时，也会自动触发save操作。")]),e._v(" "),a("li",[e._v("默认情况下执行"),a("code",[e._v("shutdown")]),e._v("命令时，如果没有开启AOF持久化功能则自动执行"),a("code",[e._v("bgsave")]),e._v("。")])]),e._v(" "),a("h3",{attrs:{id:"bgsave命令触发rdb持久化流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bgsave命令触发rdb持久化流程"}},[e._v("#")]),e._v(" "),a("code",[e._v("bgsave")]),e._v("命令触发RDB持久化流程")]),e._v(" "),a("p",[a("code",[e._v("bgsave")]),e._v("是主流的触发RDB持久化方式，大致可以分为以下5个步骤：")]),e._v(" "),a("ol",[a("li",[e._v("执行"),a("code",[e._v("bgsave")]),e._v("命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在"),a("code",[e._v("bgsave")]),e._v("命令则直接返回。")]),e._v(" "),a("li",[e._v("父进程执行"),a("code",[e._v("fork")]),e._v("操作创建子进程，fork操作过程中父进程会阻塞，通 过"),a("code",[e._v("info stats")]),e._v("命令查看"),a("code",[e._v("latest_fork_usec")]),e._v("选项，可以获取最近一个fork操作的耗时，单位为微秒。")]),e._v(" "),a("li",[e._v("父进程fork完成后，"),a("code",[e._v("bgsave")]),e._v("命令返回“Background saving started”信息 并不再阻塞父进程，可以继续响应其他命令。")]),e._v(" "),a("li",[e._v("子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行"),a("code",[e._v("lastsave")]),e._v("命令可以获取最后一次生成RDB的时间，对应"),a("code",[e._v("info")]),e._v("统计的"),a("code",[e._v("rdb_last_save_time")]),e._v("选项。")]),e._v(" "),a("li",[e._v("进程发送信号给父进程表示完成，父进程更新统计信息。")])]),e._v(" "),a("h3",{attrs:{id:"rdb文件的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb文件的处理"}},[e._v("#")]),e._v(" RDB文件的处理")]),e._v(" "),a("p",[e._v("RDB文件的处理主要可以分为三种：保存、压缩、校验。")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[e._v("保存")]),e._v("：RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定。可以通过执行"),a("code",[e._v("config set dir {newDir}")]),e._v("和"),a("code",[e._v("config set dbfilename {newFileName}")]),e._v("运行期动态执行，"),a("strong",[e._v("当下次运行时RDB文件会保存到新目录。")])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("压缩")]),e._v("：Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的 文件远远小于内存大小，默认开启，可以通过参数"),a("code",[e._v("config set rdbcompression {yes|no}")]),e._v("动态修改。")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),a("p",[e._v("虽然压缩RDB会消耗CPU，但可大幅降低文件的体积，方便保存到硬盘 或通过网络发送给从节点，因此线上建议开启。")])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("校验")]),e._v("：如果Redis加载损坏的RDB文件时拒绝启动，并打印如下日志：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Short read or OOM loading DB. Unrecoverable error, aborting now.")]),e._v("\n")])])]),a("p",[e._v("这时可以使用Redis提供的redis-check-dump工具检测RDB文件并获取对应的错误报告。")])])]),e._v(" "),a("h3",{attrs:{id:"rdb文件的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb文件的优缺点"}},[e._v("#")]),e._v(" RDB文件的优缺点")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("RDB文件的优点：")]),e._v(" "),a("ol",[a("li",[e._v("RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行"),a("code",[e._v("bgsave")]),e._v("备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。")]),e._v(" "),a("li",[e._v("Redis加载RDB恢复数据远远快于AOF的方式。")])])]),e._v(" "),a("li",[a("p",[e._v("RDB的缺点：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("RDB方式数据没办法做到实时持久化/秒级持久化。因为"),a("code",[e._v("bgsave")]),e._v("命令每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。")])]),e._v(" "),a("li",[a("p",[e._v("RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。")])])])])]),e._v(" "),a("p",[e._v("针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。")]),e._v(" "),a("h2",{attrs:{id:"aof持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化机制"}},[e._v("#")]),e._v(" AOF持久化机制")]),e._v(" "),a("p",[e._v("AOF（append only file）持久化，以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，"),a("strong",[e._v("目前已经是Redis持久化的主流方式。")])]),e._v(" "),a("p",[e._v("开启AOF功能需要设置配置："),a("code",[e._v("appendonly yes")]),e._v("，默认不开启。AOF文件名通过appendfilename配置设置，默认文件名是"),a("code",[e._v("appendonly.aof")]),e._v("。保存路径同RDB持久化方式一致，通过dir配置指定。")]),e._v(" "),a("h3",{attrs:{id:"aof触发持久化流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof触发持久化流程"}},[e._v("#")]),e._v(" AOF触发持久化流程")]),e._v(" "),a("p",[e._v("AOF触发持久化流程大致可以分为以下四个步骤：")]),e._v(" "),a("ol",[a("li",[e._v("命令写入（append）：所有的写入命令会追加到aof_buf（缓冲区）中。")]),e._v(" "),a("li",[e._v("文件同步（sync）：AOF缓冲区根据对应的策略向硬盘做同步操作。")]),e._v(" "),a("li",[e._v("文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。")]),e._v(" "),a("li",[e._v("重启加载 （load）：当Redis服务器重启时，可以加载AOF文件进行数据恢复。")])]),e._v(" "),a("h3",{attrs:{id:"aof触发持久化流程-命令写入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof触发持久化流程-命令写入"}},[e._v("#")]),e._v(" AOF触发持久化流程-命令写入")]),e._v(" "),a("p",[e._v("AOF命令写入的内容直接是文本协议格式。例如"),a("code",[e._v("set hello world")]),e._v("这条命令，在AOF缓冲区会追加如下文本：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("*3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("n"),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("nset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("n"),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("nhello"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("n"),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("nworld"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("n\n")])])]),a("p",[e._v("AOF直接采用文本协议格式有以下优势：")]),e._v(" "),a("ul",[a("li",[e._v("文本协议具有很好的兼容性。")]),e._v(" "),a("li",[e._v("开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。")]),e._v(" "),a("li",[e._v("文本协议具有可读性，方便直接修改和处理。")])]),e._v(" "),a("p",[e._v("至于AOF把命令追加到aof_buf中，主要是由于以下两个原因：")]),e._v(" "),a("ul",[a("li",[e._v("Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负 载。")]),e._v(" "),a("li",[e._v("先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。")])]),e._v(" "),a("h3",{attrs:{id:"aof触发持久化流程-文件同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof触发持久化流程-文件同步"}},[e._v("#")]),e._v(" AOF触发持久化流程-文件同步")]),e._v(" "),a("p",[e._v("Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[e._v("可配置值")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("说明")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("always")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("everysec")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync同步文件操作由专门线程每秒调用一次")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("no")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒")])])])]),e._v(" "),a("p",[e._v("系统调用write和fsync的区别：")]),e._v(" "),a("ul",[a("li",[e._v("write操作会触发"),a("strong",[e._v("延迟写（delayed write）机制")]),e._v(" 。Linux在内核提供页缓冲区用来提高硬盘IO性能。"),a("strong",[e._v("write操作在写入系统缓冲区后直接返回，同步硬盘操作依赖于系统调度机制")]),e._v("，例如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。")]),e._v(" "),a("li",[e._v("fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，"),a("strong",[e._v("fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。")])])]),e._v(" "),a("p",[e._v("各种配置值的优缺点：")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[e._v("可配置值")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("作用")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("always")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("strong",[e._v("配置为always时，每次写入都要同步AOF文件")]),e._v("，在一般的SATA硬盘 上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰， "),a("strong",[e._v("不建议配置")]),e._v("。")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("everysec")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("strong",[e._v("配置为everysec，是建议的同步策略")]),e._v("，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[e._v("no")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。")])])])]),e._v(" "),a("h3",{attrs:{id:"aof触发持久化流程-文件重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof触发持久化流程-文件重写"}},[e._v("#")]),e._v(" AOF触发持久化流程-文件重写")]),e._v(" "),a("p",[e._v("随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。"),a("strong",[e._v("AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。")])]),e._v(" "),a("p",[e._v("重写后的AOF文件将会变小，原因如下：")]),e._v(" "),a("ul",[a("li",[e._v("进程内已经超时的数据不再写入文件。")]),e._v(" "),a("li",[a("strong",[e._v("旧的AOF文件含有无效命令")]),e._v("，如"),a("code",[e._v("del key1")]),e._v("、"),a("code",[e._v("hdel key2")]),e._v("、"),a("code",[e._v("srem keys")]),e._v("、"),a("code",[e._v("set a111")]),e._v("、"),a("code",[e._v("set a222")]),e._v("等。"),a("strong",[e._v("重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。")])]),e._v(" "),a("li",[a("strong",[e._v("多条写命令可以合并为一个")]),e._v("，如："),a("code",[e._v("lpush list a")]),e._v("、"),a("code",[e._v("lpush list b")]),e._v("、"),a("code",[e._v("lpush list c")]),e._v("可以转化为："),a("code",[e._v("lpush list a b c")]),e._v("。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。")])]),e._v(" "),a("p",[e._v("AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。")]),e._v(" "),a("p",[a("strong",[e._v("AOF重写过程可以分为手动触发和自动触发")]),e._v("：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("手动触发：直接调用"),a("code",[e._v("bgrewriteaof")]),e._v("命令。")])]),e._v(" "),a("li",[a("p",[e._v("自动触发：根据"),a("code",[e._v("auto-aof-rewrite-min-size")]),e._v("和"),a("code",[e._v("auto-aof-rewrite-percentage")]),e._v("参数确定自动触发时机。"),a("code",[e._v("auto-aof-rewrite-min-size")]),e._v("表示运行AOF重写时文件最小体积，默认为64MB。"),a("code",[e._v("auto-aof-rewrite-percentage")]),e._v("代表当前AOF文件空间 （"),a("code",[e._v("aof_current_size")]),e._v("）和上一次重写后AOF文件空间（"),a("code",[e._v("aof_base_size")]),e._v("）的比值。")]),e._v(" "),a("p",[e._v("自动触发AOF重写时机满足以下条件：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("aof_current_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("auto-aof-rewrite-minsize "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v("（aof_current_size-aof_base_size）/aof_base_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">=")]),e._v("auto-aof-rewritepercentage\n")])])]),a("p",[e._v("其中"),a("code",[e._v("aof_current_size")]),e._v("和"),a("code",[e._v("aof_base_size")]),e._v("可以在info Persistence统计信息中查看。")])])]),e._v(" "),a("h3",{attrs:{id:"aof触发持久化流程-重启加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof触发持久化流程-重启加载"}},[e._v("#")]),e._v(" AOF触发持久化流程-重启加载")]),e._v(" "),a("p",[e._v("AOF和RDB文件都可以用于服务器重启时的数据恢复。")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("AOF持久化开启且存在AOF文件时，优先加载AOF文件。")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("* DB loaded from append only file: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("5.841")]),e._v(" seconds\n")])])])]),e._v(" "),a("li",[a("p",[e._v("AOF关闭或者AOF文件不存在时，加载RDB文件。")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("* DB loaded from disk: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("5.586")]),e._v(" seconds\n")])])])]),e._v(" "),a("li",[a("p",[e._v("加载AOF/RDB文件成功后，Redis启动成功。")])]),e._v(" "),a("li",[a("p",[e._v("AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。")]),e._v(" "),a("p",[e._v("加载损坏的AOF文件时会拒绝启动，并打印如下日志：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bad file format reading the append only file: make a backup of your AOF file,")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("then")]),e._v(" use ./redis-check-aof "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--fix")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("filename"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])]),a("p",[e._v("对于错误格式的AOF文件，先进行备份，然后采用"),a("code",[e._v("redis-check-aof --fix")]),e._v("命令进行修复，修复后使用"),a("code",[e._v("diff-u")]),e._v("对比数据的差异，找出丢失的数据，有些可以人工修改补全。")]),e._v(" "),a("p",[e._v("AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部文件命令写入不全。Redis为我们提供了"),a("code",[e._v("aof-load-truncated")]),e._v("配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印如下警告日志：")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# !!! Warning: short read while loading the AOF file !!!")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# !!! Truncating the AOF at offset 397856725 !!!")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# AOF loaded anyway because aof-load-truncated is enabled")]),e._v("\n")])])])])]),e._v(" "),a("h2",{attrs:{id:"本章内容总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本章内容总结"}},[e._v("#")]),e._v(" 本章内容总结")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Redis提供了两种持久化方式：RDB和AOF。")])]),e._v(" "),a("li",[a("p",[e._v("RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，无法做到实时持久化，一般用于数据冷备和复制传输。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("save")]),e._v("命令会阻塞主线程不建议使用，"),a("code",[e._v("bgsave")]),e._v("命令通过fork操作创建子进程生成RDB避免阻塞。")])]),e._v(" "),a("li",[a("p",[e._v("AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。")])]),e._v(" "),a("li",[a("p",[e._v("AOF重写可以通过"),a("code",[e._v("auto-aof-rewrite-min-size")]),e._v("和"),a("code",[e._v("auto-aof-rewrite-percentage")]),e._v("参数控制自动触发，也可以使用"),a("code",[e._v("bgrewriteaof")]),e._v("命令手动触发。子进程执行期间使用copy-on-write机制与父进程共享内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。")])]),e._v(" "),a("li",[a("p",[e._v("持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。")])]),e._v(" "),a("li",[a("p",[e._v("单机下部署多个实例时，为了防止出现多个子进程执行重写操作，建议做隔离控制，避免CPU和IO资源竞争。")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);