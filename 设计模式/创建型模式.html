<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>创建型模式 | Knowledge</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/mr-mugglefavicon.ico">
    <meta name="description" content="talk is cheap show me the code">
    <link rel="preload" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css" as="style"><link rel="preload" href="/mr-muggle/assets/js/app.03b0f33a.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/2.c49e4524.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/73.11b998f6.js" as="script"><link rel="prefetch" href="/mr-muggle/assets/js/10.b769111d.js"><link rel="prefetch" href="/mr-muggle/assets/js/11.3b528e8b.js"><link rel="prefetch" href="/mr-muggle/assets/js/12.262bc424.js"><link rel="prefetch" href="/mr-muggle/assets/js/13.701f9444.js"><link rel="prefetch" href="/mr-muggle/assets/js/14.f5836d8f.js"><link rel="prefetch" href="/mr-muggle/assets/js/15.f6ae0270.js"><link rel="prefetch" href="/mr-muggle/assets/js/16.88f016bf.js"><link rel="prefetch" href="/mr-muggle/assets/js/17.2cb6dc15.js"><link rel="prefetch" href="/mr-muggle/assets/js/18.190ccd99.js"><link rel="prefetch" href="/mr-muggle/assets/js/19.5b842041.js"><link rel="prefetch" href="/mr-muggle/assets/js/20.23e5f14f.js"><link rel="prefetch" href="/mr-muggle/assets/js/21.76eb19cf.js"><link rel="prefetch" href="/mr-muggle/assets/js/22.9a998e87.js"><link rel="prefetch" href="/mr-muggle/assets/js/23.d79bc80a.js"><link rel="prefetch" href="/mr-muggle/assets/js/24.68b1ece9.js"><link rel="prefetch" href="/mr-muggle/assets/js/25.0536eb3c.js"><link rel="prefetch" href="/mr-muggle/assets/js/26.e1e22d1b.js"><link rel="prefetch" href="/mr-muggle/assets/js/27.10fbd948.js"><link rel="prefetch" href="/mr-muggle/assets/js/28.9d8bf67a.js"><link rel="prefetch" href="/mr-muggle/assets/js/29.959e32d1.js"><link rel="prefetch" href="/mr-muggle/assets/js/3.4c2c33d8.js"><link rel="prefetch" href="/mr-muggle/assets/js/30.98fcced0.js"><link rel="prefetch" href="/mr-muggle/assets/js/31.c3717be1.js"><link rel="prefetch" href="/mr-muggle/assets/js/32.04594faa.js"><link rel="prefetch" href="/mr-muggle/assets/js/33.cbdbae4d.js"><link rel="prefetch" href="/mr-muggle/assets/js/34.112b9f11.js"><link rel="prefetch" href="/mr-muggle/assets/js/35.b52ec603.js"><link rel="prefetch" href="/mr-muggle/assets/js/36.6a59af48.js"><link rel="prefetch" href="/mr-muggle/assets/js/37.7974b0c2.js"><link rel="prefetch" href="/mr-muggle/assets/js/38.f998387a.js"><link rel="prefetch" href="/mr-muggle/assets/js/39.89abf77c.js"><link rel="prefetch" href="/mr-muggle/assets/js/4.8c3e511b.js"><link rel="prefetch" href="/mr-muggle/assets/js/40.ec4c57c4.js"><link rel="prefetch" href="/mr-muggle/assets/js/41.ef41848b.js"><link rel="prefetch" href="/mr-muggle/assets/js/42.8538a508.js"><link rel="prefetch" href="/mr-muggle/assets/js/43.c712f5fa.js"><link rel="prefetch" href="/mr-muggle/assets/js/44.7e2435a1.js"><link rel="prefetch" href="/mr-muggle/assets/js/45.633f2d43.js"><link rel="prefetch" href="/mr-muggle/assets/js/46.1bd7c05d.js"><link rel="prefetch" href="/mr-muggle/assets/js/47.e5df90ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/48.cd6c7156.js"><link rel="prefetch" href="/mr-muggle/assets/js/49.90631ebb.js"><link rel="prefetch" href="/mr-muggle/assets/js/5.6834c560.js"><link rel="prefetch" href="/mr-muggle/assets/js/50.9f214f89.js"><link rel="prefetch" href="/mr-muggle/assets/js/51.99a8dd78.js"><link rel="prefetch" href="/mr-muggle/assets/js/52.aec5051a.js"><link rel="prefetch" href="/mr-muggle/assets/js/53.7b621de8.js"><link rel="prefetch" href="/mr-muggle/assets/js/54.aa323f86.js"><link rel="prefetch" href="/mr-muggle/assets/js/55.63b233d9.js"><link rel="prefetch" href="/mr-muggle/assets/js/56.2cc8fe7b.js"><link rel="prefetch" href="/mr-muggle/assets/js/57.2a7a35c6.js"><link rel="prefetch" href="/mr-muggle/assets/js/58.3ef9ff2d.js"><link rel="prefetch" href="/mr-muggle/assets/js/59.4194402f.js"><link rel="prefetch" href="/mr-muggle/assets/js/6.ad05d8e5.js"><link rel="prefetch" href="/mr-muggle/assets/js/60.01275a59.js"><link rel="prefetch" href="/mr-muggle/assets/js/61.d314066d.js"><link rel="prefetch" href="/mr-muggle/assets/js/62.68ce6bc5.js"><link rel="prefetch" href="/mr-muggle/assets/js/63.34dea9e0.js"><link rel="prefetch" href="/mr-muggle/assets/js/64.9aaf5e00.js"><link rel="prefetch" href="/mr-muggle/assets/js/65.e4ce25ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/66.5d9f1db5.js"><link rel="prefetch" href="/mr-muggle/assets/js/67.c914fc65.js"><link rel="prefetch" href="/mr-muggle/assets/js/68.5ee52c48.js"><link rel="prefetch" href="/mr-muggle/assets/js/69.680accb1.js"><link rel="prefetch" href="/mr-muggle/assets/js/7.0c092304.js"><link rel="prefetch" href="/mr-muggle/assets/js/70.cf4408b5.js"><link rel="prefetch" href="/mr-muggle/assets/js/71.33ad3ca9.js"><link rel="prefetch" href="/mr-muggle/assets/js/72.87880929.js"><link rel="prefetch" href="/mr-muggle/assets/js/74.5a75b187.js"><link rel="prefetch" href="/mr-muggle/assets/js/75.5301781a.js"><link rel="prefetch" href="/mr-muggle/assets/js/76.c446bc20.js"><link rel="prefetch" href="/mr-muggle/assets/js/77.4eaa9052.js"><link rel="prefetch" href="/mr-muggle/assets/js/78.3b98b54f.js"><link rel="prefetch" href="/mr-muggle/assets/js/79.60b9a9ba.js"><link rel="prefetch" href="/mr-muggle/assets/js/8.471386f2.js"><link rel="prefetch" href="/mr-muggle/assets/js/80.7b067e03.js"><link rel="prefetch" href="/mr-muggle/assets/js/81.8274f49e.js"><link rel="prefetch" href="/mr-muggle/assets/js/82.b72070ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/83.4651609d.js"><link rel="prefetch" href="/mr-muggle/assets/js/84.fffdd780.js"><link rel="prefetch" href="/mr-muggle/assets/js/85.10865df0.js"><link rel="prefetch" href="/mr-muggle/assets/js/86.5b4b0452.js"><link rel="prefetch" href="/mr-muggle/assets/js/87.a270ec2b.js"><link rel="prefetch" href="/mr-muggle/assets/js/88.8bb08b0f.js"><link rel="prefetch" href="/mr-muggle/assets/js/89.3826a944.js"><link rel="prefetch" href="/mr-muggle/assets/js/9.d8124a2e.js"><link rel="prefetch" href="/mr-muggle/assets/js/90.dbf7dede.js"><link rel="prefetch" href="/mr-muggle/assets/js/91.0823b62f.js"><link rel="prefetch" href="/mr-muggle/assets/js/92.8ec406ed.js">
    <link rel="stylesheet" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-6 ant-col-xl-5 ant-col-xxl-4"><a href="/mr-muggle/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Knowledge</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="nav-space-between ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-18 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mr-muggle/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          后端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          前端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          数据库
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          消息队列
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          搜索引擎
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          项目部署与运维
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          办公软件
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <ul class="extra-group"><!----> <!----></ul></nav></div></div> <!----></header> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/mr-muggle/设计模式/Java设计模式概述.html" title="Java设计模式概述" class="sidebar-link">Java设计模式概述</a></li><li><a href="/mr-muggle/设计模式/创建型模式.html" title="创建型模式" class="active sidebar-link">创建型模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#创建型模式概述" title="创建型模式概述" class="sidebar-link">创建型模式概述</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#创建型模式的分类" title="创建型模式的分类" class="sidebar-link">创建型模式的分类</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#单例模式" title="单例模式" class="sidebar-link">单例模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#单例模式的定义" title="单例模式的定义" class="sidebar-link">单例模式的定义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#单例模式的优缺点" title="单例模式的优缺点" class="sidebar-link">单例模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#单例模式的结构和实现" title="单例模式的结构和实现" class="sidebar-link">单例模式的结构和实现</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#单例模式的使用场景" title="单例模式的使用场景" class="sidebar-link">单例模式的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#原型模式" title="原型模式" class="sidebar-link">原型模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#原型模式的定义" title="原型模式的定义" class="sidebar-link">原型模式的定义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#原型模式的优缺点" title="原型模式的优缺点" class="sidebar-link">原型模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#原型模式的结构和实现" title="原型模式的结构和实现" class="sidebar-link">原型模式的结构和实现</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#原型模式的使用场景" title="原型模式的使用场景" class="sidebar-link">原型模式的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂模式" title="工厂模式" class="sidebar-link">工厂模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂模式的定义" title="工厂模式的定义" class="sidebar-link">工厂模式的定义</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#简单工厂模式" title="简单工厂模式" class="sidebar-link">简单工厂模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#简单工厂模式的定义" title="简单工厂模式的定义" class="sidebar-link">简单工厂模式的定义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#简单工厂模式的结构和实现" title="简单工厂模式的结构和实现" class="sidebar-link">简单工厂模式的结构和实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂方法模式" title="工厂方法模式" class="sidebar-link">工厂方法模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂方法模式的优缺点" title="工厂方法模式的优缺点" class="sidebar-link">工厂方法模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂方法模式的结构和实现" title="工厂方法模式的结构和实现" class="sidebar-link">工厂方法模式的结构和实现</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#工厂方法模式的使用场景" title="工厂方法模式的使用场景" class="sidebar-link">工厂方法模式的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#抽象工厂模式" title="抽象工厂模式" class="sidebar-link">抽象工厂模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#抽象工厂模式的定义" title="抽象工厂模式的定义" class="sidebar-link">抽象工厂模式的定义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#抽象工厂模式的优缺点" title="抽象工厂模式的优缺点" class="sidebar-link">抽象工厂模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#抽象工厂模式的结构和实现" title="抽象工厂模式的结构和实现" class="sidebar-link">抽象工厂模式的结构和实现</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#抽象工厂模式的使用场景" title="抽象工厂模式的使用场景" class="sidebar-link">抽象工厂模式的使用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式" title="建造者模式" class="sidebar-link">建造者模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式的定义" title="建造者模式的定义" class="sidebar-link">建造者模式的定义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式的优缺点" title="建造者模式的优缺点" class="sidebar-link">建造者模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式的结构和实现" title="建造者模式的结构和实现" class="sidebar-link">建造者模式的结构和实现</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式的使用场景" title="建造者模式的使用场景" class="sidebar-link">建造者模式的使用场景</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/设计模式/创建型模式.html#建造者模式和工厂模式的区别" title="建造者模式和工厂模式的区别" class="sidebar-link">建造者模式和工厂模式的区别</a></li></ul></li></ul></li><li><a href="/mr-muggle/设计模式/结构型模式.html" title="结构型模式" class="sidebar-link">结构型模式</a></li><li><a href="/mr-muggle/设计模式/行为型模式.html" title="行为型模式" class="sidebar-link">行为型模式</a></li></ul> </aside> <main class="page has-page-anchor"> <div class="theme-antdocs-content content__default"><h2 id="创建型模式概述"><a href="#创建型模式概述" class="header-anchor">#</a> 创建型模式概述</h2> <p>创建型模式的主要关注点是“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p> <h2 id="创建型模式的分类"><a href="#创建型模式的分类" class="header-anchor">#</a> 创建型模式的分类</h2> <p>创建型模式分为以下几种。</p> <ul><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li> <li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li> <li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li> <li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li> <li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul> <p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p> <h2 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> 单例模式</h2> <h3 id="单例模式的定义"><a href="#单例模式的定义" class="header-anchor">#</a> 单例模式的定义</h3> <p>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p> <h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="header-anchor">#</a> 单例模式的优缺点</h3> <p>单例模式的优点：</p> <ul><li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li> <li>可以避免对资源的多重占用。</li> <li>单例模式设置全局访问点，可以优化和共享资源的访问。</li></ul> <p>单例模式的缺点：</p> <ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li> <li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li> <li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ul> <h3 id="单例模式的结构和实现"><a href="#单例模式的结构和实现" class="header-anchor">#</a> 单例模式的结构和实现</h3> <p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p> <p>单例模式的主要角色如下。</p> <ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li> <li>访问类：使用单例的类。</li></ul> <p>单例模式的主要角色如下。</p> <ul><li><p>单例类：包含一个实例且能自行创建这个实例的类。</p></li> <li><p>访问类：使用单例的类。</p></li></ul> <p>单例模式通常有三种实现形式：懒汉式、饿汉式、双重校验锁式</p> <p>懒汉式的特点是类加载时没有生成单例，只有当第一次调用 <code>getlnstance</code> 方法时才去创建这个单例。</p> <ul><li><p>线程不安全的懒汉式</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>  
  <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
 <span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁<code>synchronized</code>,所以严格意义上它并不算单例模式。</p> <ul><li><p>线程安全的懒汉式</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> 
	  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
      
      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      
      <span class="token punctuation">}</span>
      
      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span>  
      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  
      <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>这种方式能够在多线程中很好的工作，但是，效率很低。</p> <ul><li><p>饿汉式</p> <p>该模式的特点是类一旦加载就创建一个单例，保证在调用 <code>getInstance</code>方法之前单例已经存在了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre></div><p>这种方式比较常用，但容易产生垃圾对象。类加载时就初始化，浪费内存。</p></li> <li><p>双检锁/双重校验锁</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>  
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre></div><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p></li></ul> <h3 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="header-anchor">#</a> 单例模式的使用场景</h3> <p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p> <ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li> <li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li> <li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul> <h2 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h2> <p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。</p> <h3 id="原型模式的定义"><a href="#原型模式的定义" class="header-anchor">#</a> 原型模式的定义</h3> <p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p> <h3 id="原型模式的优缺点"><a href="#原型模式的优缺点" class="header-anchor">#</a> 原型模式的优缺点</h3> <h3 id="原型模式的结构和实现"><a href="#原型模式的结构和实现" class="header-anchor">#</a> 原型模式的结构和实现</h3> <p>由于 java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p> <p>原型模式通常包含以下主要角色。</p> <ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li> <li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li> <li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol> <p>原型模式的克隆分为浅克隆和深克隆。</p> <ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li> <li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul> <p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//具体原型类</span>
<span class="token keyword">class</span> <span class="token class-name">Realizetype</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token class-name">Realizetype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;具体原型创建成功！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;具体原型复制成功！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Realizetype</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用原型类方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Realizetype</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Realizetype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Realizetype</span> obj2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Realizetype</span><span class="token punctuation">)</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;obj1==obj2?&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="原型模式的使用场景"><a href="#原型模式的使用场景" class="header-anchor">#</a> 原型模式的使用场景</h3> <p>原型模式通常适用于以下场景。</p> <ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li> <li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li> <li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li> <li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li></ul> <p>在Spring中，原型模式应用的非常广泛，例如 <code>scope='prototype</code>、<code>JSON.parseObject()</code> 等都是原型模式的具体应用。</p> <h2 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h2> <h3 id="工厂模式的定义"><a href="#工厂模式的定义" class="header-anchor">#</a> 工厂模式的定义</h3> <p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。</p> <p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p> <p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。</p> <h2 id="简单工厂模式"><a href="#简单工厂模式" class="header-anchor">#</a> 简单工厂模式</h2> <h3 id="简单工厂模式的定义"><a href="#简单工厂模式的定义" class="header-anchor">#</a> 简单工厂模式的定义</h3> <p>如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p> <p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p> <p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p> <h3 id="简单工厂模式的结构和实现"><a href="#简单工厂模式的结构和实现" class="header-anchor">#</a> 简单工厂模式的结构和实现</h3> <p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p> <p>简单工厂模式的主要角色如下：</p> <ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li> <li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li> <li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul> <p>根据上面的角色划分，我们可以定义抽象产品、具体产品、以及简单工厂。</p> <ul><li>抽象产品</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//抽象产品</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
   <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>具体产品</p> <p><code>ProductA</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;具体产品1显示...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ProductB</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//具体产品：ProductB</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;具体产品2显示...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>产品类型常量定义</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Const</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PRODUCT_A</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PRODUCT_B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PRODUCT_C</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>简单工厂</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Product</span> <span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">case</span> <span class="token class-name">Const</span><span class="token punctuation">.</span><span class="token constant">PRODUCT_A</span><span class="token operator">:</span>
                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token class-name">Const</span><span class="token punctuation">.</span><span class="token constant">PRODUCT_B</span><span class="token operator">:</span>
                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="工厂方法模式"><a href="#工厂方法模式" class="header-anchor">#</a> 工厂方法模式</h2> <h3 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="header-anchor">#</a> 工厂方法模式的优缺点</h3> <p>工厂方法模式的优点：</p> <ul><li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</p></li> <li><p>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</p></li> <li><p>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</p></li></ul> <p>工厂方法模式的缺点：</p> <ul><li><p>类的个数容易过多，增加复杂度</p></li> <li><p>增加了系统的抽象性和理解难度</p></li> <li><p>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</p></li></ul> <h3 id="工厂方法模式的结构和实现"><a href="#工厂方法模式的结构和实现" class="header-anchor">#</a> 工厂方法模式的结构和实现</h3> <p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p> <p>工厂方法模式的主要角色如下。</p> <ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li> <li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li> <li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li> <li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol> <h3 id="工厂方法模式的使用场景"><a href="#工厂方法模式的使用场景" class="header-anchor">#</a> 工厂方法模式的使用场景</h3> <ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li> <li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li> <li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul> <h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="header-anchor">#</a> 抽象工厂模式</h2> <p>工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p> <p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。</p> <h3 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="header-anchor">#</a> 抽象工厂模式的定义</h3> <p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式。</p> <h3 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="header-anchor">#</a> 抽象工厂模式的优缺点</h3> <ul><li><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p> <ul><li><p>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</p></li> <li><p>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</p></li></ul></li> <li><p>缺点：</p> <ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li></ul></li></ul> <h3 id="抽象工厂模式的结构和实现"><a href="#抽象工厂模式的结构和实现" class="header-anchor">#</a> 抽象工厂模式的结构和实现</h3> <p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p> <p>抽象工厂模式的主要角色如下。</p> <ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li> <li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li> <li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li> <li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ol> <h3 id="抽象工厂模式的使用场景"><a href="#抽象工厂模式的使用场景" class="header-anchor">#</a> 抽象工厂模式的使用场景</h3> <p>抽象工厂模式通常适用于以下场景：</p> <ol><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li> <li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li> <li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ol> <h2 id="建造者模式"><a href="#建造者模式" class="header-anchor">#</a> 建造者模式</h2> <p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p> <h3 id="建造者模式的定义"><a href="#建造者模式的定义" class="header-anchor">#</a> 建造者模式的定义</h3> <p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p> <h3 id="建造者模式的优缺点"><a href="#建造者模式的优缺点" class="header-anchor">#</a> 建造者模式的优缺点</h3> <ul><li>优点：
<ul><li>各个具体的建造者相互独立，有利于系统的扩展。</li> <li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ul></li> <li>缺点：
<ul><li>产品的组成部分必须相同，这限制了其使用范围。</li> <li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li></ul></li></ul> <h3 id="建造者模式的结构和实现"><a href="#建造者模式的结构和实现" class="header-anchor">#</a> 建造者模式的结构和实现</h3> <p>建造者（Builder）模式的主要角色如下。</p> <ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</li> <li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li> <li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li> <li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol> <p>建造者模式的代码实现</p> <ul><li><p>产品角色</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Product</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> partA<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> partB<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> partC<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token class-name">String</span> partA<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>partA<span class="token operator">=</span>partA<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartB</span><span class="token punctuation">(</span><span class="token class-name">String</span> partB<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>partB<span class="token operator">=</span>partB<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartC</span><span class="token punctuation">(</span><span class="token class-name">String</span> partC<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>partC<span class="token operator">=</span>partC<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//显示产品的特性</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>抽象建造者
包含创建产品各个子部件的抽象方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建产品对象</span>
    <span class="token keyword">protected</span> <span class="token class-name">Product</span> product<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回产品对象</span>
    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> product<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>具体建造者
实现了抽象建造者接口.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">&quot;建造 PartA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">&quot;建造 PartB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">&quot;建造 PartC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>指挥者
调用建造者中的方法完成复杂对象的创建。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Director</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Builder</span> builder<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token operator">=</span>builder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//产品构建与组装方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        builder<span class="token punctuation">.</span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        builder<span class="token punctuation">.</span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        builder<span class="token punctuation">.</span><span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>客户类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Builder</span> builder<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Director</span> director<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Product</span> product<span class="token operator">=</span>director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="header-anchor">#</a> 建造者模式的使用场景</h3> <p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p> <p>建造者模式主要适用于以下应用场景：</p> <ul><li>相同的方法，不同的执行顺序，产生不同的结果。</li> <li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li> <li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li> <li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</li></ul> <h3 id="建造者模式和工厂模式的区别"><a href="#建造者模式和工厂模式的区别" class="header-anchor">#</a> 建造者模式和工厂模式的区别</h3> <p>通过前面的学习，我们已经了解了建造者模式，那么它和工厂模式有什么区别呢？</p> <ul><li>建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。</li> <li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样</li> <li>关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。</li> <li>建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">LastUpdated:</span> <span class="time">3/11/2021, 7:31:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mr-muggle/设计模式/Java设计模式概述.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        Java设计模式概述
      </a></span> <span class="next"><a href="/mr-muggle/设计模式/结构型模式.html">
        结构型模式
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> <div class="page-anchor"><div class="ant-space ant-space-vertical" style="width:100%;"><div class="ant-space-item"><div class="page-anchor-offset"><div><div class="ant-anchor-wrapper" style="max-height:100vh;"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a href="#创建型模式概述" title="创建型模式概述" class="ant-anchor-link-title">创建型模式概述</a></div><div class="ant-anchor-link"><a href="#创建型模式的分类" title="创建型模式的分类" class="ant-anchor-link-title">创建型模式的分类</a></div><div class="ant-anchor-link"><a href="#单例模式" title="单例模式" class="ant-anchor-link-title">单例模式</a><div class="ant-anchor-link"><a href="#单例模式的定义" title="单例模式的定义" class="ant-anchor-link-title">单例模式的定义</a></div><div class="ant-anchor-link"><a href="#单例模式的优缺点" title="单例模式的优缺点" class="ant-anchor-link-title">单例模式的优缺点</a></div><div class="ant-anchor-link"><a href="#单例模式的结构和实现" title="单例模式的结构和实现" class="ant-anchor-link-title">单例模式的结构和实现</a></div><div class="ant-anchor-link"><a href="#单例模式的使用场景" title="单例模式的使用场景" class="ant-anchor-link-title">单例模式的使用场景</a></div></div><div class="ant-anchor-link"><a href="#原型模式" title="原型模式" class="ant-anchor-link-title">原型模式</a><div class="ant-anchor-link"><a href="#原型模式的定义" title="原型模式的定义" class="ant-anchor-link-title">原型模式的定义</a></div><div class="ant-anchor-link"><a href="#原型模式的优缺点" title="原型模式的优缺点" class="ant-anchor-link-title">原型模式的优缺点</a></div><div class="ant-anchor-link"><a href="#原型模式的结构和实现" title="原型模式的结构和实现" class="ant-anchor-link-title">原型模式的结构和实现</a></div><div class="ant-anchor-link"><a href="#原型模式的使用场景" title="原型模式的使用场景" class="ant-anchor-link-title">原型模式的使用场景</a></div></div><div class="ant-anchor-link"><a href="#工厂模式" title="工厂模式" class="ant-anchor-link-title">工厂模式</a><div class="ant-anchor-link"><a href="#工厂模式的定义" title="工厂模式的定义" class="ant-anchor-link-title">工厂模式的定义</a></div></div><div class="ant-anchor-link"><a href="#简单工厂模式" title="简单工厂模式" class="ant-anchor-link-title">简单工厂模式</a><div class="ant-anchor-link"><a href="#简单工厂模式的定义" title="简单工厂模式的定义" class="ant-anchor-link-title">简单工厂模式的定义</a></div><div class="ant-anchor-link"><a href="#简单工厂模式的结构和实现" title="简单工厂模式的结构和实现" class="ant-anchor-link-title">简单工厂模式的结构和实现</a></div></div><div class="ant-anchor-link"><a href="#工厂方法模式" title="工厂方法模式" class="ant-anchor-link-title">工厂方法模式</a><div class="ant-anchor-link"><a href="#工厂方法模式的优缺点" title="工厂方法模式的优缺点" class="ant-anchor-link-title">工厂方法模式的优缺点</a></div><div class="ant-anchor-link"><a href="#工厂方法模式的结构和实现" title="工厂方法模式的结构和实现" class="ant-anchor-link-title">工厂方法模式的结构和实现</a></div><div class="ant-anchor-link"><a href="#工厂方法模式的使用场景" title="工厂方法模式的使用场景" class="ant-anchor-link-title">工厂方法模式的使用场景</a></div></div><div class="ant-anchor-link"><a href="#抽象工厂模式" title="抽象工厂模式" class="ant-anchor-link-title">抽象工厂模式</a><div class="ant-anchor-link"><a href="#抽象工厂模式的定义" title="抽象工厂模式的定义" class="ant-anchor-link-title">抽象工厂模式的定义</a></div><div class="ant-anchor-link"><a href="#抽象工厂模式的优缺点" title="抽象工厂模式的优缺点" class="ant-anchor-link-title">抽象工厂模式的优缺点</a></div><div class="ant-anchor-link"><a href="#抽象工厂模式的结构和实现" title="抽象工厂模式的结构和实现" class="ant-anchor-link-title">抽象工厂模式的结构和实现</a></div><div class="ant-anchor-link"><a href="#抽象工厂模式的使用场景" title="抽象工厂模式的使用场景" class="ant-anchor-link-title">抽象工厂模式的使用场景</a></div></div><div class="ant-anchor-link"><a href="#建造者模式" title="建造者模式" class="ant-anchor-link-title">建造者模式</a><div class="ant-anchor-link"><a href="#建造者模式的定义" title="建造者模式的定义" class="ant-anchor-link-title">建造者模式的定义</a></div><div class="ant-anchor-link"><a href="#建造者模式的优缺点" title="建造者模式的优缺点" class="ant-anchor-link-title">建造者模式的优缺点</a></div><div class="ant-anchor-link"><a href="#建造者模式的结构和实现" title="建造者模式的结构和实现" class="ant-anchor-link-title">建造者模式的结构和实现</a></div><div class="ant-anchor-link"><a href="#建造者模式的使用场景" title="建造者模式的使用场景" class="ant-anchor-link-title">建造者模式的使用场景</a></div><div class="ant-anchor-link"><a href="#建造者模式和工厂模式的区别" title="建造者模式和工厂模式的区别" class="ant-anchor-link-title">建造者模式和工厂模式的区别</a></div></div></div></div></div></div></div></div></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/mr-muggle/assets/js/app.03b0f33a.js" defer></script><script src="/mr-muggle/assets/js/2.c49e4524.js" defer></script><script src="/mr-muggle/assets/js/73.11b998f6.js" defer></script>
  </body>
</html>