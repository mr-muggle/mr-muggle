<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Linux入门-基础 | Knowledge</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/mr-mugglefavicon.ico">
    <meta name="description" content="talk is cheap show me the code">
    <link rel="preload" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css" as="style"><link rel="preload" href="/mr-muggle/assets/js/app.03b0f33a.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/2.c49e4524.js" as="script"><link rel="preload" href="/mr-muggle/assets/js/16.88f016bf.js" as="script"><link rel="prefetch" href="/mr-muggle/assets/js/10.b769111d.js"><link rel="prefetch" href="/mr-muggle/assets/js/11.3b528e8b.js"><link rel="prefetch" href="/mr-muggle/assets/js/12.262bc424.js"><link rel="prefetch" href="/mr-muggle/assets/js/13.701f9444.js"><link rel="prefetch" href="/mr-muggle/assets/js/14.f5836d8f.js"><link rel="prefetch" href="/mr-muggle/assets/js/15.f6ae0270.js"><link rel="prefetch" href="/mr-muggle/assets/js/17.2cb6dc15.js"><link rel="prefetch" href="/mr-muggle/assets/js/18.190ccd99.js"><link rel="prefetch" href="/mr-muggle/assets/js/19.5b842041.js"><link rel="prefetch" href="/mr-muggle/assets/js/20.23e5f14f.js"><link rel="prefetch" href="/mr-muggle/assets/js/21.76eb19cf.js"><link rel="prefetch" href="/mr-muggle/assets/js/22.9a998e87.js"><link rel="prefetch" href="/mr-muggle/assets/js/23.d79bc80a.js"><link rel="prefetch" href="/mr-muggle/assets/js/24.68b1ece9.js"><link rel="prefetch" href="/mr-muggle/assets/js/25.0536eb3c.js"><link rel="prefetch" href="/mr-muggle/assets/js/26.e1e22d1b.js"><link rel="prefetch" href="/mr-muggle/assets/js/27.10fbd948.js"><link rel="prefetch" href="/mr-muggle/assets/js/28.9d8bf67a.js"><link rel="prefetch" href="/mr-muggle/assets/js/29.959e32d1.js"><link rel="prefetch" href="/mr-muggle/assets/js/3.4c2c33d8.js"><link rel="prefetch" href="/mr-muggle/assets/js/30.98fcced0.js"><link rel="prefetch" href="/mr-muggle/assets/js/31.c3717be1.js"><link rel="prefetch" href="/mr-muggle/assets/js/32.04594faa.js"><link rel="prefetch" href="/mr-muggle/assets/js/33.cbdbae4d.js"><link rel="prefetch" href="/mr-muggle/assets/js/34.112b9f11.js"><link rel="prefetch" href="/mr-muggle/assets/js/35.b52ec603.js"><link rel="prefetch" href="/mr-muggle/assets/js/36.6a59af48.js"><link rel="prefetch" href="/mr-muggle/assets/js/37.7974b0c2.js"><link rel="prefetch" href="/mr-muggle/assets/js/38.f998387a.js"><link rel="prefetch" href="/mr-muggle/assets/js/39.89abf77c.js"><link rel="prefetch" href="/mr-muggle/assets/js/4.8c3e511b.js"><link rel="prefetch" href="/mr-muggle/assets/js/40.ec4c57c4.js"><link rel="prefetch" href="/mr-muggle/assets/js/41.ef41848b.js"><link rel="prefetch" href="/mr-muggle/assets/js/42.8538a508.js"><link rel="prefetch" href="/mr-muggle/assets/js/43.c712f5fa.js"><link rel="prefetch" href="/mr-muggle/assets/js/44.7e2435a1.js"><link rel="prefetch" href="/mr-muggle/assets/js/45.633f2d43.js"><link rel="prefetch" href="/mr-muggle/assets/js/46.1bd7c05d.js"><link rel="prefetch" href="/mr-muggle/assets/js/47.e5df90ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/48.cd6c7156.js"><link rel="prefetch" href="/mr-muggle/assets/js/49.90631ebb.js"><link rel="prefetch" href="/mr-muggle/assets/js/5.6834c560.js"><link rel="prefetch" href="/mr-muggle/assets/js/50.9f214f89.js"><link rel="prefetch" href="/mr-muggle/assets/js/51.99a8dd78.js"><link rel="prefetch" href="/mr-muggle/assets/js/52.aec5051a.js"><link rel="prefetch" href="/mr-muggle/assets/js/53.7b621de8.js"><link rel="prefetch" href="/mr-muggle/assets/js/54.aa323f86.js"><link rel="prefetch" href="/mr-muggle/assets/js/55.63b233d9.js"><link rel="prefetch" href="/mr-muggle/assets/js/56.2cc8fe7b.js"><link rel="prefetch" href="/mr-muggle/assets/js/57.2a7a35c6.js"><link rel="prefetch" href="/mr-muggle/assets/js/58.3ef9ff2d.js"><link rel="prefetch" href="/mr-muggle/assets/js/59.4194402f.js"><link rel="prefetch" href="/mr-muggle/assets/js/6.ad05d8e5.js"><link rel="prefetch" href="/mr-muggle/assets/js/60.01275a59.js"><link rel="prefetch" href="/mr-muggle/assets/js/61.d314066d.js"><link rel="prefetch" href="/mr-muggle/assets/js/62.68ce6bc5.js"><link rel="prefetch" href="/mr-muggle/assets/js/63.34dea9e0.js"><link rel="prefetch" href="/mr-muggle/assets/js/64.9aaf5e00.js"><link rel="prefetch" href="/mr-muggle/assets/js/65.e4ce25ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/66.5d9f1db5.js"><link rel="prefetch" href="/mr-muggle/assets/js/67.c914fc65.js"><link rel="prefetch" href="/mr-muggle/assets/js/68.5ee52c48.js"><link rel="prefetch" href="/mr-muggle/assets/js/69.680accb1.js"><link rel="prefetch" href="/mr-muggle/assets/js/7.0c092304.js"><link rel="prefetch" href="/mr-muggle/assets/js/70.cf4408b5.js"><link rel="prefetch" href="/mr-muggle/assets/js/71.33ad3ca9.js"><link rel="prefetch" href="/mr-muggle/assets/js/72.87880929.js"><link rel="prefetch" href="/mr-muggle/assets/js/73.11b998f6.js"><link rel="prefetch" href="/mr-muggle/assets/js/74.5a75b187.js"><link rel="prefetch" href="/mr-muggle/assets/js/75.5301781a.js"><link rel="prefetch" href="/mr-muggle/assets/js/76.c446bc20.js"><link rel="prefetch" href="/mr-muggle/assets/js/77.4eaa9052.js"><link rel="prefetch" href="/mr-muggle/assets/js/78.3b98b54f.js"><link rel="prefetch" href="/mr-muggle/assets/js/79.60b9a9ba.js"><link rel="prefetch" href="/mr-muggle/assets/js/8.471386f2.js"><link rel="prefetch" href="/mr-muggle/assets/js/80.7b067e03.js"><link rel="prefetch" href="/mr-muggle/assets/js/81.8274f49e.js"><link rel="prefetch" href="/mr-muggle/assets/js/82.b72070ad.js"><link rel="prefetch" href="/mr-muggle/assets/js/83.4651609d.js"><link rel="prefetch" href="/mr-muggle/assets/js/84.fffdd780.js"><link rel="prefetch" href="/mr-muggle/assets/js/85.10865df0.js"><link rel="prefetch" href="/mr-muggle/assets/js/86.5b4b0452.js"><link rel="prefetch" href="/mr-muggle/assets/js/87.a270ec2b.js"><link rel="prefetch" href="/mr-muggle/assets/js/88.8bb08b0f.js"><link rel="prefetch" href="/mr-muggle/assets/js/89.3826a944.js"><link rel="prefetch" href="/mr-muggle/assets/js/9.d8124a2e.js"><link rel="prefetch" href="/mr-muggle/assets/js/90.dbf7dede.js"><link rel="prefetch" href="/mr-muggle/assets/js/91.0823b62f.js"><link rel="prefetch" href="/mr-muggle/assets/js/92.8ec406ed.js">
    <link rel="stylesheet" href="/mr-muggle/assets/css/0.styles.a4a1d2b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-6 ant-col-xl-5 ant-col-xxl-4"><a href="/mr-muggle/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Knowledge</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="nav-space-between ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-18 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mr-muggle/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          后端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          前端开发必知必会
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          数据库
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          消息队列
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          搜索引擎
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          项目部署与运维
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          办公软件
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <ul class="extra-group"><!----> <!----></ul></nav></div></div> <!----></header> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/mr-muggle/操作系统/Linux/Linux-base.html" title="Linux入门-基础" class="active sidebar-link">Linux入门-基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#前言" title="前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第一章-初探linux操作系统" title="第一章 初探Linux操作系统" class="sidebar-link">第一章 初探Linux操作系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#date-显示当前系统日期和时间" title="date-显示当前系统日期和时间" class="sidebar-link">date-显示当前系统日期和时间</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#cal-显示当前系统的日历" title="cal-显示当前系统的日历" class="sidebar-link">cal-显示当前系统的日历</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#df-查看磁盘空间" title="df-查看磁盘空间" class="sidebar-link">df-查看磁盘空间</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#free-查看linux可用内存" title="free-查看Linux可用内存" class="sidebar-link">free-查看Linux可用内存</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第二章-认识linux文件系统树" title="第二章 认识Linux文件系统树" class="sidebar-link">第二章 认识Linux文件系统树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#pwd-显示当前工作目录" title="pwd-显示当前工作目录" class="sidebar-link">pwd-显示当前工作目录</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#ls-列出目录内容" title="ls-列出目录内容" class="sidebar-link">ls-列出目录内容</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#cd-更改当前工作目录" title="cd-更改当前工作目录" class="sidebar-link">cd-更改当前工作目录</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#cd命令常用快捷方式" title="cd命令常用快捷方式" class="sidebar-link">cd命令常用快捷方式</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#文件名命名规则说明" title="文件名命名规则说明" class="sidebar-link">文件名命名规则说明</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#linux命令选项和参数" title="Linux命令选项和参数" class="sidebar-link">Linux命令选项和参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第三章-linux系统" title="第三章 Linux系统" class="sidebar-link">第三章 Linux系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#深入了解ls命令" title="深入了解ls命令" class="sidebar-link">深入了解ls命令</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#file-命令确定文件类型" title="file-命令确定文件类型" class="sidebar-link">file-命令确定文件类型</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#less-使用命令查看文本内容" title="less-使用命令查看文本内容" class="sidebar-link">less-使用命令查看文本内容</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#linux系统重要目录" title="Linux系统重要目录" class="sidebar-link">Linux系统重要目录</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第四章-操作目录和文件" title="第四章 操作目录和文件" class="sidebar-link">第四章 操作目录和文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#mkdir-创建目录" title="mkdir-创建目录" class="sidebar-link">mkdir-创建目录</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#cp-复制文件和目录" title="cp-复制文件和目录" class="sidebar-link">cp-复制文件和目录</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#mv-移动和重命名文件" title="mv-移动和重命名文件" class="sidebar-link">mv-移动和重命名文件</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#rm-删除文件或目录" title="rm-删除文件或目录" class="sidebar-link">rm-删除文件或目录</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#ln-创建软硬链接" title="ln-创建软硬链接" class="sidebar-link">ln-创建软硬链接</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#linux操作实践" title="Linux操作实践" class="sidebar-link">Linux操作实践</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第五章-命令的使用" title="第五章 命令的使用" class="sidebar-link">第五章 命令的使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#命令的含义" title="命令的含义" class="sidebar-link">命令的含义</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#type-显示命令的类型" title="type-显示命令的类型" class="sidebar-link">type-显示命令的类型</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#which-显示可执行程序的位置" title="which-显示可执行程序的位置" class="sidebar-link">which-显示可执行程序的位置</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#help-获取shell内置命令的帮助文档" title="help-获取shell内置命令的帮助文档" class="sidebar-link">help-获取shell内置命令的帮助文档</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#help选项-显示可执行命令的使用信息" title="help选项-显示可执行命令的使用信息" class="sidebar-link">help选项-显示可执行命令的使用信息</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#man-显示程序的手册页" title="man-显示程序的手册页" class="sidebar-link">man-显示程序的手册页</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#apropos-搜索合适的命令" title="apropos-搜索合适的命令" class="sidebar-link">apropos-搜索合适的命令</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#whatis-显示命令的简要描述" title="whatis-显示命令的简要描述" class="sidebar-link">whatis-显示命令的简要描述</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#info-显示程序的info条目" title="info-显示程序的info条目" class="sidebar-link">info-显示程序的info条目</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#定义和删除别名" title="定义和删除别名" class="sidebar-link">定义和删除别名</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#alias-查看与自定义命令别名" title="alias-查看与自定义命令别名" class="sidebar-link">alias-查看与自定义命令别名</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#unalias-删除命令别名" title="unalias-删除命令别名" class="sidebar-link">unalias-删除命令别名</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第六章-重定向" title="第六章 重定向" class="sidebar-link">第六章 重定向</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#标准输入、输出和标准错误" title="标准输入、输出和标准错误" class="sidebar-link">标准输入、输出和标准错误</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#i-o重定向-标准输出重定向" title="I/O重定向-标准输出重定向" class="sidebar-link">I/O重定向-标准输出重定向</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#i-o重定向-标准错误重定向" title="I/O重定向-标准错误重定向" class="sidebar-link">I/O重定向-标准错误重定向</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#标准输出、标准错误重定向输出到同一个文件" title="标准输出、标准错误重定向输出到同一个文件" class="sidebar-link">标准输出、标准错误重定向输出到同一个文件</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#位桶-抑制或隐藏不想要的输出" title="位桶-抑制或隐藏不想要的输出" class="sidebar-link">位桶-抑制或隐藏不想要的输出</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#cat-合并、查看、创建文件以及重定向" title="cat-合并、查看、创建文件以及重定向" class="sidebar-link">cat-合并、查看、创建文件以及重定向</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#管道操作符-过滤器" title="|-管道操作符 &amp;&amp; 过滤器" class="sidebar-link">|-管道操作符 &amp;&amp; 过滤器</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#uniq-报告或忽略文件中重复的行" title="uniq-报告或忽略文件中重复的行" class="sidebar-link">uniq-报告或忽略文件中重复的行</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#wc-打印行数、字数和字节数" title="wc-打印行数、字数和字节数" class="sidebar-link">wc-打印行数、字数和字节数</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#grep-打印文本中的匹配行" title="grep-打印文本中的匹配行" class="sidebar-link">grep-打印文本中的匹配行</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#head-tail-打印文件的开头部分-结尾部分" title="head/tail-打印文件的开头部分/结尾部分" class="sidebar-link">head/tail-打印文件的开头部分/结尾部分</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#tee-从标准输入读取并输出到标准输出和文件" title="tee-从标准输入读取并输出到标准输出和文件" class="sidebar-link">tee-从标准输入读取并输出到标准输出和文件</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第七章-透过shell看世界" title="第七章 透过Shell看世界" class="sidebar-link">第七章 透过Shell看世界</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#路径名扩展" title="路径名扩展" class="sidebar-link">路径名扩展</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#波浪线扩展" title="波浪线扩展" class="sidebar-link">波浪线扩展</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#算术扩展" title="算术扩展" class="sidebar-link">算术扩展</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#花括号扩展" title="花括号扩展" class="sidebar-link">花括号扩展</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#参数扩展" title="参数扩展" class="sidebar-link">参数扩展</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#命令替换" title="命令替换" class="sidebar-link">命令替换</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#各种类型的引用" title="各种类型的引用" class="sidebar-link">各种类型的引用</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第八章-高级键盘技巧" title="第八章 高级键盘技巧" class="sidebar-link">第八章 高级键盘技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#光标移动快捷键" title="光标移动快捷键" class="sidebar-link">光标移动快捷键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#修改文本快捷键" title="修改文本快捷键" class="sidebar-link">修改文本快捷键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#剪切、粘贴文本快捷键" title="剪切、粘贴文本快捷键" class="sidebar-link">剪切、粘贴文本快捷键</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#tab键-自动补齐" title="Tab键-自动补齐" class="sidebar-link">Tab键-自动补齐</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#history-搜索历史" title="history-搜索历史" class="sidebar-link">history-搜索历史</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#历史记录扩展" title="历史记录扩展" class="sidebar-link">历史记录扩展</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第九章-权限管理" title="第九章 权限管理" class="sidebar-link">第九章 权限管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#所有者、组成员和其他所有用户" title="所有者、组成员和其他所有用户" class="sidebar-link">所有者、组成员和其他所有用户</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#id-显示用户身份标识" title="id-显示用户身份标识" class="sidebar-link">id-显示用户身份标识</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#读取、写入和执行权限" title="读取、写入和执行权限" class="sidebar-link">读取、写入和执行权限</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#chmod-更改文件模式-权限" title="chmod-更改文件模式（权限）" class="sidebar-link">chmod-更改文件模式（权限）</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#su-以其他用户和组id的身份来运行shell" title="su-以其他用户和组ID的身份来运行shell" class="sidebar-link">su-以其他用户和组ID的身份来运行shell</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#su和sudo命令的几点区别" title="su和sudo命令的几点区别" class="sidebar-link">su和sudo命令的几点区别</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#chown-更改文件所有者和所属群组" title="chown-更改文件所有者和所属群组" class="sidebar-link">chown-更改文件所有者和所属群组</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#passwd-修改用户密码" title="passwd-修改用户密码" class="sidebar-link">passwd-修改用户密码</a></li></ul></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#第十章-进程信息查看与进程控制" title="第十章 进程信息查看与进程控制" class="sidebar-link">第十章 进程信息查看与进程控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#进程的工作方式" title="进程的工作方式" class="sidebar-link">进程的工作方式</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#ps-显示当前所有进程的运行情况" title="ps-显示当前所有进程的运行情况" class="sidebar-link">ps-显示当前所有进程的运行情况</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#top-动态查看进程信息" title="top-动态查看进程信息" class="sidebar-link">top-动态查看进程信息</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#ctrl-c-中断进程" title="Ctrl-C-中断进程" class="sidebar-link">Ctrl-C-中断进程</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#使进程在后台运行" title="&amp;-使进程在后台运行" class="sidebar-link">&amp;-使进程在后台运行</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#jobs-查看当前终端后台运行的任务" title="jobs-查看当前终端后台运行的任务" class="sidebar-link">jobs-查看当前终端后台运行的任务</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#fg-让进程回到前台运行" title="fg-让进程回到前台运行" class="sidebar-link">fg-让进程回到前台运行</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#ctrl-z-停止-暂停-进程" title="Ctrl-Z-停止（暂停）进程" class="sidebar-link">Ctrl-Z-停止（暂停）进程</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#bg-让进程移到后台运行" title="bg-让进程移到后台运行" class="sidebar-link">bg-让进程移到后台运行</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#kill-发送信号到进程" title="kill-发送信号到进程" class="sidebar-link">kill-发送信号到进程</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#kill命令最常用的发送信号" title="Kill命令最常用的发送信号" class="sidebar-link">Kill命令最常用的发送信号</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#系统常用的其它信号" title="系统常用的其它信号" class="sidebar-link">系统常用的其它信号</a></li><li class="sidebar-sub-header"><a href="/mr-muggle/操作系统/Linux/Linux-base.html#killall-发送信号给多个进程" title="killall-发送信号给多个进程" class="sidebar-link">killall-发送信号给多个进程</a></li></ul></li></ul></li><li><a href="/mr-muggle/操作系统/Linux/Linux-env-config.html" title="Linux入门-Linux环境与配置" class="sidebar-link">Linux入门-Linux环境与配置</a></li><li><a href="/mr-muggle/操作系统/Linux/Linux-tasks-utils.html" title="Linux入门-常见任务和主要工具" class="sidebar-link">Linux入门-常见任务和主要工具</a></li><li><a href="/mr-muggle/操作系统/Linux/Linux-practice.html" title="Linux实践-常见操作集锦" class="sidebar-link">Linux实践-常见操作集锦</a></li><li><a href="/mr-muggle/操作系统/Linux/Linux-shell.html" title="Linux入门-shell基础" class="sidebar-link">Linux入门-shell基础</a></li></ul> </aside> <main class="page has-page-anchor"> <div class="theme-antdocs-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>对于普通的PC使用者来说，学会使用Windows操作系统已经足够了。但是，对于一个软件开发者来说，仅仅会使用Windows操作系统是不行的，还需要学会使用Linux操作系统。《Linux命令行大全》正是一本能够帮助初学者系统了解Linux操作系统基本操作的书籍，因此我决定仔细阅读一下。为了方便以后查阅相关知识点，我决定将所学知识记录下来。和《Linux命令行大全》一书一样，笔者并不打算告诉你如何安装Linux操作系统，安装Linux操作系统的详细步骤可以在网络上方便地找到，在此，就不再赘述了。大多数Linux书籍都会告诉你使用Vmware或其它虚拟机安装Linux操作系统。在这里，笔者直接使用阿里云的ECS服务器Centos 6.8，这是Linux的一种发行版本，在互联网行业中得到广泛使用。一般情况下，我们都不会直接操作Linux操作系统，更普遍的情况是，我们会通过Xshell等终端远程连接、访问并操作Linux操作系统。</p> <div class="custom-block tip"><p class="custom-block-title">Xshell简介</p> <p>Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows平台的TELNET协议，可以用来连接并操作远端服务器。Xshell提供了个人和家庭使用的免费版本，而且其安装也是相当简单的，读者可以自行搜索Xshell下载并安装。</p></div> <p>当我们准备好Linux操作系统，并通过Xshell连接到远程服务器并登录后，就可以进行相关操作了。</p> <h2 id="第一章-初探linux操作系统"><a href="#第一章-初探linux操作系统" class="header-anchor">#</a> 第一章 初探Linux操作系统</h2> <p>既然是初探，就应该循序渐进，而不是揠苗助长。学习Linux系统，其实主要学习的是命令行命令。因此，我们先从简单的Linux命令入手。</p> <h3 id="date-显示当前系统日期和时间"><a href="#date-显示当前系统日期和时间" class="header-anchor">#</a> <code>date</code>-显示当前系统日期和时间</h3> <p>首先，我们学习如何显示当前系统的时间和日期，这个命令很简单，只需要在终端上输入<code>date</code>命令并回车即可。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">date</span> 
</code></pre></div><p>此时，Xshell界面会返回当前日期和时间</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Wed Feb <span class="token number">20</span> <span class="token number">11</span>:26:30 CST <span class="token number">2019</span>
</code></pre></div><h3 id="cal-显示当前系统的日历"><a href="#cal-显示当前系统的日历" class="header-anchor">#</a> <code>cal</code>-显示当前系统的日历</h3> <p>接下来，我们再敲一个<code>cal</code>命令，这个命令用来显示当前系统的日历，默认情况下，该命令的结果将返回当前月的日历。和上面类似，我们在终端直接输入<code>cal</code>命令并回车就行了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cal</span>
</code></pre></div><p>此时，我们将在终端看到一个显示当前月的日历。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>February <span class="token number">2019</span>   
Su Mo Tu We Th Fr Sa
                <span class="token number">1</span>  <span class="token number">2</span>
 <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  <span class="token number">6</span>  <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span>
<span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span>
<span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span>
<span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span> <span class="token number">28</span>
</code></pre></div><p>通过以上两个例子，我们初步感受了Linux命令行的使用。下面，我们学习一下查看磁盘驱动器可用空间以及Linux可用内存的命令。</p> <h3 id="df-查看磁盘空间"><a href="#df-查看磁盘空间" class="header-anchor">#</a> <code>df</code>-查看磁盘空间</h3> <p>查看磁盘驱动器可用空间的命令比较简单，直接输入<code>df</code>命令并回车即可。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">df</span>
</code></pre></div><p>这样，我们可以得到如下信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/vda1       <span class="token number">41151808</span> <span class="token number">2001384</span>  <span class="token number">37053376</span>   <span class="token number">6</span>% /
tmpfs             <span class="token number">509988</span>       <span class="token number">0</span>    <span class="token number">509988</span>   <span class="token number">0</span>% /dev/shm
</code></pre></div><h3 id="free-查看linux可用内存"><a href="#free-查看linux可用内存" class="header-anchor">#</a> <code>free</code>-查看Linux可用内存</h3> <p>然后，我们再学习查看Linux可用内存的命令，这个命令和前面一样简单，直接在终端输入<code>free</code>命令回车即可。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">free</span>
</code></pre></div><p>这样，我们得到如下结果</p> <div class="language-shell extra-class"><pre class="language-shell"><code>             total       used       <span class="token function">free</span>     shared    buffers     cached
Mem:       <span class="token number">1019980</span>     <span class="token number">920564</span>      <span class="token number">99416</span>        <span class="token number">160</span>     <span class="token number">143624</span>     <span class="token number">681376</span>
-/+ buffers/cache:      <span class="token number">95564</span>     <span class="token number">924416</span>
Swap:            <span class="token number">0</span>          <span class="token number">0</span>          <span class="token number">0</span>
</code></pre></div><p>当我们完成所有操作后，我们可以在终端输入<code>exit</code>命令断开本机与远程Linux的连接。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">exit</span>
</code></pre></div><h2 id="第二章-认识linux文件系统树"><a href="#第二章-认识linux文件系统树" class="header-anchor">#</a> 第二章 认识Linux文件系统树</h2> <p>在上一节中，我们初步体验了在Xshell终端中输入命令操作Linux，在本节中，我们开始学习Linux文件系统树。和Windows相同，Linux也是以称之为分层目录结构的方式来组织文件的。这也就意味着文件是在树形结构的目录中组织的，在该树形结构目录中可能包含有文件和其他目录。文件系统的第一个目录称为根目录，它包含了文件和子目录，子目录包含了更多的文件和子目录，就这样一直重复下去，最终构成了Linux文件系统树。</p> <div class="custom-block warning"><p class="custom-block-title">Windows和类Unix系统文件系统树的区别</p> <p>需要注意的是，虽然Windows和Linux组织文件的方式相同，但在Windows系统中，每个存储设备都有一个独立的文件系统树
，而在Linux这些类Unix系统中，无论存在多少驱动器和存储设备，通常都只有一个文件系统树，类Unix系统会根据系统管理员的设置，将设备挂载到文件系统树的不同位置。</p></div> <h3 id="pwd-显示当前工作目录"><a href="#pwd-显示当前工作目录" class="header-anchor">#</a> <code>pwd</code>-显示当前工作目录</h3> <p>和Windows一样，当我们处在某个目录中，我们可以看到该目录所包含的文件、去往上一级目录的路径，以及下一级的子目录。此时我们所处的目录称为当前工作目录。正如GPS导航系统可以显示我们所处的经纬度信息一样，我们也可以让Linux告诉我们当前工作目录的路径，使用<code>pwd</code>命令可以显示当前工作目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">pwd</span>
</code></pre></div><p>通过这个命令，我们可以知道当前工作目录的路径。既然可以知道当前工作目录，我们也就可以知道当前目录下的文件和子目录。当我们第一次登陆系统时，当前工作目录会被设置成主目录。每个用户都会有一个主目录，对于普通用户来说，主目录是唯一一个允许用户进行写操作的地方。</p> <h3 id="ls-列出目录内容"><a href="#ls-列出目录内容" class="header-anchor">#</a> <code>ls</code>-列出目录内容</h3> <p>在Linux中，我们可以使用<code>ls</code>命令列出当前目录的文件和子目录</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span>
</code></pre></div><p>当然，<code>ls</code>命令还有其它用法，在后面的内容中将会更加详细地介绍。</p> <h3 id="cd-更改当前工作目录"><a href="#cd-更改当前工作目录" class="header-anchor">#</a> <code>cd</code>-更改当前工作目录</h3> <p>绝大多数情况下，我们都需要更改当前工作目录，此时，我们需要使用<code>cd</code>命令切换工作目录。一般情况下，我们输入<code>cd</code>命令后还需要指定具体的目标工作目录的路径，所谓路径指的是沿着分枝到达目标目录的路由。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> target
</code></pre></div><p>和Windows类似，Linux的路径也分为绝对路径和相对路径</p> <ul><li><strong>绝对路径</strong>：绝对路径从根目录开始，其后跟着一个又一个文件树分枝，直到到达目标目录或文件。对于绝对路径来说，其显著特征是以前导斜杠<code>/</code>开头。</li></ul> <p>例如，在Linux系统中，有一个目录，大多数系统程序都安装到这个目录里，这个目录是<code>/usr/bin</code>,这也就意味着在根目录下有一个目录usr，在目录usr下存在bin目录，现在我们切换过去</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/bin
</code></pre></div><p>此时，我们使用<code>pwd</code>命令显示当前工作目录</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">pwd</span>
</code></pre></div><p>可以看到，当前工作目录已经是<code>/usr/bin</code>，我们使用<code>ls</code>查看当前工作目录下的文件及子目录，可以看到数量是非常多的。</p> <ul><li><strong>相对路径</strong>：和绝对路径从根目录开始，到目标目录或文件结束不同，相对路径则是从工作目录开始的。我们可以使用一些特殊符号来表示文件系统树中的相对位置，这些符号是<code>.</code>和<code>..</code>。符号<code>.</code>表示工作目录，符号<code>..</code>表示工作目录的父目录。</li></ul> <p>若我们想更改当前工作目录<code>\usr\bin</code>为<code>\usr</code>，即当前目录的父目录，可以有两种方式。</p> <ul><li>绝对路径方式</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr
</code></pre></div><ul><li>相对路径方式</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>
</code></pre></div><p>无论哪种方式，我们都可以切换到<code>\usr</code>目录。当然，我们也可以从<code>\usr</code>目录切换到<code>\usr\bin</code>目录。同样地，我们也有两种方式。</p> <ul><li>绝对路径方式</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/bin
</code></pre></div><ul><li>相对路径方式</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ./bin
</code></pre></div><p>在相对路径方式下，我们还可以省略<code>./</code>，因为其是隐含的。即</p> <ul><li>隐含相对路径方式</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> bin
</code></pre></div><p>一般而言，若是没有指定目录，则默认为当前工作目录</p> <h3 id="cd命令常用快捷方式"><a href="#cd命令常用快捷方式" class="header-anchor">#</a> <code>cd</code>命令常用快捷方式</h3> <p><code>cd</code>命令提供了几个可以快速切换工作目录的方法</p> <table><thead><tr><th>快捷方式</th> <th>结果</th></tr></thead> <tbody><tr><td>cd</td> <td>将工作目录切换到主目录</td></tr> <tr><td>cd -</td> <td>将工作目录切换到先前的工作目录</td></tr> <tr><td>cd~username</td> <td>将工作目录切换为username的主目录</td></tr></tbody></table> <h3 id="文件名命名规则说明"><a href="#文件名命名规则说明" class="header-anchor">#</a> 文件名命名规则说明</h3> <ol><li>在Linux中，以<code>.</code>开头的文件是隐藏的，这仅仅说明<code>ls</code>命令不会列出该文件，除非使用<code>ls -a</code>命令，在创建用户账号时，主目录会放置一些隐藏文件，用来配置账号信息。此外，一些应用程序也会将它们的配置文件和设置文件以隐藏文件的形式放在主目录下。</li> <li>Linux文件名与命令都是区分字母大小写的。例如：File1和file1是不一样的。</li> <li>Linux没有扩展名的概念，我们可以按照自己的喜好随意给文件命名。文件的内容或用途由其它方式决定。虽然如此，一些应用程序仍然使用扩展名区分文件内容和用途。</li> <li>Linux支持长文件名，但在文件名中不要嵌入空格，以免给自己带来不必要的麻烦。</li></ol> <h3 id="linux命令选项和参数"><a href="#linux命令选项和参数" class="header-anchor">#</a> Linux命令选项和参数</h3> <p>在Linux中，大部分命令都遵循以下格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>commond <span class="token parameter variable">-options</span> arguments
</code></pre></div><p>即通常情况下，一个命令会带有一个或多个选项，带有不同选项的命令其功能也会有所不同，此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象。大部分命令的选项是在单个字符前加上连字符<code>-</code>,但是很多命令，包括GNU里面的命令，也支持在单字前加上两个连字符<code>--</code>的长选项，而且很多命令也允许多个短选项串在一起使用。
下面，我们通过<code>ls</code>命令说明上述描述。</p> <h2 id="第三章-linux系统"><a href="#第三章-linux系统" class="header-anchor">#</a> 第三章 Linux系统</h2> <h3 id="深入了解ls命令"><a href="#深入了解ls命令" class="header-anchor">#</a> 深入了解<code>ls</code>命令</h3> <p>前面说到，<code>ls</code>命令的作用是列出目录内容，鉴于 <code>ls</code>命令是用户最常用的命令之一，它能查看目录内容，确定各种重要文件和目录的属性，我们有必要详细了解一下<code>ls</code>丰富的用法。</p> <ol><li><p>若我们直接查看当前工作目录下的文件和子目录，我们可以直接使用不带参的<code>ls</code>命令，即</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span>
</code></pre></div><p>这样，我们就可以获取当前工作目录的文件和子目录信息了</p> <div class="language-shell extra-class"><pre class="language-shell"><code>bin  etc  games  include  <span class="token function">java</span>  lib  lib64  libexec  <span class="token builtin class-name">local</span>  sbin  share  src  tmp
</code></pre></div></li> <li><p>若我们想要查看指定目录的信息，我们可以直接指定目录</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span>  /usr
</code></pre></div><p>当然我们也可以一次性指定多个目录，同时查看多个目录下的文件和子目录</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span> ~ /usr
</code></pre></div><p>其中，~指的是当前账户的主目录，现在，我使用的是root账号，执行这条命令，可以得到如下结果</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/root:

/usr:
bin  etc  games  include  <span class="token function">java</span>  lib  lib64  libexec  <span class="token builtin class-name">local</span>  sbin  share  src  tmp
</code></pre></div><p>可以看到，在当前账户的主目录下，没有任何文件和子目录，而在<code>\usr</code>目录下则存在多个子目录。</p></li> <li><p>若我们想要展示更多的信息并按照文件修改时间排序，我们可以使用选项<code>l</code>,<code>t</code>，选项<code>l</code>产生长格式输出，<code>t</code>选项表示以文件修改的时间顺序先后将结果输出</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span> <span class="token parameter variable">-lt</span> /usr
</code></pre></div><p>这样，我们就按长格式输出<code>/usr</code>目录下按照文件修改的时间排序的文件和子目录信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">72</span>
dr-xr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Aug  <span class="token number">8</span>  <span class="token number">2018</span> sbin
drwxr-xr-x   <span class="token number">3</span> root root  <span class="token number">4096</span> Jul <span class="token number">25</span>  <span class="token number">2018</span> <span class="token function">java</span>
dr-xr-xr-x. <span class="token number">28</span> root root <span class="token number">12288</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> lib64
dr-xr-xr-x.  <span class="token number">2</span> root root <span class="token number">20480</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> bin
dr-xr-xr-x. <span class="token number">12</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> lib
drwxr-xr-x. <span class="token number">13</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> <span class="token builtin class-name">local</span>
drwxr-xr-x. <span class="token number">65</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> share
drwxr-xr-x. <span class="token number">10</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> libexec
drwxr-xr-x. <span class="token number">35</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> include
drwxr-xr-x.  <span class="token number">4</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> src
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">10</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> tmp -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/var/tmp
drwxr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Sep <span class="token number">23</span>  <span class="token number">2011</span> etc
drwxr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Sep <span class="token number">23</span>  <span class="token number">2011</span> games
</code></pre></div><p>若我们想按照相反顺序输出，则加上长选项<code>--reverse</code>即可，即</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span> <span class="token parameter variable">-lt</span> <span class="token parameter variable">--reverse</span> /usr
</code></pre></div><p>可以预料，输出结果和原结果排序正好相反</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">72</span>
drwxr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Sep <span class="token number">23</span>  <span class="token number">2011</span> games
drwxr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Sep <span class="token number">23</span>  <span class="token number">2011</span> etc
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">10</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> tmp -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/var/tmp
drwxr-xr-x.  <span class="token number">4</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> src
drwxr-xr-x. <span class="token number">35</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> include
drwxr-xr-x. <span class="token number">10</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> libexec
drwxr-xr-x. <span class="token number">65</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> share
drwxr-xr-x. <span class="token number">13</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> <span class="token builtin class-name">local</span>
dr-xr-xr-x. <span class="token number">12</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> lib
dr-xr-xr-x.  <span class="token number">2</span> root root <span class="token number">20480</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> bin
dr-xr-xr-x. <span class="token number">28</span> root root <span class="token number">12288</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> lib64
drwxr-xr-x   <span class="token number">3</span> root root  <span class="token number">4096</span> Jul <span class="token number">25</span>  <span class="token number">2018</span> <span class="token function">java</span>
dr-xr-xr-x.  <span class="token number">2</span> root root  <span class="token number">4096</span> Aug  <span class="token number">8</span>  <span class="token number">2018</span> sbin
</code></pre></div></li></ol> <p>对于<code>ls</code>命令，Linux提供了相当多的选项，常用选项罗列如下</p> <ol start="4"><li><code>ls</code>命令常用选项及含义</li></ol> <table><thead><tr><th>选项</th> <th>长选项</th> <th>含义</th></tr></thead> <tbody><tr><td><code>-a</code></td> <td><code>--all</code></td> <td>列出所有文件，包括以<code>.</code>开头的隐藏文件，<br>这些文件在不加该选项时是不显示的</td></tr> <tr><td><code>-d</code></td> <td><code>--directory</code></td> <td>通常情况下，<code>ls</code>命令会罗列指定目录下的文件和子目录，<br>若想要查看目录本身的信息，需要使用该选项。若与<code>l</code>选<br>项相结合，可以罗列出目录本身的详细信息</td></tr> <tr><td><code>-F</code></td> <td><code>--classify</code></td> <td>该选项会在每个所列出的名字后面加上类型指示符，<br>若是一个目录，则会加上一个斜杠</td></tr> <tr><td><code>-h</code></td> <td><code>--human-readable</code></td> <td>若使用该选项，当信息以长格式列出时，Linux将以人类可读的方式<br>而不是字节数显示文件大小</td></tr> <tr><td><code>-l</code></td> <td></td> <td>使用长格式显示结果</td></tr> <tr><td><code>-r</code></td> <td><code>--reverse</code></td> <td>以相反的顺序显示结果，通常情况下，<code>ls</code>命令按照字母升序<br>排列显示结果</td></tr> <tr><td><code>-S</code></td> <td></td> <td>按文件大小对结果排序</td></tr> <tr><td><code>-t</code></td> <td></td> <td>按修改时间排序</td></tr></tbody></table> <ol start="5"><li>了解<code>ls</code>命令长格式信息含义</li></ol> <p>我们随意选取一条长格式的输出结果</p> <div class="language-shell extra-class"><pre class="language-shell"><code>dr-xr-xr-x. <span class="token number">12</span> root root  <span class="token number">4096</span> Aug <span class="token number">24</span>  <span class="token number">2017</span> lib
</code></pre></div><p>我们将结果进行拆分，查看这些字段的含义</p> <table><thead><tr><th>字段</th> <th>含义</th></tr></thead> <tbody><tr><td>dr-xr-xr-x</td> <td>这表示的是用户对文件的访问权限；<br>第一个字符表示文件的类型。<br>在不同的类型中，开头的<code>-</code>表示该文件是一个普通文件，<code>d</code>表示目录,<code>l</code>表示链接文件。<br>紧接着的三个字符表示文件所有者的访问权限，<br>再紧接着的三个字符表示文件所属组中成员的访问权限，<br>最后三个字符表示其他所有人的访问权限</td></tr> <tr><td>12</td> <td>文件硬链接数目</td></tr> <tr><td>root</td> <td>文件所有者的用户名称</td></tr> <tr><td>root</td> <td>文件所属用户组名称</td></tr> <tr><td>4096</td> <td>以字节数表示的文件大小</td></tr> <tr><td>Aug 24  2017</td> <td>上次修改文件的日期和时间，即最近改动文件时间</td></tr> <tr><td>lib</td> <td>文件名</td></tr></tbody></table> <h3 id="file-命令确定文件类型"><a href="#file-命令确定文件类型" class="header-anchor">#</a> <code>file</code>-命令确定文件类型</h3> <p>先前讲过，Linux并不能通过后缀名确定文件类型，因此，我们需要使用其它命令来确定文件类型，Linux提供了<code>file</code>命令查看文件类型，其命令格式为：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">file</span> filename
</code></pre></div><p>我们查看一下目录<code>\usr\include</code>下的<code>poll.h</code>文件类型</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">file</span> poll.h
</code></pre></div><p>可以看到，这是一个ASCII C文本文件，也就是C语言编写的源文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code>poll.h: ASCII C program text
</code></pre></div><h3 id="less-使用命令查看文本内容"><a href="#less-使用命令查看文本内容" class="header-anchor">#</a> <code>less</code>-使用命令查看文本内容</h3> <p>在Linux中，很多文件都以文本文件的形式存储，不可避免地，我们需要经常查看这类格式的文件。因此，我们有必要学习如何查看文本文件。</p> <p>在该系统中，Linux提供了各种各样的命令帮助我们查看文本内容，我们学习<code>less</code>命令，其命令格式为：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">less</span> filename
</code></pre></div><p>一旦运行该命令，<code>less</code>命令将允许我们前后滚动文件，这样我们就能查看内容了，现在我们查看一下<code>/etc/passwd</code>文件内容。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">less</span> /etc/passwd
</code></pre></div><p>若我们查看完成，可以按<code>q</code>退出程序。下面列出<code>less</code>命令常用的键盘命令。</p> <table><thead><tr><th>命令</th> <th>功能</th></tr></thead> <tbody><tr><td><code>Page Up</code>或<code>b</code></td> <td>后翻一页</td></tr> <tr><td><code>Page Down</code>或<code>Space</code></td> <td>前翻一页</td></tr> <tr><td>向上箭头</td> <td>向上一行</td></tr> <tr><td>向下箭头</td> <td>向下一行</td></tr> <tr><td><code>G</code></td> <td>跳到文本文件末尾</td></tr> <tr><td><code>g</code></td> <td>跳到文本文件开头</td></tr> <tr><td><code>/charaters</code></td> <td>向前查找指定的字符串</td></tr> <tr><td><code>n</code></td> <td>向前查找指定的字符串，该字符串是之前指定查找的</td></tr> <tr><td><code>h</code></td> <td>显示帮助屏幕</td></tr> <tr><td><code>q</code></td> <td>退出less</td></tr></tbody></table> <h3 id="linux系统重要目录"><a href="#linux系统重要目录" class="header-anchor">#</a> Linux系统重要目录</h3> <p>在Linux中，存在一些比较重要的目录，这些目录存储了比较重要的程序或文件，我们需要对其有一定的了解。</p> <table><thead><tr><th>目录</th> <th>内容</th></tr></thead> <tbody><tr><td><code>/</code></td> <td>根目录</td></tr> <tr><td><code>/bin</code></td> <td>包含系统启动和运行必须的二进制文件</td></tr> <tr><td><code>/sbin</code></td> <td>该目录放置&quot;系统&quot;二进制文件，这些文件执行重要的系统任务</td></tr> <tr><td><code>/boot</code></td> <td>包含Linux内核，最初的RAM磁盘映像（系统启动时会用到）,以及自动加载程序</td></tr> <tr><td><code>/lib</code></td> <td>包含核心系统程序使用的共享库文件</td></tr> <tr><td><code>/dev</code></td> <td>包含设备节点的特殊目录</td></tr> <tr><td><code>/etc</code></td> <td>包含所有系统层面的配置文件，同时也包含一系列shell脚本，系统启动时，这些脚本都会打开相应的系统服务</td></tr> <tr><td><code>/home</code></td> <td>通常情况下，每个用户都会在<code>/home</code>目录下有属于自己的一个目录，普通用户只能在自己的主目录中创建文件</td></tr> <tr><td><code>/opt</code></td> <td>主要用来安装其他可选软件，一般用来安装可能安装在系统内的商业软件</td></tr> <tr><td><code>/usr</code></td> <td>包含普通用户使用的所有程序和相关文件</td></tr> <tr><td><code>/usr/sbin</code></td> <td>系统管理程序</td></tr> <tr><td><code>/var/log</code></td> <td>该目录包含的日志文件极其重要，记录了各种系统活动</td></tr> <tr><td><code>/tmp</code></td> <td>供用户存放各类程序创建的临时文件，在系统重启后，会清空该目录</td></tr> <tr><td><code>/var</code></td> <td>可能改变的数据会存储在该目录中，如各种数据库、假脱机文件、用户邮件</td></tr> <tr><td><code>/root</code></td> <td>root账户的主目录</td></tr></tbody></table> <h2 id="第四章-操作目录和文件"><a href="#第四章-操作目录和文件" class="header-anchor">#</a> 第四章 操作目录和文件</h2> <p>在Windows里，我们通常使用图形界面提供的功能来对目录和文件进行操作，在Linux中，我们应当尝试使用命令操作目录和文件，因为在实际开发中，我们使用的服务器一般是没有图形界面的。</p> <p>在学习如何使用命令操作目录和文件之前，我们先学习一下通配符。通配符是一些特殊字符，它允许用户根据字符模式选择文件名，通过通配符，使得为文件名构建复杂的筛选标准成为可能。</p> <ol><li>常用的通配符</li></ol> <table><thead><tr><th>通配符</th> <th>匹配项</th></tr></thead> <tbody><tr><td><code>*</code></td> <td>匹配任意多个字符，包括0个或1个</td></tr> <tr><td><code>?</code></td> <td>匹配任意一个字符，不包括0个</td></tr> <tr><td><code>[characters]</code></td> <td>匹配任意一个属于字符集的字符</td></tr> <tr><td><code>[!characters]</code></td> <td>匹配任意一个不属于字符集的字符</td></tr> <tr><td><code>[[:class:]]</code></td> <td>匹配任意一个属于指定字符类的字符</td></tr></tbody></table> <ol start="2"><li>常用的字符类</li></ol> <table><thead><tr><th>字符类</th> <th>匹配项</th></tr></thead> <tbody><tr><td><code>[:alnum:]</code></td> <td>匹配任意一个字母或数字</td></tr> <tr><td><code>[:alpha:]</code></td> <td>匹配任意一个字母</td></tr> <tr><td><code>[:digit:]</code></td> <td>匹配任意一个数字</td></tr> <tr><td><code>[:lower:]</code></td> <td>匹配任意一个小写字母</td></tr> <tr><td><code>[:upper:]</code></td> <td>匹配任意一个大写字母</td></tr></tbody></table> <ol start="3"><li>通配符和常用字符类使用示例</li></ol> <table><thead><tr><th>模式</th> <th>匹配项</th></tr></thead> <tbody><tr><td><code>*</code></td> <td>所有文件</td></tr> <tr><td><code>g*</code></td> <td>以g开头的任意文件</td></tr> <tr><td><code>b*.txt</code></td> <td>以b开头，中间有任意多个字符，以.txt结尾的文件</td></tr> <tr><td><code>Data???</code></td> <td>以Data开头，后面跟任意三个字符的文件</td></tr> <tr><td><code>[![:digit:]]*</code></td> <td>不以数字开头的任意文件</td></tr></tbody></table> <h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="header-anchor">#</a> <code>mkdir</code>-创建目录</h3> <p>现在，我们先学习第一个命令，创建目录的<code>mkdir</code>命令，格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> directory<span class="token punctuation">..</span>.
</code></pre></div><p><code>...</code>表示可以同时创建多个目录，directory代表具体的目录名称。可以看到，我们可以同时创建一个或多个目录。</p> <ol><li>创建单个目录的命令格式</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> directory1
</code></pre></div><ol start="2"><li>创建多个目录的命令格式</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> directory1 directory2 directory3
</code></pre></div><p>创建多个目录时，目录之间以空格作为间隔。下面，我们学习复制文件和目录的<code>cp</code>命令。</p> <h3 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="header-anchor">#</a> <code>cp</code>-复制文件和目录</h3> <p><code>cp</code>命令用来复制文件和目录，需要注意的是，<code>cp</code>命令有两种用法。</p> <ol><li>将单个文件或目录item1复制到文件或目录item2中，其命令格式如下：</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> item1 item2
</code></pre></div><p>该命令表示将单个文件或目录item1复制到文件或目录item2中。</p> <ol start="2"><li>若要将多个目录复制到同一文件夹则需要使用以下命令格式：</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> item<span class="token punctuation">..</span>. directory
</code></pre></div><p>当然，在实际使用过程中，<code>cp</code>命令并不会这么简单，Linux提供了多个选项供我们自定义复制。</p> <table><thead><tr><th>选项</th> <th>长选项</th> <th>含义</th></tr></thead> <tbody><tr><td><code>-a</code></td> <td><code>--archive</code></td> <td>复制文件和目录及其属性，包括所有权和权限。<br> 通常来说，复制的文件具有用户所操作文件的默认属性</td></tr> <tr><td><code>-i</code></td> <td><code>--interactive</code></td> <td>在覆盖一个已存在的文件前，提示用户进行确认。<br>如果没有该选项，<code>cp</code>命令将执行直接覆盖操作</td></tr> <tr><td><code>-r</code></td> <td><code>--recursive</code></td> <td><strong>递归复制目录及其内容，复制目录时需要这个选项</strong></td></tr> <tr><td><code>-u</code></td> <td><code>--update</code></td> <td>当将文件从一个目录复制到另一个目录时，只会复制那些目标<br>文件中不存在的文件或目标文件相应文件的更新文件</td></tr> <tr><td><code>-v</code></td> <td><code>--verbose</code></td> <td>复制文件时，显示信息性消息</td></tr></tbody></table> <h3 id="mv-移动和重命名文件"><a href="#mv-移动和重命名文件" class="header-anchor">#</a> <code>mv</code>-移动和重命名文件</h3> <p><strong><code>mv</code>命令可以执行文件移动和文件重命名操作，具体取决于如何使用它。</strong> 无论如何使用，操作完成后，原来的文件将不再存在，<code>mv</code>命令的使用方式和<code>cp</code>命令相似，都有两种使用方法。</p> <ol><li>将文件或目录item1移动或重命名为item2</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> item1 item2
</code></pre></div><ol start="2"><li>将一个或多个文件或目录移动到另一个目录下</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> item<span class="token punctuation">..</span>. directory
</code></pre></div><p><code>mv</code>命令和<code>cp</code>命令很多选项是共享的。</p> <table><thead><tr><th>选项</th> <th>长选项</th> <th>含义</th></tr></thead> <tbody><tr><td><code>-i</code></td> <td><code>--interactive</code></td> <td>覆盖一个文件之前，提示用户确认，<br>如果没有指定该选项，默认会覆盖文件</td></tr> <tr><td><code>-u</code></td> <td><code>--update</code></td> <td>将文件从一个目录复制到另外一个目录，只移动目标目录<br>不存在的文件或目标目录里相应文件的更新文件</td></tr> <tr><td><code>-v</code></td> <td><code>--verbose</code></td> <td>移动文件时显示信息性消息</td></tr></tbody></table> <p>下面是<code>mv</code>命令的一些使用示例。</p> <ol><li>将文件移到另一个文件</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> file1 file2
</code></pre></div><p>将file1移到file2，如果file2存在，则将会被file1的内容覆盖。如果file2不存在，则会创建file2，不管怎么样，file1都将不会再存在。</p> <ol start="2"><li>将文件移到另外一个文件,并在操作前给与提示</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> <span class="token parameter variable">-i</span> file1 file2
</code></pre></div><p>从最终结果来看，其和第一种是没有区别的。不同的是，若file2已经存在，覆盖之前Linux会通知用户确认。</p> <ol start="3"><li>将多个文件移到某个目录下</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> file1 file2 dir1
</code></pre></div><p>这个命令可以同时将file1和file2移动到目录dir1下，需要注意的是，该目录必须已经存在。</p> <ol start="4"><li>将目录移到另一个目录</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> dir1 dir2
</code></pre></div><p>该命令意思是将目录dir1的内容移动到目录dir2下，若目录dir2不存在，Linux就会创建目录dir2，最终结果是目录dir1的内容被移动到目录dir2，原有目录dir1将被删除。</p> <h3 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="header-anchor">#</a> <code>rm</code>-删除文件或目录</h3> <p>在Linux中，我们使用<code>rm</code>命令移除（删除）文件和目录，其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">rm</span> item<span class="token punctuation">..</span>.
</code></pre></div><p>其中，item是一个或多个文件或目录的名称，目录或文件之间使用空格分隔。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>Linux默认用户是明智的，并清楚自己在干什么，所以其并没有提供还原删除操作的命令。一旦使用<code>rm</code>命令，就意味着目录或文件被彻底删除了。因此，在进行该操作时，必须仔细检查。在使用<code>rm</code>命令搭配通配符删除文件或目录时，可以先使用<code>ls</code>命令测试通配符，确保不会出现误删除的情况。</p></div> <p>和前面一样，<code>rm</code>命令的一些常用选项罗列如下：</p> <table><thead><tr><th>选项</th> <th>长选项</th> <th>含义</th></tr></thead> <tbody><tr><td><code>-i</code></td> <td><code>--interactive</code></td> <td>删除一个已经存在的文件之前，提示用户确认，<br>如果没有这个选项，<code>rm</code>命令会默认删除文件，<br>同意使用y，反对使用n</td></tr> <tr><td><code>-r</code></td> <td><code>--recursive</code></td> <td>递归地删除目录，也就是说，如果删除的目录有子目录的话<br>，也要将其删除。<strong>如果要删除一个目录，必须指定该选项</strong></td></tr> <tr><td><code>-f</code></td> <td><code>--force</code></td> <td>忽略不存在的文件并无需确认，该选项会覆盖<code>--iteractive</code>选项</td></tr> <tr><td><code>-v</code></td> <td><code>--verbose</code></td> <td>删除文件时显示信息性消息</td></tr></tbody></table> <h3 id="ln-创建软硬链接"><a href="#ln-创建软硬链接" class="header-anchor">#</a> <code>ln</code>-创建软硬链接</h3> <p>在Linux中，内核为每一个新创建的文件分配一个Inode(索引结点)，每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存中，从而实现文件的快速访问。</p> <p>在Linux中，<strong>链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法</strong>。我们可以使用<code>ln</code>命令创建链接， <code>ln</code>可以创建两种链接：硬链接和符号链接（也称为软链接）。</p> <ul><li><p><strong>硬链接</strong>：<em>硬链接是文件的别名</em>。从技术上讲，他们共用一个inode(inode中包含了一个文件的所有必要的信息，说inode就是文件也是没有问题的)。 由于linux下的文件是通过索引节点（Inode）来识别文件，硬链接也可以认为是一个指向文件索引节点的指针，系统并不为它重新分配inode。</p> <p>每添加一个硬链接，文件的链接数就加1, 删除一个则链接数减1。</p> <p>对于硬连接来说，其有两大限制：</p> <div class="language- extra-class"><pre><code>  1. 硬链接不能引用自身文件系统以外的文件，也就是说，链接不能引用与该链接不在同一磁盘分区的文件。
  
  2. 硬链接不能引用目录。
</code></pre></div></li></ul> <p>创建硬连接的<code>ln</code>命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ln</span> filepath linkpath
</code></pre></div><ul><li><strong>软链接</strong>： 软链接是一种特殊的文件类型，其中包含对另一个文件或目录以绝对或相对路径形式的引用，<em>可以看做是对一个文件的间接指针，相当于windows下的快捷方式。</em></li></ul> <p>创建软链接的<code>ln</code>命令格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ln</span> <span class="token parameter variable">-s</span> item linkpath
</code></pre></div><p>在这里，item既可以是文件也可以是目录，和创建硬链接的格式相比，创建软链接多了一个<code>-s</code>选项。</p> <p>软链接与硬连接的区别：</p> <div class="language- extra-class"><pre><code>1. 软链接没有任何文件系统的限制，任何用户可以创建指向文件或目录的软链接。甚至可以跨越不同机器、不同网络对文件进行链接。

2. 创建文件的软链接时，软链接会使用一个新的inode，所以软链接的inode号和文件的inode号不同(表明他们是两个不同的文件)

3. 删除软链接对原文件没有任何影响。

4. 软链接的inode里存放着指向文件的路径，删除源文件，软链接也就无法正常使用了，此时，这是一个坏链接。
</code></pre></div><h3 id="linux操作实践"><a href="#linux操作实践" class="header-anchor">#</a> Linux操作实践</h3> <p>现在，我们进行一些实际操作，为方便操作，我们将目录切换到当前账号的主目录，输入<code>cd</code>命令，切换到主目录，并在当前目录下创建<code>playground</code>目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> playground 
</code></pre></div><p>然后，我们切换工作目录到目录<code>playground</code>，在该目录下创建两个新的目录<code>dir1</code>和<code>dir2</code>。前面我们提到<code>mkdir</code>命令可以接受多个参数，允许我们同时创建多个目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> dir1 dir2
</code></pre></div><p>接下来，我们使用<code>cp</code>命令复制<code>/etc</code>目录下的<code>passwd</code>文件到当前工作目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> /etc/passwd <span class="token builtin class-name">.</span>
</code></pre></div><p>其中，<code>.</code>代表的是当前工作目录。此时，我们查看一下当前工作目录包含的文件和子目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span>
</code></pre></div><p>可以看到，当前工作目录下的详细信息一目了然。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>total <span class="token number">12</span>
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">15</span>:49 dir1
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">15</span>:49 dir2
-rw-r--r-- <span class="token number">1</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">15</span>:54 <span class="token function">passwd</span>
</code></pre></div><p>其中，目录<code>dir1</code>和<code>dir2</code>是我们创建的，而文件passwd则是我们复制产生的。让我们使用<code>-i</code>选项，重复操作复制命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/passwd <span class="token builtin class-name">.</span>
</code></pre></div><p>此时，我们将获得警告信息，根据提示，我们输入y，完成复制，覆盖当前文件。若输入其它字符，则会使<code>cp</code>命令保留原有文件，不进行复制操作。</p> <p>然后，我们使用<code>mv</code>命令修改<code>passwd</code>文件名为<code>fun</code>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> <span class="token function">passwd</span> fun
</code></pre></div><p>我们继续操作，将<code>fun</code>文件移动到目录<code>dir1</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> fun dir1
</code></pre></div><p>再将其从目录<code>dir1</code>移动到目录<code>dir2</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> dir1/fun dir2
</code></pre></div><p>接着，我们将文件重新移动到当前工作目录下</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> dir2/fun <span class="token builtin class-name">.</span>
</code></pre></div><p>我们再操作一下，将数据文件<code>fun</code>移动到<code>dir1</code>目录下</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> fun dir1
</code></pre></div><p>完成之后，我们再将<code>dir1</code>目录移动到<code>dir2</code>目录下，因为<code>dir2</code>目录已经存在，<code>mv</code>将正常移动，否则，<code>dir1</code>将重命名为<code>dir2</code>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> dir1 dir2
</code></pre></div><p>为了确认操作是否已经成功，我们使用<code>ls</code>命令查看目录<code>dir2/dir1</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> dir2/dir1
</code></pre></div><p>查看结果，我们已经操作成功了。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">4</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun
</code></pre></div><p>紧接着，我们将文件恢复原状，将数据文件<code>fun</code>重新移动回当前工作目录，即<code>playground</code>目录。</p> <p>先将<code>dir1</code>目录移动回<code>playground</code>目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mv</span> dir2/dir1 <span class="token builtin class-name">.</span>
</code></pre></div><p>再将<code>dir1</code>目录中的<code>fun</code>文件移动回<code>playground</code>目录。</p> <div class="language-bash extra-class"><pre class="language-bash"><code> <span class="token function">mv</span> dir1/fun <span class="token builtin class-name">.</span> 
</code></pre></div><p>最后，我们尝试创建一些硬链接和软链接，先来创建三个硬链接。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ln</span> fun fun-hard
<span class="token function">ln</span> fun dir1/fun-hard
<span class="token function">ln</span> fun dir2/fun-hard
</code></pre></div><p>查看当前工作目录</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">16</span>
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:12 dir1
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:12 dir2
-rw-r--r-- <span class="token number">4</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun
-rw-r--r-- <span class="token number">4</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun-hard
</code></pre></div><p>可以注意到，文件<code>fun</code>和<code>fun-hard</code>的第二个字段都是4，这表示的是文件<code>fun</code>存在的<strong>硬链接数目</strong>。由于文件的文件名是由链接创建的，因此一个文件至少有一个链接。实际上，文件<code>fun</code>和<code>fun-hard</code>是同一个文件。
对于一个文件来说，其包含两部分：包含数据内容的数据部分和包含文件名的名称部分。创建硬链接实际上是创建了文件额外的名称，不同链接指向的是同一数据。Linux系统分配了一系列的盘块给所谓的索引节点，该节点随后与文件名称部分建立联系。因此，<strong>每个硬链接都是指向包含文件内容的具体节点</strong>。</p> <p>我们可以通过在<code>ls</code>上增加<code>-i</code>选项查看文件的索引节点，若两文件索引节点相同，则表示两文件是同一文件。执行以下命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ls</span>  <span class="token parameter variable">-li</span>
</code></pre></div><p>查看结果，观察第一个字段，可以确定，文件<code>fun</code>和<code>fun-hard</code>是同一个文件。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">16</span>
<span class="token number">1048614</span> drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:12 dir1
<span class="token number">1048615</span> drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:12 dir2
<span class="token number">1048616</span> -rw-r--r-- <span class="token number">4</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun
<span class="token number">1048616</span> -rw-r--r-- <span class="token number">4</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun-hard
</code></pre></div><p>接下来，我们来创建软链接。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">ln</span> <span class="token parameter variable">-s</span> fun fun-sym
<span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token punctuation">..</span>/fun dir1/fun-sym
<span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token punctuation">..</span>/fun dir2/fun-sym
</code></pre></div><p>第一个命令，相当直接，通过在<code>ln</code>命令添加<code>-s</code>选项我们创建了软链接，至于第二、第三个命令同样也是创建软链接。我们查看一下dir1目录的文件和子目录。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">4</span>
-rw-r--r-- <span class="token number">4</span> root root <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun-hard
lrwxrwxrwx <span class="token number">1</span> root root   <span class="token number">6</span> Feb <span class="token number">25</span> <span class="token number">17</span>:35 fun-sym -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/fun
</code></pre></div><p>通过文件信息第一个字段的首字符，可以判断<code>fun-sym</code>的列表是一个链接文件，并且其指向<code>../fun</code>。相对于<code>fun-sym</code>文件来说，<code>fun</code>文件是其上级目录<code>playground</code>下的文件，因此，这个写法是正确的。<strong>同时注意到，软链接文件的长度是6，代表的是<code>../fun</code>字符串中字符的数目，而不是它所指向的文件的长度。</strong></p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>创建软链接时，可以使用绝对路径，也可以使用相对路径。因为相对路径允许包含软链接的目录被重命名或移动，而且不会破坏链接。因此更适宜使用相对路径。</p></div> <p>最后，我们来清理<code>playground</code>目录，我们先删除硬链接<code>fun-hard</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">rm</span> fun-hard
</code></pre></div><p>查看<code>playground</code>目录下的文件和目录信息</p> <div class="language-bash extra-class"><pre class="language-bash"><code>total <span class="token number">12</span>
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:35 dir1
drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Feb <span class="token number">25</span> <span class="token number">17</span>:36 dir2
-rw-r--r-- <span class="token number">3</span> root root  <span class="token number">964</span> Feb <span class="token number">25</span> <span class="token number">16</span>:03 fun
lrwxrwxrwx <span class="token number">1</span> root root    <span class="token number">3</span> Feb <span class="token number">25</span> <span class="token number">17</span>:33 fun-sym -<span class="token operator">&gt;</span> fun
</code></pre></div><p>比较上面的结果，文件<code>fun</code>的链接数由4变成了3，硬链接数减少了1。我们再删除文件<code>fun</code>,此时符号链接还存在，只是其指向的文件已经不存在了，链接被破坏。我们删除链接。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">rm</span> fun-sym
</code></pre></div><p>最后一步，我们切换到主目录，使用<code>rm</code>命令的<code>-r</code>选项删除<code>playground</code>目录以及包括子目录在内的所有内容。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-r</span> playground
</code></pre></div><p>到这里为止，我们初步了解了操作文件和目录的相关命令。</p> <h2 id="第五章-命令的使用"><a href="#第五章-命令的使用" class="header-anchor">#</a> 第五章 命令的使用</h2> <p>在上面的章节中，我们学习了多个命令。在本章节，我们将进一步了解命令，揭开命令神秘的面纱。</p> <h3 id="命令的含义"><a href="#命令的含义" class="header-anchor">#</a> 命令的含义</h3> <p>在Linux中，一条命令无外乎下面四种情况：</p> <ul><li><strong>可执行程序</strong>：可执行命令就像在<code>\usr\bin</code>目录里所看到的所有文件一样。在该程序类别中，程序可以编译成二进制文件，比如C 、C++语言编写的程序，也可以是shell、Perl、Python、Ruby等脚本语言编写的程序。</li> <li><strong>shell内置命令</strong>：bash支持许多在内部被称之为shell builtin的内置命令。例如：<code>cd</code>命令就是shell内置命令。</li> <li><strong>shell函数</strong>：shell函数是合并到环境变量中的小型shell脚本。</li> <li><strong>alias命令</strong>：我们可以在其它命令的基础之上定义自己的命令。</li></ul> <h3 id="type-显示命令的类型"><a href="#type-显示命令的类型" class="header-anchor">#</a> <code>type</code>-显示命令的类型</h3> <p><code>type</code>命令是一个shell内置命令，可根据指定的命令名显示shell将要执行的命令类型，其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">type</span> commond
</code></pre></div><p>这里的commond是想要查看的命令名。我们先来查看一下<code>type</code>命令的类型。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">type</span> <span class="token builtin class-name">type</span> 
</code></pre></div><p>可以看到，终端返回如下信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">type</span> is a shell <span class="token builtin class-name">builtin</span>
</code></pre></div><p>这表明<code>type</code>命令是一个shell内置命令。我们再查看一下<code>ls</code>命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">type</span> <span class="token function">ls</span>
</code></pre></div><p>此时，终端返回如下信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> is aliased to `ls <span class="token parameter variable">--color</span><span class="token operator">=</span>auto'
</code></pre></div><p>我们注意到，<code>ls</code>命令其实是带有<code>--color=auto</code>选项的<code>ls</code>命令的别名。</p> <h3 id="which-显示可执行程序的位置"><a href="#which-显示可执行程序的位置" class="header-anchor">#</a> <code>which</code>-显示可执行程序的位置</h3> <p>有时候，系统中可能安装一个可执行程序的多个版本，这种情况在大型服务器中尤其常见。使用<code>which</code>命令可以确定一个给定可执行文件的准确位置。</p> <p>我们查看一下<code>ls</code>命令可执行文件的准确位置。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">which</span> <span class="token function">ls</span>
</code></pre></div><p>执行命令，输出如下结果。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ls</span><span class="token operator">=</span><span class="token string">'ls --color=auto'</span>
        /bin/ls
</code></pre></div><p>可以看到，使用<code>ls</code>命令实际执行的是<code>bin</code>目录下的ls程序。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>which命令只适用于可执行程序，而不适合内置命令和命令别名（真正可执行程序的替代物），若试图在shell内置命令（例如：<code>cd</code>命令）中使用<code>which</code>命令，要么没有响应，要么返回错误信息。</p></div> <p>下面，我们来验证一下这个说法。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">which</span> <span class="token builtin class-name">cd</span>
</code></pre></div><p>此时，终端返回错误信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/usr/bin/which: no <span class="token builtin class-name">cd</span> <span class="token keyword">in</span> <span class="token punctuation">(</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/java/jdk1.8.0_181/bin:/bin:/bin:/bin:/usr/local/bin:/bin:/root/bin<span class="token punctuation">)</span>
</code></pre></div><p>在了解命令的含义后，我们学习每一类命令的使用文档。</p> <h3 id="help-获取shell内置命令的帮助文档"><a href="#help-获取shell内置命令的帮助文档" class="header-anchor">#</a> <code>help</code>-获取shell内置命令的帮助文档</h3> <p>bash为每一个shell内置命令提供了一个内置的帮助工具。其使用方式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">help</span> commond
</code></pre></div><p>我们尝试一下</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">help</span> <span class="token builtin class-name">cd</span> 
</code></pre></div><p>此时，终端输出如下信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code>	cd: <span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>-L<span class="token operator">|</span>-P<span class="token punctuation">]</span> <span class="token punctuation">[</span>dir<span class="token punctuation">]</span>
	 Change the current directory to DIR.  The default DIR is the value of the
    <span class="token environment constant">HOME</span> shell variable.
    
    The variable CDPATH defines the search path <span class="token keyword">for</span> the directory containing
    DIR.  Alternative directory names <span class="token keyword">in</span> CDPATH are separated by a colon <span class="token punctuation">(</span>:<span class="token punctuation">)</span>.
    A null directory name is the same as the current directory.  If DIR begins
    with a slash <span class="token punctuation">(</span>/<span class="token punctuation">)</span>, <span class="token keyword">then</span> CDPATH is not used.
    
    If the directory is not found, and the shell option <span class="token variable"><span class="token variable">`</span>cdable_vars' is set,
    the word is assumed to be  a variable name.  If that variable has a value,
    its value is used <span class="token keyword">for</span> DIR.
    
    Options:
        <span class="token parameter variable">-L</span>      force symbolic links to be followed
        <span class="token parameter variable">-P</span>      use the physical directory structure without following symbolic
        links
    
    The default is to follow symbolic links, as <span class="token keyword">if</span> <span class="token variable">`</span></span>-L' were specified.
    
    Exit Status:
    Returns <span class="token number">0</span> <span class="token keyword">if</span> the directory is changed<span class="token punctuation">;</span> non-zero otherwise.
</code></pre></div><p>该命令语法描述说明，<code>cd</code>命令后可能跟一个<code>-L</code>或<code>-P</code>参数，甚至可以跟参数<code>dir</code>。</p> <div class="custom-block tip"><p class="custom-block-title">命令语法描述规则</p> <p>命令语法描述中的方括号表示这是一个可选的选项，竖线符号代表的是两个互斥的选项。</p></div> <h3 id="help选项-显示可执行命令的使用信息"><a href="#help选项-显示可执行命令的使用信息" class="header-anchor">#</a> <code>help</code>选项-显示可执行命令的使用信息</h3> <p>很多可执行命令都支持<code>--help</code>选项，<code>--help</code>选项描述了命令支持的语法和选项。我们查看一下<code>mkdir</code>命令的语法和支持的选项。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> <span class="token parameter variable">--help</span> 
</code></pre></div><p>此时，终端返回如下信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Usage: <span class="token function">mkdir</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. DIRECTORY<span class="token punctuation">..</span>.
Create the DIRECTORY<span class="token punctuation">(</span>ies<span class="token punctuation">)</span>, <span class="token keyword">if</span> they <span class="token keyword">do</span> not already exist.

Mandatory arguments to long options are mandatory <span class="token keyword">for</span> short options too.
  -m, <span class="token parameter variable">--mode</span><span class="token operator">=</span>MODE   <span class="token builtin class-name">set</span> <span class="token function">file</span> mode <span class="token punctuation">(</span>as <span class="token keyword">in</span> <span class="token function">chmod</span><span class="token punctuation">)</span>, not <span class="token assign-left variable">a</span><span class="token operator">=</span>rwx - <span class="token builtin class-name">umask</span>
  -p, <span class="token parameter variable">--parents</span>     no error <span class="token keyword">if</span> existing, <span class="token function">make</span> parent directories as needed
  -v, <span class="token parameter variable">--verbose</span>     print a message <span class="token keyword">for</span> each created directory
  -Z, <span class="token parameter variable">--context</span><span class="token operator">=</span>CTX  <span class="token builtin class-name">set</span> the SELinux security context of each created
                      directory to CTX
      When COREUTILS_CHILD_DEFAULT_ACLS environment variable is set, -p/--parents
      option respects default <span class="token builtin class-name">umask</span> and ACLs, as it does <span class="token keyword">in</span> Red Hat Enterprise Linux <span class="token number">7</span> by default
            <span class="token parameter variable">--help</span>     display this <span class="token builtin class-name">help</span> and <span class="token builtin class-name">exit</span>
      <span class="token parameter variable">--version</span>  output version information and <span class="token builtin class-name">exit</span>

Report <span class="token function">mkdir</span> bugs to bug-coreutils@gnu.org
GNU coreutils home page: <span class="token operator">&lt;</span>http://www.gnu.org/software/coreutils/<span class="token operator">&gt;</span>
General <span class="token builtin class-name">help</span> using GNU software: <span class="token operator">&lt;</span>http://www.gnu.org/gethelp/<span class="token operator">&gt;</span>
For complete documentation, run: info coreutils <span class="token string">'mkdir invocation'</span>
</code></pre></div><p>一些程序不支持<code>--help</code>选项，使用该选项可能会返回一条错误信息。</p> <h3 id="man-显示程序的手册页"><a href="#man-显示程序的手册页" class="header-anchor">#</a> <code>man</code>-显示程序的手册页</h3> <p>Linux提供了详细的称为mannual或man的手册供我们查询命令，我们可以通过<code>man</code>命令阅读它。<code>man</code>命令的格式如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>man commond
</code></pre></div><p>这里的commond是需要查看的命令名称。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>手册文档在格式上会有所不同，但是通常都包括标题、命令句法的摘要、命令用途的描述、命令选项列表以及每个命令选项的描述。但是，手册文档通常不包括实例，更多地是作为参考使用，而不是教程。</p></div> <p>现在，我们尝试使用一下</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">man</span> <span class="token function">ls</span>
</code></pre></div><p>执行命令，我们将得到命令名称，命令格式、命令选项及其选项描述等重要信息。</p> <p>在大多数Linux系统中，<code>man</code>命令通过调用<code>less</code>命令来显示手册文档，所以，当显示手册文档时，可以使用熟悉的<code>less</code>命令。</p> <p><code>man</code>命令显示的手册文档不仅包括用户命令，也包括系统管理命令、程序接口、文件格式等。</p> <table><thead><tr><th>部分</th> <th>内容</th></tr></thead> <tbody><tr><td>1</td> <td>用户命令</td></tr> <tr><td>2</td> <td>内核系统调用的程序接口</td></tr> <tr><td>3</td> <td>C库函数程序接口</td></tr> <tr><td>4</td> <td>特殊文件，如设备节点和驱动程序</td></tr> <tr><td>5</td> <td>文件格式</td></tr> <tr><td>6</td> <td>游戏和娱乐</td></tr> <tr><td>7</td> <td>其他杂项</td></tr> <tr><td>8</td> <td>系统管理命令</td></tr></tbody></table> <p>有时候我们需要查看手册文档的具体部分，以查找我们所需要的信息。尤其当我们所查找的一个文件格式同时也是一个命令名的时候，就尤为重要了。若我们没有指明要查找的编号，通常会获得第一次匹配的实例。我们可以使用如下格式的<code>man</code>命令通过数字指定范围查找相关信息：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">man</span> section search_term
</code></pre></div><p>例如，我们执行如下命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">man</span> <span class="token number">5</span> <span class="token function">passwd</span>
</code></pre></div><p>该命令将会显示文件<code>/ect/passwd</code>的文件格式描述手册。</p> <h3 id="apropos-搜索合适的命令"><a href="#apropos-搜索合适的命令" class="header-anchor">#</a> <code>apropos</code>-搜索合适的命令</h3> <p>有时候，我们希望通过关键字搜索手册信息，那么我们可以用<code>apropos</code>命令，其格式如下所示：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">apropos</span> floppy
</code></pre></div><p>执行命令，显示如下信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">fdformat</span>             <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>  - Low-level formats a floppy disk
floppy               <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>  - <span class="token function">format</span> floppy disks
</code></pre></div><p>其中，第一个字段是手册页的名称，第二个字段显示的是该信息所属手册的部分信息。<strong>注意，带有<code>-k</code>选项的man命令和apropos在功能上是一致的</strong>。</p> <h3 id="whatis-显示命令的简要描述"><a href="#whatis-显示命令的简要描述" class="header-anchor">#</a> <code>whatis</code>-显示命令的简要描述</h3> <p><code>whatis</code>命令可以帮助我们快速了解匹配具体关键字的手册页名字和一行描述。其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>whatis commond
</code></pre></div><p>现在，我们可以使用<code>whatis</code>命令查看<code>ls</code>命令的描述信息。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>whatis <span class="token function">ls</span>
</code></pre></div><p>执行命令，我们得到以下信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span>  <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  - list directory contents
</code></pre></div><p>可以看到，输出简要指出了<code>ls</code>命令的作用是列出目录内容。若我们只想知道一个命令的作用，可以直接使用<code>whatis</code>命令即可。</p> <h3 id="info-显示程序的info条目"><a href="#info-显示程序的info条目" class="header-anchor">#</a> <code>info</code>-显示程序的info条目</h3> <p>GNU项目提供了info页面来代替手册文档。info页面使用了超链接，其文件是一个树形结构，分为各个单独的节点，每个节点包含一个主题。info文件包含的超链接可以实现节点间的跳转。通过前置星号可以识别超链接，将光标放在超链接上并按<code>Enter</code>即可激活它。它的格式如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>info commond
</code></pre></div><p>在上面的格式中，commond是可选的。当我们使用<code>info</code>打开info页面时，可以使用以下命令进行控制。</p> <table><thead><tr><th>命令</th> <th>功能</th></tr></thead> <tbody><tr><td>?</td> <td>显示命令帮助</td></tr> <tr><td>Page Up</td> <td>返回上一页</td></tr> <tr><td>Page Down</td> <td>翻到下一页</td></tr> <tr><td>n</td> <td>显示下一个节点</td></tr> <tr><td>p</td> <td>显示上一个节点</td></tr> <tr><td>u</td> <td>显示目前显示节点的父节点</td></tr> <tr><td>Enter</td> <td>进入光标所指的超链接</td></tr> <tr><td>q</td> <td>退出</td></tr></tbody></table> <h2 id="定义和删除别名"><a href="#定义和删除别名" class="header-anchor">#</a> 定义和删除别名</h2> <h3 id="alias-查看与自定义命令别名"><a href="#alias-查看与自定义命令别名" class="header-anchor">#</a> <code>alias</code>-查看与自定义命令别名</h3> <p>在前面的章节中，我们使用了多个命令来获取命令的信息。在本章节中，我们尝试使用<code>alias</code>命令自定义命令，
在学习自定义命令之前，我们学习一个命令行技巧：通过使用分号来分隔多条命令，使多条命令输入在一行中。其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>commond1<span class="token punctuation">;</span>commond2<span class="token punctuation">;</span>commond3<span class="token punctuation">..</span>.
</code></pre></div><p>我们尝试一下这个技巧</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr<span class="token punctuation">;</span><span class="token function">ls</span><span class="token punctuation">;</span><span class="token builtin class-name">cd</span> -
</code></pre></div><p>执行命令，该命令成功执行并返回切换之前所在的工作目录。</p> <p>现在，我们尝试将上述命令组合成一条命令，将其命名为<code>test</code>命令，为了保险起见，我们使用<code>type</code>命令测试一下<code>test</code>命令是否已经被使用了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">type</span> <span class="token builtin class-name">test</span>
</code></pre></div><p>执行命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">test</span> is a shell <span class="token builtin class-name">builtin</span>
</code></pre></div><p>可以看到，该条命令已经被占用了，因此，我们只能将组合命令定义为其它名字，比如foo</p> <div class="language-bash extra-class"><pre class="language-bash"><code> <span class="token builtin class-name">alias</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">'cd /usr;ls;cd -'</span>
</code></pre></div><p>观察这个结构，我们得出了指定命令别名的一般格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">alias</span> name <span class="token operator">=</span><span class="token string">'string'</span>
</code></pre></div><p>其中，<code>alias</code>是定义命令别名的关键字，<code>name</code>是别名的名称，后面紧接着一个等号（没有空格），等号后面是一个用单引号括起来的字符串，这个字符串代表了一个或多个命令的组合。</p> <p>当然，若我们需要查看在环境中定义的所有别名，直接执行不带参数的<code>alias</code>命令即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">alias</span> <span class="token assign-left variable">cp</span><span class="token operator">=</span><span class="token string">'cp -i'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">'cd /usr;ls;cd -'</span>
<span class="token builtin class-name">alias</span> l.<span class="token operator">=</span><span class="token string">'ls -d .* --color=auto'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">ll</span><span class="token operator">=</span><span class="token string">'ls -l --color=auto'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">ls</span><span class="token operator">=</span><span class="token string">'ls --color=auto'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">mv</span><span class="token operator">=</span><span class="token string">'mv -i'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">rm</span><span class="token operator">=</span><span class="token string">'rm -i'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">which</span><span class="token operator">=</span><span class="token string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span>
</code></pre></div><h3 id="unalias-删除命令别名"><a href="#unalias-删除命令别名" class="header-anchor">#</a> <code>unalias</code>-删除命令别名</h3> <p>若我们在定义别名之后，想要删除定义的别名，可以使用<code>unalias</code>命令进行删除操作。其格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">unalias</span> commond
</code></pre></div><h2 id="第六章-重定向"><a href="#第六章-重定向" class="header-anchor">#</a> 第六章 重定向</h2> <p>本章我们来讨论Linux最酷的功能—I/O重定向，I/O重定向是输入/输出的缩写。这个功能可以分为两部分。</p> <ul><li><strong>输入重定向</strong>：把命令行的输入重定向为从文件中获取内容</li> <li><strong>输出重定向</strong>：把命令行的输出结果重定向到文件中。</li></ul> <p>如果我们将多个命令行关联起来，将形成非常强大的命令-管道。</p> <h3 id="标准输入、输出和标准错误"><a href="#标准输入、输出和标准错误" class="header-anchor">#</a> 标准输入、输出和标准错误</h3> <p>到目前为止，我们使用过的许多程序生成了多种不同的输出，这些输出包含两种类型。</p> <ul><li>第一种类型是程序运行的结果，表示该程序生成的数据。</li> <li>第二种类型是状态和错误信息，表示程序当前的运行情况。</li></ul> <p>与Unix“一切都是文件”的思想一致，类似<code>ls</code>的程序实际上将它们的运行结果发送到一个称为<strong>标准输出</strong>的特殊文件中，它们的状态信息则发送到另一个称为<strong>标准错误</strong>的文件中。<strong>默认情况下，标准输出和标准错误都被链接到屏幕上，并且不会保存在磁盘文件中</strong>。</p> <p>另外，许多程序从一个称为<strong>标准输入</strong>的设备来得到输入。默认情况下，<strong>标准输入连接到键盘</strong>。</p> <p>I/O重定向功能可以可以改变输出内容发送的目的地，也可以改变输入内容的来源地。<strong>通常来说，输出内容显示在屏幕上，输入内容来自于键盘。</strong></p> <h3 id="i-o重定向-标准输出重定向"><a href="#i-o重定向-标准输出重定向" class="header-anchor">#</a> I/O重定向-标准输出重定向</h3> <p>I/O重定向功能可以重新定义标准输出内容发送到哪里。使用重定向操作符&quot;&gt;&quot;，后面接文件名，就可以把标准输出重定向到另一个文件中。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>output <span class="token operator">&gt;</span> <span class="token function">file</span>
</code></pre></div><p>它主要的作用用于把命令的输出内容保存到一个文件中。我们尝试执行下面一条命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt
</code></pre></div><p>这里，我们将/usr/bin的长列表信息输出到ls-output.txt文件中。检查该命令被重定向的输出内容。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> ls-output.txt
</code></pre></div><p>如果使用<code>less</code>命令查看这个文件，可以看到该文件确实包含了<code>ls</code>命令的执行结果。</p> <p>若我们将目录换成一个不存在的目录，则屏幕上会显示错误信息，却不会输出到ls-output.txt文件中。因为ls命令并不会将它运行的错误信息输出到标准输出文件中。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&gt;</span> ls-output.txt
</code></pre></div><p>此时，我们再用<code>ls</code>命令查看该文件信息，发现该文件大小为0。这是因为当我们重定向标准输出时，目的文件通常会从文件开头部分重新改写。</p> <ol><li>清空文件内容或创建空文件</li></ol> <p>若我们需要清空文件内容或创建空文件，我们可以使用如下命名</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&gt;</span> ls-output.txt
</code></pre></div><p>仅仅使用了重定向符，并在它之前不加任何命令，就可以删除一个已存在的文件内容或创建一个新文件。</p> <ol start="2"><li>重定向输出追加在已存在文件内容尾部</li></ol> <p>若我们不希望重定向输出覆盖已经存在的文件内容，则可以使用重定向符“&gt;&gt;”来实现</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;&gt;</span> ls-output.txt
</code></pre></div><p>使用这个重定向符“&gt;&gt;”将输出内容添加在文件尾部。如果这个文件不存在，则将于操作符&quot;&gt;&quot;的作用一样创建这个文件。</p> <h3 id="i-o重定向-标准错误重定向"><a href="#i-o重定向-标准错误重定向" class="header-anchor">#</a> I/O重定向-标准错误重定向</h3> <p>标准错误重定向并不能用一个专用的重定向符来实现。要实现标准错误重定向，需要使用<strong>文件描述符</strong>。一个程序可以把生成的内容发送到任意文件流中，如果把这些文件流的前三个分别对应标准输入文件、标准输出文件、标准错误文件。那么shell将在内部用文件描述符分别索引它们为0、1、2。</p> <p><strong>shell提供了使用文件描述符来重定向文件的表示法。</strong> 因此，使用下面表示法来重定向标准错误输出。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> ls-error.txt
</code></pre></div><p>查看文件ls-error.txt，可以看到该命令输出的错误信息。</p> <p><strong>注意：文件描述符2紧跟在重定向符之前</strong></p> <h3 id="标准输出、标准错误重定向输出到同一个文件"><a href="#标准输出、标准错误重定向输出到同一个文件" class="header-anchor">#</a> 标准输出、标准错误重定向输出到同一个文件</h3> <p>在许多情况下，我们需要将一个命令的所有输出放到同一个文件中。此时，我们必须同时重定向标准输出和标准错误。有两种表示法可以使用。</p> <ul><li>第一种表示法：</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&gt;</span> ls-output.txt <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><p>这是一种传统的表示法，使用这个方法，将执行两个重定向操作。手续将重定向标准输出到文件ls-output.txt文件中，然后使用2&gt;&amp;1把文件描述符2（标准错误）重定向到文件描述符1（标准输出）中。</p> <ul><li>第二种表示法：</li></ul> <p>这种表示法提供了更为简洁的方法</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&amp;&gt;</span> ls-output.txt
</code></pre></div><p>在这个例子中，注意“&amp;&gt;”标记符就把标准输出和标准错误都重定向到了文件ls-output.txt中。</p> <h3 id="位桶-抑制或隐藏不想要的输出"><a href="#位桶-抑制或隐藏不想要的输出" class="header-anchor">#</a> 位桶-抑制或隐藏不想要的输出</h3> <p>若我们在命令执行后不希望得到输出，而是将输出丢弃，则可以把输出重定向到一个称为“/dev/null”的特殊文件来实现它。这个特殊文件称为“位桶”。</p> <div class="custom-block tip"><p class="custom-block-title">位桶</p> <p>这个设备接受输入，但是不对输入进行任何处理。</p></div> <p>以下命令用来抑制或隐藏一个文件的错误信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null
</code></pre></div><h3 id="cat-合并、查看、创建文件以及重定向"><a href="#cat-合并、查看、创建文件以及重定向" class="header-anchor">#</a> <code>cat</code>-合并、查看、创建文件以及重定向</h3> <ol><li><code>cat</code>-读取或合并文件</li></ol> <p>对于<code>cat</code>命令来说，不同参数，产生的结果并不一样。</p> <ol start="2"><li><code>cat</code>命令读取文件</li></ol> <p><code>cat</code>命令读取一个或多个文件，并把它们复制到标准输出文件中，格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">cat</span> <span class="token punctuation">[</span>file<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p><strong>我们可以使用它显示文件而不需要分页，</strong> 通过以下命令，我们可以查看文件ls-output.txt</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">cat</span> ls-output.txt
</code></pre></div><ol start="3"><li><code>cat</code>命令合并多个文件</li></ol> <p>由于<code>cat</code>可以接受多个文件作为参数，所以它可以用来将文件合并在一起。</p> <p>例如，我们需要将多个movie.mpeg.01、movie.mpeg.02......合并为一个文件movie.mpeg。</p> <p>则我们可以使用如下命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">cat</span> movie.mpeg.* <span class="token operator">&gt;</span> movie.mpeg
</code></pre></div><p>通过这个命令，我们可以将多个文件合并为一个文件movie.mpeg。</p> <ol start="4"><li><code>cat</code>命令获取键盘输入</li></ol> <p>当然，我们可以使用不带参数的<code>cat</code>命令，从标准输入中读取内容。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">cat</span>
</code></pre></div><p>由于标准输入在默认情况下是连接到键盘，所以它实际上将等待着从键盘输入内容。下一步，我们可以使用组合键<code>ctrl D</code>，告知<code>cat</code>命令已经达到了标准输入的文件尾。</p> <p>在缺少文件名参数的情况下，<code>cat</code>命令将把标准输入内容复制到标准输出文件，所以我们会看到文本行重复显示。</p> <ol start="5"><li><code>cat</code>命令创建新文件</li></ol> <p>若我们希望将键盘输入的信息输出重定向到文件中，则可以在<code>cat</code>命令后输入想要放到文件中的内容。当文本内容输入结束时，则按组合键<code>ctrl D</code>结束。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">cat</span> <span class="token operator">&gt;</span> lady_dog.txt
the document <span class="token keyword">for</span> lady_dog.txt
</code></pre></div><ol start="6"><li><code>cat</code>命令重定向输入源</li></ol> <p>现在，我们知道<code>cat</code>命令除了接受文件名参数之外，还可以重定向标准输入源，其格式如下</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">cat</span> <span class="token operator">&lt;</span> lady_dog.txt
</code></pre></div><p>使用重定向符&quot;&lt;&quot;，我们将把标准输入的源从键盘变为文件lady_dog.txt。可以看到这个命令结果和只传递单个文件参数名的结果一样，这种方式并不常用。</p> <h3 id="管道操作符-过滤器"><a href="#管道操作符-过滤器" class="header-anchor">#</a> <code>|</code>-管道操作符 &amp;&amp; 过滤器</h3> <p>命令从标准输入到读取数据，并将数据发送到标准输出的能力，是使用了名为管道的shell特性。<strong>使用管道操作符&quot;|&quot;(竖线)可以把一个命令的标准输出传送到另一个命令的标准输入中。</strong> 其命令格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>commond1 <span class="token operator">|</span> commond2
</code></pre></div><p>在前面提到的命令中，<code>less</code>命令可以接受标准输入。通过<code>less</code>命令可以分页显示任意命令的输入，并将它的结果发送到标准输出。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token punctuation">\</span>usr<span class="token punctuation">\</span>bin <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><p>管道功能常常用来对数据执行复杂的操作。<strong>可以将多个命令合并在一起构成一个管道，这种方式中用到的命令通常称为过滤器(filter)。</strong> 过滤器接受输入，按照某种方式对输入进行改变，然后再输出。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><p>该命令可以把/bin和/usr/bin目录下的所有可执行文件合成一个列表，并按照顺序排列。</p> <h3 id="uniq-报告或忽略文件中重复的行"><a href="#uniq-报告或忽略文件中重复的行" class="header-anchor">#</a> <code>uniq</code>-报告或忽略文件中重复的行</h3> <p><code>uniq</code>命令经常和<code>sort</code>命令结合使用。<strong><code>uniq</code>命令可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的的数据列表。默认情况下，该命令删除列表中的所有重复行。</strong> 因此，在管道中添加<code>uniq</code>命令，可以确定所有的列表都没有重复行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><p>若我们想要查看重复行的列表，可以在<code>uniq</code>命令后面添加<code>-d</code>选项。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-d</span> <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><h3 id="wc-打印行数、字数和字节数"><a href="#wc-打印行数、字数和字节数" class="header-anchor">#</a> <code>wc</code>-打印行数、字数和字节数</h3> <p>在Linux中，我们可以使用<code>wc</code>命令用来显示文件中包含的行数、字数和字节数。现在，我们查看文件ls-output.txt的行数、字数、字节数信息。</p> <ol><li>获取文件的行数、字数、字节数</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">wc</span> ls-output.txt
</code></pre></div><p>执行这个命令，可以得到以下信息</p> <div class="language-bash extra-class"><pre class="language-bash"><code> <span class="token number">1</span>  <span class="token number">9</span> <span class="token number">54</span> ls-output.txt
</code></pre></div><p>这三个数据分别代表行数、字数和字节数。</p> <ol start="2"><li>获取标准输入输出行数、字数、字节数</li></ol> <p><strong>和前面的命令一样，若我们在执行命令时没有输入输出命令行参数，则它将接受标准输入内容。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">wc</span>
</code></pre></div><ol start="3"><li>单独获取文件的行数</li></ol> <p>若我们只想获取文件的行数，则只需要带一个<code>-l</code>参数即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
</code></pre></div><p>执行命令，输出行数数据</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">763</span>
</code></pre></div><p><code>wc</code>命令常用的参数选项</p> <table><thead><tr><th style="text-align:center;">选项</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">-c</td> <td style="text-align:center;">统计字节数</td></tr> <tr><td style="text-align:center;">-l</td> <td style="text-align:center;">统计行数</td></tr> <tr><td style="text-align:center;">-m</td> <td style="text-align:center;">统计字符数，这个标志不能与 -c 标志一起使用。</td></tr> <tr><td style="text-align:center;">-w</td> <td style="text-align:center;">统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串。</td></tr> <tr><td style="text-align:center;">-help</td> <td style="text-align:center;">显示帮助信息</td></tr></tbody></table> <h3 id="grep-打印文本中的匹配行"><a href="#grep-打印文本中的匹配行" class="header-anchor">#</a> <code>grep</code>-打印文本中的匹配行</h3> <p>grep是一个功能强大的程序，它用来在文件中查找匹配文本，其方式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">grep</span> pattern <span class="token punctuation">[</span>file<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p>当<code>grep</code>命令在文件中遇到“模式”的时候，将打印出包含该模式的行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
</code></pre></div><p>通过上面这条命令，我们可以从列出的程序中搜索出文件名中包含zip的所有文件，该搜索将获得系统中与文件压缩相关的程序。</p> <div class="custom-block tip"><p class="custom-block-title">grep</p> <p>grep存在一对方便的选项，<code>-i</code>，该选项使得grep在搜索时忽略大小写，默认情况下，搜索是区分大小写的；<code>-v</code>，该选项只输出和模式不匹配的行。</p></div> <h3 id="head-tail-打印文件的开头部分-结尾部分"><a href="#head-tail-打印文件的开头部分-结尾部分" class="header-anchor">#</a> <code>head/tail</code>-打印文件的开头部分/结尾部分</h3> <p>有些时候，我们不需要命令输出所有的内容，可能只是需要开头几行或最后几行。<strong>默认情况下，<code>head</code>命令将输出文件的前10行，<code>tail</code>命令输出文件的后10行。可以用<code>-n</code>选项指定输出的行数。</strong></p> <ol><li><code>head/tail</code>命令基本用法</li></ol> <p>首先，我们输出文件内容的前5行</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">5</span> ls-output.txt
</code></pre></div><p>输出如下结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>total 60M
-rwxr-xr-x <span class="token number">1</span> root root     41K Oct <span class="token number">31</span>  <span class="token number">2018</span> <span class="token punctuation">[</span>
-rwxr-xr-x <span class="token number">1</span> root root     29K Oct <span class="token number">30</span>  <span class="token number">2018</span> addr2line
-rwxr-xr-x <span class="token number">1</span> root root      <span class="token number">29</span> Oct <span class="token number">31</span>  <span class="token number">2018</span> <span class="token builtin class-name">alias</span>
lrwxrwxrwx <span class="token number">1</span> root root       <span class="token number">6</span> Jan <span class="token number">29</span> 04:54 <span class="token function">apropos</span> -<span class="token operator">&gt;</span> whatis
</code></pre></div><p>其次，我们输出文件内容的后5行</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">5</span> ls-output.txt
</code></pre></div><p>输出如下结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-rwxr-xr-x <span class="token number">1</span> root root    <span class="token number">6</span>.0K Apr <span class="token number">11</span>  <span class="token number">2018</span> zgrep
-rwxr-xr-x <span class="token number">1</span> root root    <span class="token number">2</span>.0K Apr <span class="token number">11</span>  <span class="token number">2018</span> zless
-rwxr-xr-x <span class="token number">1</span> root root    <span class="token number">2</span>.8K Apr <span class="token number">11</span>  <span class="token number">2018</span> zmore
-rwxr-xr-x <span class="token number">1</span> root root    <span class="token number">5</span>.3K Apr <span class="token number">11</span>  <span class="token number">2018</span> znew
lrwxrwxrwx <span class="token number">1</span> root root       <span class="token number">6</span> Jan <span class="token number">29</span> 04:52 zsoelim -<span class="token operator">&gt;</span> soelim
</code></pre></div><p>当然，我们也可将这两个命令用在管道中</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">5</span>
</code></pre></div><p>输出如下结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>zgrep
zless
zmore
znew
zsoelim
</code></pre></div><ol start="2"><li><code>tail</code>命令实时查看文件</li></ol> <p>值得注意的是，tail有一个选项<code>-f</code>可以实时查看文件，其命令格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">tail</span> <span class="token parameter variable">-f</span> fileName
</code></pre></div><p>它会把文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要更新就可以看到最新的文件内容。当我们按<code>ctrl+C</code>时才会停止刷新。</p> <h3 id="tee-从标准输入读取并输出到标准输出和文件"><a href="#tee-从标准输入读取并输出到标准输出和文件" class="header-anchor">#</a> <code>tee</code>-从标准输入读取并输出到标准输出和文件</h3> <p>为了和我们的管道隐喻保持一致，Linux提供了一个称为<code>tee</code>的命令，就好像安装了一个“T”在管道上。<code>tee</code>程序读取标准输入，再把读到的内容复制到标准输出（允许数据可以继续传递到管道中）和一个或更多文件中去。</p> <p><strong>可用于在某个中间处理阶段来捕获一个管道中的内容时，会很有用。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tee</span> ls.txt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
</code></pre></div><p>输出结果如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>gpg-zip
gunzip
<span class="token function">gzip</span>
</code></pre></div><p>通过上面这个命令，我们使用<code>tee</code>命令获取了整个目录列表并输出到文件ls.txt中。</p> <h2 id="第七章-透过shell看世界"><a href="#第七章-透过shell看世界" class="header-anchor">#</a> 第七章 透过Shell看世界</h2> <p>在本章中，我们学习一个重要的命令<code>echo</code>，这个命令用来显示一行文本。</p> <p>现在，我们来看看<code>echo</code>命令，<code>echo</code>命令是shell的一个内置命令，它执行的任务非常简单，即把文本参数内容打印到标准输出。</p> <p>我们执行以下命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> this is a <span class="token builtin class-name">test</span>
</code></pre></div><p>结果输出上面输入的字符串。</p> <p>现在，我们执行命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> *
</code></pre></div><p>这时，我们看到命令执行的结果不是<code>*</code>，这是因为shell在执行<code>echo</code>命令前会把<code>*</code>字符扩展成其它内容。<strong>在按下Enter键的时候，shell会在执行命令前自动扩展命令行中所有符合条件的字符，因此，我们无法看到程序打印输出<code>*</code>字符，而是输出以下内容。</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>anaconda-ks.cfg lady_dog.txt ls-error.txt ls-output.txt ls.txt original-ks.cfg
</code></pre></div><p>对于Linux来说，Linux存在多种扩展。</p> <h3 id="路径名扩展"><a href="#路径名扩展" class="header-anchor">#</a> 路径名扩展</h3> <p>通过使用通配符来实现扩展的机制称为<strong>路径名扩展</strong>。我们来看下面这个命令，这个命令用于查看除主目录之外的目录。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> /usr/*/share
</code></pre></div><p>结果输出如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>/usr/local/share
</code></pre></div><h3 id="波浪线扩展"><a href="#波浪线扩展" class="header-anchor">#</a> 波浪线扩展</h3> <p>我们回顾前面对<code>cd</code>命令的介绍，你会发现波浪线（~）具有特殊的含义。<strong>如果把它（~）用在一个单词的开头，那么它将被扩展为指定用户的主目录；如果没有指定用户名，则扩展为当前用户的主目录。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> ~
</code></pre></div><p>由于没有指定用户，而且当前时root账户，则打印出root账户的主目录/root</p> <div class="language-bash extra-class"><pre class="language-bash"><code>/root
</code></pre></div><p>若存在用户foo这个账号，则可以执行下面这个命令获得foo账号的主目录</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> ~foo
</code></pre></div><p>执行结果为/home/foo。</p> <h3 id="算术扩展"><a href="#算术扩展" class="header-anchor">#</a> 算术扩展</h3> <p>除了上面两种扩展外，shell还支持通过扩展来运行算术运算符，这允许我们将shell当作计算器来使用。</p> <p>算术扩展使用如下格式</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token variable"><span class="token variable">$((</span>expression<span class="token variable">))</span></span>
</code></pre></div><p>其中，expression代表的是指包含数值和算术运算符的算术表达式，并且算术扩展只支持整数，没有小数。因此，若我们需要执行2+2，则命令可以如下这样写。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span>
</code></pre></div><p>不出所料，输出运算结果<code>4</code>。</p> <p>下面，我们罗列出echo支持的运算符种类。</p> <table><thead><tr><th style="text-align:center;">运算符</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">+</td> <td style="text-align:center;">算术加</td></tr> <tr><td style="text-align:center;">-</td> <td style="text-align:center;">算术减</td></tr> <tr><td style="text-align:center;">*</td> <td style="text-align:center;">算术乘</td></tr> <tr><td style="text-align:center;">/</td> <td style="text-align:center;">除，由于只支持整数，所以结果也只会是整数</td></tr> <tr><td style="text-align:center;">%</td> <td style="text-align:center;">取余，即取余数</td></tr> <tr><td style="text-align:center;">**</td> <td style="text-align:center;">取幂</td></tr></tbody></table> <p>现在，我们看看5/2的结果</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token builtin class-name">echo</span> Five divided by two equals <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span><span class="token variable">))</span></span>
</code></pre></div><p>执行命令，结果输出<code>2</code>。</p> <h3 id="花括号扩展"><a href="#花括号扩展" class="header-anchor">#</a> 花括号扩展</h3> <p>在shell中，存在一种特殊的扩展，通过<strong>花括号扩展</strong>，我们可以创建多种文本字符串。例如下面这个例子</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> Front-<span class="token punctuation">{</span>A,B,C<span class="token punctuation">}</span>-Back
</code></pre></div><p>通过这个例子，我们可以输出三个字符串，Front-A-Back、Front-B-Back和Front-C-Back。</p> <p>用于花括号扩展的模式信息可以包含一个称为前导字符的开头部分和一个称为附言的结尾部分。当然，花括号表达式除了可以包含一系列逗号分隔的字符串外，也可以包含一系列整数或单个字符，但不能包含空白。</p> <ol><li>生成一系列整数</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> Number_<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">}</span>
</code></pre></div><p>输出结果如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre></div><ol start="2"><li>生成一系列逆序排列的字母</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>Z<span class="token punctuation">..</span>A<span class="token punctuation">}</span>
</code></pre></div><p>输出结果如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
</code></pre></div><ol start="3"><li>批量生成多个目录</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">mkdir</span> <span class="token punctuation">{</span><span class="token number">2009</span><span class="token punctuation">..</span><span class="token number">2011</span><span class="token punctuation">}</span>-0<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">9</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token number">2009</span><span class="token punctuation">..</span><span class="token number">2011</span><span class="token punctuation">}</span>-<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">..</span><span class="token number">12</span><span class="token punctuation">}</span>
</code></pre></div><p>若没有错误，将如愿批量生成类似2009-01的多个目录。</p> <h3 id="参数扩展"><a href="#参数扩展" class="header-anchor">#</a> 参数扩展</h3> <p>在Linux中，<strong>参数扩展</strong>用在shell脚本中比直接用在命令行中更有用。例如：在Linux中，使用变量USER表示用户。为了显示变量USER的值，我们使用<code>echo</code>命令。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token environment constant">$USER</span>
</code></pre></div><p>执行命令，输出用户名<code>root</code>。</p> <p>当然，USER变量只是众多可用变量中的一个，若要查看可用变量列表，则执行命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">printenv</span> <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><p>输出的部分结果如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>xterm-256color
<span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token number">1000</span>
<span class="token assign-left variable">WSLENV</span><span class="token operator">=</span>
<span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span>root
<span class="token assign-left variable">NAME</span><span class="token operator">=</span>LAPTOP-2ESIRNKO
</code></pre></div><p>对于其它扩展来说，若是输入了错误的模式，则不会发生扩展，而对于参数扩展则不同，若发生错误，则仍然会扩展，只是扩展的结果是一个空字符串。</p> <h3 id="命令替换"><a href="#命令替换" class="header-anchor">#</a> 命令替换</h3> <p>所谓的命令替换指的是，将一个命令的输出作为一个扩展模式使用，例如下面这个例子。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span><span class="token variable">)</span></span>
</code></pre></div><p>整个命令将列出<code>ls</code>命令执行的结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>anaconda-ks.cfg lady_dog.txt ls-error.txt ls-output.txt ls.txt original-ks.cfg
</code></pre></div><p>当然，我们也可以这样用</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> <span class="token builtin class-name">cd</span><span class="token variable">)</span></span>
</code></pre></div><p>这里，我们将which cd命令的运行结果作为<code>ls</code>命令的一个参数，这样我们在不知道<code>cd</code>命令完整路径的情况下就能获得<code>cd</code>命令程序对应的列表。</p> <p>当然，我们也可以用于管道，下面的例子将输出<code>file</code>命令的参数列表</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">file</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> /usr/bin/* <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span><span class="token variable">)</span></span>
</code></pre></div><p>结果我们得到了如下信息</p> <div class="language-bash extra-class"><pre class="language-bash"><code>/usr/bin/gpg-zip: POSIX shell script, ASCII text executable
/usr/bin/gunzip:  POSIX shell script, ASCII text executable
/usr/bin/gzip:    ELF <span class="token number">64</span>-bit LSB executable, x86-64, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, <span class="token keyword">for</span> GNU/Linux <span class="token number">2.6</span>.32, BuildID<span class="token punctuation">[</span>sha1<span class="token punctuation">]</span><span class="token operator">=</span>526d77ff7164870f948d8f97aaf0a888cc561b30, stripped
</code></pre></div><p>在早期的shell命令中，我们还存在另外一种命令替换格式，它用反引号(即`)代替美元符号和括号</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token variable"><span class="token variable">`</span><span class="token function">which</span> <span class="token builtin class-name">cd</span><span class="token variable">`</span></span>
</code></pre></div><h3 id="各种类型的引用"><a href="#各种类型的引用" class="header-anchor">#</a> 各种类型的引用</h3> <p>在讲引用之前，我们先来看这样一个例子</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token builtin class-name">echo</span> The total is <span class="token variable">$100</span>.00
</code></pre></div><p>在这个例子中，$1是一个未定义的变量，所以参数扩展将把$1的值替换为空字符串。shell提供了一种称为引用的机制，用来有选择性地避免不必要的扩展。</p> <p>引用可以分为双引号、单引号、转义字符三种</p> <ul><li><p><strong>双引号</strong>：如果把文本放在双引号中，那么shell使用的所有特殊字符都将失去它们的特殊含义，而被看成普通字符。当然“$” 、&quot;&quot;、“`”除外。这也就意味着单词分割、路径名扩展、波浪线扩展和花括号扩展都将失效，但是参数扩展、算术扩展和命令替换仍然有效。使用双引号能够处理文件名中包含空白的情况。</p> <p>由于参数扩展、算术扩展和命令替换在双引号内仍然有用，那么我们输入下面命令可以正常运行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token environment constant">$USER</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>&quot;</span>
</code></pre></div><p>运行结果如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>root <span class="token number">4</span>       July <span class="token number">2019</span>
Su Mo Tu We Th Fr Sa
    <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  <span class="token number">6</span>
 <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span>
<span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span>
<span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span>
<span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span>
</code></pre></div><p>默认情况下，若没有双引号，单词分割会先查找是否存在空格、制表符以及换行</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> this is a   <span class="token builtin class-name">test</span>
</code></pre></div><p>输出结果<code>this is a test</code>，但是如果使用了双引号，则会将这些符号当成参数的一部分</p> <div class="language-bash extra-class"><pre class="language-bash"><code>this is a   <span class="token builtin class-name">test</span>
</code></pre></div><p>单词分割机制会把换行符当成界定符，在命令替换时有不同的效果</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>&quot;</span>
</code></pre></div><p>输出结果为</p> <div class="language-bash extra-class"><pre class="language-bash"><code>      July <span class="token number">2019</span>
Su Mo Tu We Th Fr Sa
    <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  <span class="token number">6</span>
 <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span>
<span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span>
<span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span>
<span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span>
</code></pre></div><p>而若是执行命令<code>echo $(cal)</code>，则获得如下输出结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>July <span class="token number">2019</span> Su Mo Tu We Th Fr Sa <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span> <span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span>
</code></pre></div><p>在第一个例子中，由于加了双引号，使得命令行被识别为命令后面只跟着一个参数，这个参数包含着嵌入空格和换行字符；而在第二个例子，没有加上引号的命令替换将导致命令行被识别为命令后面跟着38个参数。</p></li> <li><p><strong>单引号</strong>：如果我们希望抑制所有的扩展，那么应该使用单引号。下面是使用单引号的情况</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token string">'$USER $((2+2)) $(cal)'</span>
</code></pre></div><p>与双引号的运行结果不同，<code>echo</code>命令将其当作普通字符串输出</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token environment constant">$USER</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>
</code></pre></div></li> <li><p><strong>转义字符</strong>：有时候我们只想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现。这里的反斜杠称为<strong>转义字符</strong> 。 <strong>转义字符经常在双引号中用来有选择性地阻止扩展。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;The balance for user <span class="token environment constant">$USER</span> is：\<span class="token variable">$100</span>.00&quot;</span>
</code></pre></div><p>得到结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>The balance <span class="token keyword">for</span> user root is：<span class="token variable">$100</span>.00
</code></pre></div><p>如果想要显示反斜杠字符，可以通过使用两个反斜杠“\”来实现。需要注意的是，单引号中的反斜杠将失去它的特殊意义，而只是被它当成一个普通字符。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token string">'The balance for user $USER is：\$100.0'</span>
</code></pre></div><p>运行该命令，可以看到“\”只是被当成一个普通字符。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>The balance <span class="token keyword">for</span> user <span class="token environment constant">$USER</span> is：<span class="token punctuation">\</span><span class="token variable">$100</span>.0
</code></pre></div></li></ul> <h2 id="第八章-高级键盘技巧"><a href="#第八章-高级键盘技巧" class="header-anchor">#</a> 第八章 高级键盘技巧</h2> <p>在本章，我们学习一些键盘快捷键，尽量减少键盘和鼠标之间的切换，提高工作效率。</p> <h3 id="光标移动快捷键"><a href="#光标移动快捷键" class="header-anchor">#</a> 光标移动快捷键</h3> <table><thead><tr><th style="text-align:center;">组合键</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">Ctrl-A</td> <td style="text-align:center;">移动光标到行首</td></tr> <tr><td style="text-align:center;">Ctrl-E</td> <td style="text-align:center;">移动光标到行尾</td></tr> <tr><td style="text-align:center;">Ctrl-F</td> <td style="text-align:center;">光标向前移动一个字符，相当于右箭头键</td></tr> <tr><td style="text-align:center;">Ctrl-B</td> <td style="text-align:center;">光标向后移动一个字符，相当于左箭头键</td></tr> <tr><td style="text-align:center;">Alt-F</td> <td style="text-align:center;">光标向前移动一个字</td></tr> <tr><td style="text-align:center;">Alt-B</td> <td style="text-align:center;">光标向后移动一个字</td></tr> <tr><td style="text-align:center;">Ctrl-L</td> <td style="text-align:center;">清屏并把光标移到左上角，clear命令与此效果相同</td></tr></tbody></table> <h3 id="修改文本快捷键"><a href="#修改文本快捷键" class="header-anchor">#</a> 修改文本快捷键</h3> <table><thead><tr><th style="text-align:center;">组合键</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">Ctrl-D</td> <td style="text-align:center;">删除光标处的字符</td></tr> <tr><td style="text-align:center;">Ctrl-T</td> <td style="text-align:center;">光标处字符和前面的字符对调</td></tr> <tr><td style="text-align:center;">Alt-T</td> <td style="text-align:center;">光标处字和前面的字对调</td></tr> <tr><td style="text-align:center;">Alt-L</td> <td style="text-align:center;">把从光标处到字尾的字符转换为小写字母</td></tr> <tr><td style="text-align:center;">Alt-U</td> <td style="text-align:center;">把从光标处到字尾的字符转换为大写字母</td></tr></tbody></table> <h3 id="剪切、粘贴文本快捷键"><a href="#剪切、粘贴文本快捷键" class="header-anchor">#</a> 剪切、粘贴文本快捷键</h3> <table><thead><tr><th style="text-align:center;">组合键</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">Ctrl-K</td> <td style="text-align:center;">剪切光标到行尾的文本</td></tr> <tr><td style="text-align:center;">Ctrl-U</td> <td style="text-align:center;">剪切光标到行首的文本</td></tr> <tr><td style="text-align:center;">Alt-D</td> <td style="text-align:center;">剪切从光标到当前词尾的文本</td></tr> <tr><td style="text-align:center;">Alt-BackSpace</td> <td style="text-align:center;">剪切从光标到词头的文本，如果光标在一个单词的开头，则剪切前一个单词</td></tr> <tr><td style="text-align:center;">Ctrl-Y</td> <td style="text-align:center;">把kill-ring缓冲区中的文本粘贴到光标位置</td></tr></tbody></table> <h3 id="tab键-自动补齐"><a href="#tab键-自动补齐" class="header-anchor">#</a> <code>Tab</code>键-自动补齐</h3> <p>shell提供了一种称为“自动补齐”的机制为用户提供输入帮助。当用户输入命令时，可以按下Tab键，</p> <ul><li><p>若符合条件的提示是唯一的，则shell会自动补齐。</p></li> <li><p>若是满足条件的提示存在多个，再按一次Tab键，shell将若列出所有可能的结果。</p></li></ul> <p>为了更好说明这个功能，我们查看一下主目录下的文件</p> <div class="language-bash extra-class"><pre class="language-bash"><code>total <span class="token number">68</span>
-rw------- <span class="token number">1</span> root root  <span class="token number">6921</span> Jan <span class="token number">29</span> 05:02 anaconda-ks.cfg
-rw-r--r-- <span class="token number">1</span> root root    <span class="token number">29</span> Jul <span class="token number">23</span> <span class="token number">22</span>:55 lady_dog.txt
-rw-r--r-- <span class="token number">1</span> root root    <span class="token number">54</span> Jul <span class="token number">23</span> <span class="token number">21</span>:40 ls-error.txt
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">41164</span> Jul <span class="token number">24</span> 09:58 ls-output.txt
-rw-r--r-- <span class="token number">1</span> root root  <span class="token number">6916</span> Jul <span class="token number">24</span> <span class="token number">10</span>:32 ls.txt
-rw------- <span class="token number">1</span> root root  <span class="token number">6577</span> Jan <span class="token number">29</span> 05:02 original-ks.cfg
</code></pre></div><p>若我们输入命令<code>ls l</code>，按下Tab键，自动补齐将不会生效，因为有多个满足以l开头的文件，我们再按一次Tab，将罗列出所有可能的结果。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>lady_dog.txt   ls-error.txt   ls-output.txt  ls.txt
</code></pre></div><p>我们继续输入，知道满足条件的结果唯一时，自动补齐将生效。</p> <p>因此，当我们输入命令时，若按Tab键后没有自动补齐，则可能的原因是满足条件的结果有多个，可以再按一下Tab键，shell将列出所有可能的结果。</p> <p>自动补齐功能最常用于路径名补齐上，除此之外，自动补齐对变量、用户名、命令和主机名也起作用，主机名的自动补齐只对\etc\hosts目录下的主机名生效。</p> <h3 id="history-搜索历史"><a href="#history-搜索历史" class="header-anchor">#</a> <code>history</code>-搜索历史</h3> <p>在Linux Bash中，会保存使用过命令的历史记录。这些命令的历史纪录列表保存在用户主目录的.bash_history文件中。这些历史记录非常有用，可以大大减少用户敲打键盘的次数，通过向上方向指示键，可以重新调用先前输入的命令。</p> <p>任何情况下，我们都可以通过如下命令查看历史记录的内容列表。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">history</span> <span class="token operator">|</span> <span class="token function">less</span>
</code></pre></div><p><strong>bash默认会保存用户最近使用过的500个命令。</strong> 其中，500是默认值。</p> <ol><li>使用<code>grep</code>命令搜索历史记录</li></ol> <p>若我们想要查询包含/usr/bin的命令，则可以结合前面的<code>grep</code>命令查询符合条件的历史记录。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> /usr/bin
</code></pre></div><p>执行命令，获得如下记录</p> <div class="language-bash extra-class"><pre class="language-bash"><code>   <span class="token number">20</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt
   <span class="token number">27</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt
   <span class="token number">40</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;&gt;</span> ls-output.txt
   <span class="token number">44</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;&gt;</span> ls-output.txt
   <span class="token number">50</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
   <span class="token number">64</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">less</span>
   <span class="token number">65</span>  <span class="token function">ls</span> /bin /usr/bin
   <span class="token number">66</span>  <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin /usr/bin
   <span class="token number">67</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">less</span>
   <span class="token number">68</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-d</span> <span class="token operator">|</span> <span class="token function">less</span>
   <span class="token number">69</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-d</span>
   <span class="token number">70</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span>
   <span class="token number">78</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
   <span class="token number">80</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
   <span class="token number">81</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token function">zip</span>
   <span class="token number">82</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-iv</span> <span class="token function">zip</span>
   <span class="token number">83</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-iv</span> <span class="token function">zip</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
   <span class="token number">84</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-iv</span> <span class="token function">zip</span> <span class="token operator">|</span> <span class="token function">head</span>
   <span class="token number">85</span>  <span class="token function">ls</span> /bin /usr/bin <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-iv</span> <span class="token function">zip</span> <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">30</span>
   <span class="token number">87</span>  <span class="token function">ls</span> <span class="token parameter variable">-lh</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt
   <span class="token number">92</span>  <span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">5</span>
   <span class="token number">94</span>  <span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tee</span> ls.txt
   <span class="token number">95</span>  <span class="token function">ls</span> /usr/bin
   <span class="token number">96</span>  <span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tee</span> ls.txt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
  <span class="token number">121</span>  <span class="token function">file</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> /usr/bin/* <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span><span class="token variable">)</span></span>
  <span class="token number">204</span>  <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> /usr/bin
</code></pre></div><ol start="2"><li>执行特定行数的历史命令</li></ol> <p>这些记录最开始的数字代表了这个命令行在历史记录列表中所处的行号，我们可以通过使用名为历史记录扩展的扩展类型来立即使用它。例如我们想执行92行的命令，可以使用命令<code>!92</code>执行92行命令。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">!</span><span class="token number">92</span>
</code></pre></div><ol start="3"><li>使用快捷键搜索历史记录</li></ol> <p>bash支持以递增的方式搜索历史记录。也就是说，当搜索历史记录时，随着输入字符数的增加，bash也会相应地改变搜索范围。</p> <p>下面是使用快捷键搜索历史记录的详细步骤</p> <div class="language- extra-class"><pre><code>1. 首先，按下Ctrl-R键，接着输入要查找的内容，开始递增式搜索。

2. 然后，当搜索到符合条件的内容，可以按Enter键执行此命令，也可以按Ctrl-J将搜索
到的内容从历史记录列表复制到当前命令行。

3. 若需要查找下一个匹配项（向前搜索历史记录），再次按Ctrl-R键。

4. 若查询到符合的内容，执行2。

5. 若要退出搜索，则按Ctrl-G或Ctrl-C即可。
</code></pre></div><ol start="4"><li>历史记录常用快捷键</li></ol> <table><thead><tr><th style="text-align:center;">组合键</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">Ctrl-P</td> <td style="text-align:center;">移动到前一条历史记录，相当于向上箭头键</td></tr> <tr><td style="text-align:center;">Ctrl-N</td> <td style="text-align:center;">移动到后一条历史记录，相当于向下箭头键</td></tr> <tr><td style="text-align:center;">Ctrl-R</td> <td style="text-align:center;">逆向递增搜索，从当前命令行向前递增搜索</td></tr></tbody></table> <h3 id="历史记录扩展"><a href="#历史记录扩展" class="header-anchor">#</a> 历史记录扩展</h3> <p>shell提供了一种专门用来扩展历史记录项的方式-使用!字符，通过这种历史记录扩展方式，可以更方便地执行历史命令。</p> <table><thead><tr><th style="text-align:center;">序列</th> <th style="text-align:center;">行为</th></tr></thead> <tbody><tr><td style="text-align:center;">!!</td> <td style="text-align:center;">重复执行最后一个执行地命令。按向上箭头键再按Enter键也可实现相同的功能</td></tr> <tr><td style="text-align:center;">!number</td> <td style="text-align:center;">重复历史记录中第number条命令</td></tr> <tr><td style="text-align:center;">!String</td> <td style="text-align:center;">重复最近以string开头的历史记录</td></tr> <tr><td style="text-align:center;">!?String</td> <td style="text-align:center;">重复最近包含String的历史记录</td></tr></tbody></table> <h2 id="第九章-权限管理"><a href="#第九章-权限管理" class="header-anchor">#</a> 第九章 权限管理</h2> <p>传统的UNIX操作系统与那些传统的MS-DOS操作系统不同，区别在于它们不仅是多重任务处理系统，而且还是多用户系统。这意味着同一时间内可以有多个用户使用同一台计算机。不同的远程用户可以使用shell在同一时间登录同一台电脑。为了保证多用户实际可用，系统设计了一种方案来保护当前用户不受其它用户操作的影响。</p> <p>因此，本章将介绍系统安全的基础知识以及相关命令的使用。</p> <h3 id="所有者、组成员和其他所有用户"><a href="#所有者、组成员和其他所有用户" class="header-anchor">#</a> 所有者、组成员和其他所有用户</h3> <p>为了讲述所有者、组成员和其他所有用户这三个概念，需要了解一下<strong>UNIX安全模型</strong>。</p> <p>在一个UNIX安全模型中，一个用户可以拥有文件和目录。</p> <ul><li>当一个用户拥有一个文件和目录时，它将对该文件或目录的访问权限拥有控制权。</li> <li>对于一个用户来说，用户又归属于一个群组，该群组由一个或多个用户组成，组中用户对文件和目录的访问权限由拥有者授予。</li> <li>除了可以授予群组访问权限之外，文件所有者也可以授予所有用户一些访问权限。</li></ul> <h3 id="id-显示用户身份标识"><a href="#id-显示用户身份标识" class="header-anchor">#</a> <code>id</code>-显示用户身份标识</h3> <p>在UNIX系统中，可以使用<code>id</code>命令获得用户身份标识的相关信息。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">id</span>
</code></pre></div><p>执行命令，可以获得如下用户信息</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>shenzx<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>shenzx<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>shenzx<span class="token punctuation">)</span>
</code></pre></div><p>查看<code>id</code>命令的输出结果。可以知道，在创建账户的时候</p> <ul><li>用户将被分配一个称为用户ID或者uid的号码，而且用户ID与用户名一一映射。</li> <li>于此同时，用户会被分配一个有效的组ID或者gid，而且该用户也可以属于其它的群组。</li></ul> <p>类似于Linux中的很多情况，这些信息来自于一系列的文本文件。</p> <ul><li>用户账号定义在文件\etc\passwd中，对于每一个账号，文件\etc\passwd定义了对应用户的用户名、uid、gid、账户的真实姓名、主目录以及登录shell信息。除了普通用户外，\etc\passwd和\etc\group还有定义超级用户以及起他不同种类的系统用户的账号信息。</li> <li>用户组定义在文件\etc\group文件中。</li> <li>在创建用户账号和群组时，这些文件随着\etc\shadow的变动而修改，文件中保存了用户的密码信息。</li></ul> <p>在Linux中，普通用户会被分配给和账号同名的群组，这使得权限分配更加容易。</p> <h3 id="读取、写入和执行权限"><a href="#读取、写入和执行权限" class="header-anchor">#</a> 读取、写入和执行权限</h3> <p>对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> ls-output.txt
</code></pre></div><p>查看运行结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-rw-r--r-- <span class="token number">1</span> root root <span class="token number">42955</span> Jul <span class="token number">26</span> <span class="token number">18</span>:19 ls-output.txt
</code></pre></div><p>列在输出结果中的前10个字符表示的是文件属性，其中第一个字符表示文件类型。按照文件的类型分类，可以分为以下几种文件类型。</p> <table><thead><tr><th style="text-align:center;">属性</th> <th style="text-align:left;">文件类型</th></tr></thead> <tbody><tr><td style="text-align:center;">-</td> <td style="text-align:left;">普通文件</td></tr> <tr><td style="text-align:center;">d</td> <td style="text-align:left;">目录文件</td></tr> <tr><td style="text-align:center;">l</td> <td style="text-align:left;">符号链接。<strong>对于符号链接文件来说，剩下的文件属性始终是<code>rwxrwxrwx</code></strong> ，<br>它是一个伪属性值，符号链接执行的文件的属性才是真正的文件属性</td></tr> <tr><td style="text-align:center;">c</td> <td style="text-align:left;">字符设备文件，该文件类型表示以字节流形式处理数据的设备，如终端或调制解调器</td></tr> <tr><td style="text-align:center;">b</td> <td style="text-align:left;">块设备文件，该文件类型表示以数据块方式处理数据的设备，如硬盘驱动或光盘驱动</td></tr></tbody></table> <p>文件中剩下的9个字符称为<strong>文件模式</strong>，分别代表文件所有者、文件所属群组以及其他所有用户对该文件的读取、写入和执行权限。</p> <p>分别设置r、w、x的模式属性将会对文件和目录带来不同的影响，具体影响看下表。</p> <table><thead><tr><th style="text-align:center;">属性</th> <th style="text-align:center;">文件</th> <th style="text-align:center;">目录</th></tr></thead> <tbody><tr><td style="text-align:center;">r</td> <td style="text-align:center;">允许打开和读取文件</td> <td style="text-align:center;">如果目录还设置了执行权限，则允许使用<code>ls</code>命令列出目录下的文件信息</td></tr> <tr><td style="text-align:center;">w</td> <td style="text-align:center;">可以使用编辑器修改文件内容，但需要配置r权限一起使用;如果还设置了执行权限，则目录中的文件可以被创建、删除以及重命名</td> <td style="text-align:center;">可以创建、删除目录里的文件，也可以删除当前目录</td></tr> <tr><td style="text-align:center;">x</td> <td style="text-align:center;">允许把文件当作程序一样来执行。用脚本语言写的程序必须被设置为已读，以便能够执行</td> <td style="text-align:center;">可以使用<code>cd</code>命令切换此目录为工作目录，但需配合r权限一起使用</td></tr></tbody></table> <h3 id="chmod-更改文件模式-权限"><a href="#chmod-更改文件模式-权限" class="header-anchor">#</a> <code>chmod</code>-更改文件模式（权限）</h3> <p>我们可以使用<code>chmod</code>命令来更改文件或目录的文件模式，<strong>需要注意的是只有文件所有者和超级用户才可以更改文件或目录的模式。<code>chmod</code>命令支持两种不同的改变文件模式的方法-八进制数字表示法和符号表示法。</strong></p> <p>首先是八进制表示法。</p> <ol><li>八进制表示法</li></ol> <p>八进制表示法指的是使用八进制数字来设置所期待的权限模式。因为每个八进制数对应3个二进制数，所以这种关系正好可以和用来存储文件模式的结构一一映射。</p> <table><thead><tr><th style="text-align:center;">八进制</th> <th style="text-align:center;">二进制</th> <th style="text-align:center;">文件模式</th></tr></thead> <tbody><tr><td style="text-align:center;">0</td> <td style="text-align:center;">000</td> <td style="text-align:center;">---</td></tr> <tr><td style="text-align:center;">1</td> <td style="text-align:center;">001</td> <td style="text-align:center;">--x</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">010</td> <td style="text-align:center;">-w-</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">011</td> <td style="text-align:center;">-wx</td></tr> <tr><td style="text-align:center;">4</td> <td style="text-align:center;">100</td> <td style="text-align:center;">r--</td></tr> <tr><td style="text-align:center;">5</td> <td style="text-align:center;">101</td> <td style="text-align:center;">r-x</td></tr> <tr><td style="text-align:center;">6</td> <td style="text-align:center;">110</td> <td style="text-align:center;">rw-</td></tr> <tr><td style="text-align:center;">7</td> <td style="text-align:center;">111</td> <td style="text-align:center;">rwx</td></tr></tbody></table> <p>通过使用3位八进制数字，我们可以分别设置文件所有者、组成员、其他所有用户的所有模式。</p> <p>例如，若我们想设置文件所有者具有读写权限，而取消组用户和其他所有用户的所有权限，则命令如下</p> <div class="language- extra-class"><pre class="language-text"><code>chmod 600 ls-output.txt
</code></pre></div><p>再次查看文件ls-output.txt的权限，则输入结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-rw------- <span class="token number">1</span> root root <span class="token number">42955</span> Jul <span class="token number">26</span> <span class="token number">18</span>:19 ls-output.txt
</code></pre></div><ol start="2"><li>符号表示法</li></ol> <p>除了上面的八进制表示法之外，chmod还支持符号表示法。该符号表示法分为三部分：更改会影响谁、要执行哪种操作以及设置哪种权限。可以通过字符u、g、o和a的组合来指定要影响的对象。</p> <table><thead><tr><th style="text-align:center;">符号</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">u</td> <td style="text-align:center;">user的简写，表示文件或目录的所有者</td></tr> <tr><td style="text-align:center;">g</td> <td style="text-align:center;">文件所属群组</td></tr> <tr><td style="text-align:center;">o</td> <td style="text-align:center;">others的简写，表示其他所有用户</td></tr> <tr><td style="text-align:center;">a</td> <td style="text-align:center;">all的简写，是u、g、o的三者组合</td></tr></tbody></table> <p><strong>如果没有指定字符，则表示使用all，操作符“+”表示增加一种权限，“-”表示删除一种权限，“=”表示只有指定的权限可以用，其他所有权限都被删除。权限由字符“r”、“w”、“x”来指定。</strong></p> <p>下面是一些符号表示法示例</p> <table><thead><tr><th style="text-align:center;">符号</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">+x</td> <td style="text-align:center;">为文件所有者、组成员和其他所有用户添加可执行权限</td></tr> <tr><td style="text-align:center;">o-rw</td> <td style="text-align:center;">除了文件所有者和所属群组外，删除其他所有用户的读写权限</td></tr> <tr><td style="text-align:center;">u+x,go=rw</td> <td style="text-align:center;">为文件所有者添加可执行权限，同时设置所属群组和其他所有用户具有读和可写权限，需用都好分隔</td></tr></tbody></table> <p>相对于八进制表示法，符号表示法的优点在于允许设置单个属性，而不影响其他的任何属性。</p> <h3 id="su-以其他用户和组id的身份来运行shell"><a href="#su-以其他用户和组id的身份来运行shell" class="header-anchor">#</a> <code>su</code>-以其他用户和组ID的身份来运行shell</h3> <p><code>su</code>命令用来以另一个用户的身份来启动shell，该命令的一般形式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">su</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> <span class="token punctuation">[</span>user<span class="token punctuation">]</span>
</code></pre></div><p>如果包含“-l”选项，那么将得到的shell会话界面将是用于指定用户的登录shell界面。这意味着，该指定用户的运行环境将被加载，而且其工作目录也将更改为该指定用户的主目录。如果没有指定用户，那么默认假定为超级用户。</p> <ol><li>使用超级用户的身份来启动shell</li></ol> <p>需要注意的是，<code>-l</code>可以缩写为-。因此，我们可以使用以下的命令来以超级用户的身份启动shell。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">su</span> -
</code></pre></div><p>在输入<code>su</code>命令后，系统会提示输入该超级用户的密码。如果密码输入正确，那么将出现新的shell提示符，该提示符表示该shell将拥有超级用户的特权，而且当前的工作目录也是用于超级用户的主目录。一旦进入这个新的shell环境，我们就可以以超级用户的身份执行命令了。</p> <p><strong>在使用结束时，输入<code>exit</code>，将返回之前的shell环境。</strong></p> <ol start="2"><li>使用<code>su</code>命令执行单个命令</li></ol> <p>我们也可以使用su命令执行单个命令，而不是开启一个新的交互命令界面，操作如下：</p> <div class="language- extra-class"><pre class="language-text"><code>su -c 'commond'
</code></pre></div><p><strong>使用这种格式，单个命令行将被传递到一个新的shell环境下进行执行。这里需要用单引号把命令行引起来。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">'ls -l /root/*'</span>
</code></pre></div><p>运行结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-rw------- <span class="token number">1</span> root root <span class="token number">6921</span> Jan <span class="token number">29</span> 05:02 /root/anaconda-ks.cfg
-rw------- <span class="token number">1</span> root root    <span class="token number">0</span> Jul <span class="token number">26</span> <span class="token number">22</span>:36 /root/ls-output.txt
-rw------- <span class="token number">1</span> root root <span class="token number">6577</span> Jan <span class="token number">29</span> 05:02 /root/original-ks.cfg
</code></pre></div><p><code>sudo</code>-以另一个用户的身份执行命令</p> <p><code>sudo</code>命令在许多方面类似于<code>su</code>命令</p> <h3 id="su和sudo命令的几点区别"><a href="#su和sudo命令的几点区别" class="header-anchor">#</a> <code>su</code>和<code>sudo</code>命令的几点区别</h3> <ol><li>对于<code>sudo</code>命令来说，管理者可以通过配置<code>sudo</code>命令，使系统以一种可控的方式，允许一个普通用户以一个不同的身份执行命令。在特定情况下，用户可能被限制只能执行一条或几条特定的命令，而对其他命令没有执行权限。</li> <li>使用<code>sudo</code>命令并不需要输入超级用户的密码。使用<code>sudo</code>命令时，用户只需要输入自己的密码来进行认证。一旦认证被通过，指定的命令就会被执行。</li> <li><code>sudo</code>命令并不需要启动一个新的shell环境，也不需要加载另一个用户的运行环境。</li></ol> <h3 id="chown-更改文件所有者和所属群组"><a href="#chown-更改文件所有者和所属群组" class="header-anchor">#</a> <code>chown</code>-更改文件所有者和所属群组</h3> <p><code>chown</code>命令用来更改文件或者目录的所有者和所属群组。使用这个命令需要超级用户的权限。<code>chown</code>命令的语法格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">chown</span> <span class="token punctuation">[</span>owner<span class="token punctuation">]</span><span class="token punctuation">[</span>:group<span class="token punctuation">]</span> file<span class="token punctuation">..</span>.
</code></pre></div><p><strong><code>chown</code> 命令更改的是文件所有者还是文件所属群组，或者对两者都更改，取决于该命令的第一个参数。</strong></p> <p>下面是<code>chown</code>命令参数示例</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">结果</th></tr></thead> <tbody><tr><td style="text-align:center;">bob</td> <td style="text-align:center;">把文件所有者从当前所有者更改为用户bob</td></tr> <tr><td style="text-align:center;">bob:users</td> <td style="text-align:center;">把文件所有者从当前所有者更改为用户bob，并将其文件所属群组更改为users组</td></tr> <tr><td style="text-align:center;">:admins</td> <td style="text-align:center;">把文件所属群组更改为admins组，文件所有者不变</td></tr> <tr><td style="text-align:center;">bob:</td> <td style="text-align:center;">把文件所有者从当前所有者更改为用户bob，并把文件所属群组更改为用户bob登录系统时所属的组</td></tr></tbody></table> <h3 id="passwd-修改用户密码"><a href="#passwd-修改用户密码" class="header-anchor">#</a> <code>passwd</code>-修改用户密码</h3> <p>有时候，我们需要修改账号密码，这时候就需要使用命令<code>passwd</code>命令了。<strong>一般情况下，我们只能修改当前用户的密码，当然，若是超级用户，则可以修改其他用户的账号密码。</strong> 修改密码的一般格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">passwd</span> <span class="token punctuation">[</span>user<span class="token punctuation">]</span>
</code></pre></div><ol><li>修改用户自己的密码</li></ol> <p>若是修改自己的密码，则只需要输入输入<code>passwd</code>命令即可，接下来，shell会提示用户输入旧密码和新密码。</p> <ol start="2"><li>修改其他用户的密码</li></ol> <p>如果我们拥有超级用户的权限，那么我们就可以修改其他用户的密码。只需要指定一个user参数即可。对于超级用户来说，我们还可以使用该命令的其他选项设置账户锁定、密码失效等功能。</p> <p><code>passwd</code>命令会尝试用户使用“强”密码，也就是说它会拒绝接受太简单、太短、与之前相似的密码或者容易猜到的密码。为了安全起见，最好设置复杂一点的密码。</p> <h2 id="第十章-进程信息查看与进程控制"><a href="#第十章-进程信息查看与进程控制" class="header-anchor">#</a> 第十章 进程信息查看与进程控制</h2> <p>在学习进程信息查看与进程控制命令之前，我们先来了解一下进程的工作方式。</p> <h3 id="进程的工作方式"><a href="#进程的工作方式" class="header-anchor">#</a> 进程的工作方式</h3> <p>系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为init的程序。init程序将依次运行一系列称为脚本初始化的shell脚本（这些脚本在/etc目录下），这些脚本将会启动所有的系统服务。其中的很多服务都是通过守护程序来实现的。而后台程序只是呆在后台做自己的事情。因此，即使没有用户登录，系统也会忙于执行一些例行程序。</p> <p>内存会保存每个进程的信息以便确保任务有序进行。比如，每个进程将被分配一个称为进程ID的号码。进程ID是按照递增的顺序来分配的，init进程的PID始终为1.内核也记录分配给每个进程的内存信息以及用来恢复运行的进程就绪信息。</p> <p>有时候计算机运行速度会变慢，或者应用程序会停止响应。本章将介绍命令行中可以用来查看程序当前运行情况以及终止运行异常的进程的一些工具。</p> <h3 id="ps-显示当前所有进程的运行情况"><a href="#ps-显示当前所有进程的运行情况" class="header-anchor">#</a> <code>ps</code>-显示当前所有进程的运行情况</h3> <p>用来查看进程信息的命令中，使用最普遍的就是<code>ps</code>命令。</p> <ol><li>输出和当前终端会话相关的进程信息</li></ol> <p><code>ps</code>命令有很多选项，其中最简单的使用格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ps</span>
</code></pre></div><p>执行命令，输出结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code>  PID TTY          TIME CMD
    <span class="token number">3</span> tty1     00:00:00 init
    <span class="token number">4</span> tty1     00:00:00 <span class="token function">bash</span>
   <span class="token number">26</span> tty1     00:00:00 <span class="token function">ps</span>
</code></pre></div><p>默认情况下，<code>ps</code>命令输出的信息不是很多，只是输出和当前终端会话相关的进程信息。其中</p> <ul><li><strong>TTY</strong>代表了进程的控制终端，</li> <li><strong>TIME</strong>字段表示了进程消耗的CPU时间总和</li></ul> <ol start="2"><li>反映系统运行情况的视图界面</li></ol> <p>我们增加一个选项x，我们将被告知所有的进程，而不需要关注它们是由哪个终端所控制的。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ps</span> x
</code></pre></div><p>得到输出结果，在输出结果中，TTY列中的出现的“?”表示没有终端。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>  PID TTY      STAT   TIME COMMAND
    <span class="token number">1</span> ?        Ss     <span class="token number">0</span>:00 /init
    <span class="token number">3</span> tty1     Ss     <span class="token number">0</span>:00 /init
    <span class="token number">4</span> tty1     S      <span class="token number">0</span>:00 <span class="token parameter variable">-bash</span>
   <span class="token number">27</span> tty2     Ss     <span class="token number">0</span>:00 /init
   <span class="token number">28</span> tty2     S      <span class="token number">0</span>:00 <span class="token parameter variable">-bash</span>
   <span class="token number">41</span> tty2     S      <span class="token number">0</span>:00 <span class="token function">su</span> shenzx
   <span class="token number">57</span> tty1     R      <span class="token number">0</span>:00 <span class="token function">ps</span> x
</code></pre></div><p>同时在输出结果中还添加了一个名为<strong>STAT</strong>的新列。SRTAT是state的缩写，显示的是进程的当前状态。对照下表，可以看到进程的状态由好几个。</p> <table><thead><tr><th style="text-align:center;">状态</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">R</td> <td style="text-align:center;">运行状态，进程正在运行或准备运行</td></tr> <tr><td style="text-align:center;">S</td> <td style="text-align:center;">睡眠状态，进程不在运行。而是等待某事件发生</td></tr> <tr><td style="text-align:center;">D</td> <td style="text-align:center;">不可终端的睡眠状态，进程在等待I/O操作，如硬盘驱动</td></tr> <tr><td style="text-align:center;">T</td> <td style="text-align:center;">暂停状态，进程被指示暂停，后续还可继续运行</td></tr> <tr><td style="text-align:center;">Z</td> <td style="text-align:center;">无效或僵尸状态，子进程被终止，但还没有被其父进程彻底释放掉</td></tr> <tr><td style="text-align:center;">&lt;</td> <td style="text-align:center;">高优先级进程，进程可以被赋予更多的重要性，分配更多的CPU时间</td></tr> <tr><td style="text-align:center;">N</td> <td style="text-align:center;">低优先级进程，低优先级进程只有在其他更高优先级的进程使用完之后才能获得使用处理器的时间</td></tr></tbody></table> <p>这些进程状态的后面可以带其他的字符来表示不同的特殊进程特性。</p> <ol start="3"><li>显示属于每个用户的进程信息</li></ol> <p>另外一个常用的选项组合是aux，执行命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ps</span> aux
</code></pre></div><p>输出如下的详细结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">8324</span>   <span class="token number">156</span> ?        Ss   <span class="token number">11</span>:27   <span class="token number">0</span>:00 /init
root         <span class="token number">3</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">8328</span>   <span class="token number">160</span> tty1     Ss   <span class="token number">11</span>:27   <span class="token number">0</span>:00 /init
root         <span class="token number">4</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">115664</span>  <span class="token number">2048</span> tty1     S    <span class="token number">11</span>:27   <span class="token number">0</span>:00 <span class="token parameter variable">-bash</span>
root        <span class="token number">27</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">8328</span>   <span class="token number">160</span> tty2     Ss   <span class="token number">14</span>:58   <span class="token number">0</span>:00 /init
root        <span class="token number">28</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">115664</span>  <span class="token number">2040</span> tty2     S    <span class="token number">14</span>:58   <span class="token number">0</span>:00 <span class="token parameter variable">-bash</span>
root        <span class="token number">41</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">118768</span>  <span class="token number">2188</span> tty2     S    <span class="token number">14</span>:58   <span class="token number">0</span>:00 <span class="token function">su</span> shenzx
shenzx      <span class="token number">42</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">115660</span>  <span class="token number">2060</span> tty2     S    <span class="token number">14</span>:58   <span class="token number">0</span>:00 <span class="token function">bash</span>
root        <span class="token number">58</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">119064</span>  <span class="token number">2068</span> tty1     R    <span class="token number">15</span>:20   <span class="token number">0</span>:00 <span class="token function">ps</span> aux
</code></pre></div><p>该选项组合会显示属于每个用户的进程信息，各列的含义如下</p> <table><thead><tr><th style="text-align:center;">标题</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">USER</td> <td style="text-align:center;">用户ID，表示该进程的所有者</td></tr> <tr><td style="text-align:center;">%CPU</td> <td style="text-align:center;">CPU使用百分比</td></tr> <tr><td style="text-align:center;">%MEM</td> <td style="text-align:center;">内存使用百分比</td></tr> <tr><td style="text-align:center;">VSZ</td> <td style="text-align:center;">虚拟耗用内存大小</td></tr> <tr><td style="text-align:center;">RSS</td> <td style="text-align:center;">实际使用的内存大小。进程使用的物理内存大小（以KB为单位）</td></tr> <tr><td style="text-align:center;">START</td> <td style="text-align:center;">进程开启的时间，如果数值超过24小时，那么将使用日期来表示</td></tr></tbody></table> <h3 id="top-动态查看进程信息"><a href="#top-动态查看进程信息" class="header-anchor">#</a> <code>top</code>-动态查看进程信息</h3> <p>虽然<code>ps</code>命令可以显示有关机器运行的很多情况，但是它提供的只是<code>ps</code>命令被执行时刻机器状态的一个写照。<strong>要查看机器运行情况的动态视图，可以使用<code>top</code>命令查看系统进程的运行情况。</strong></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">top</span>
</code></pre></div><p><strong><code>top</code>命令将按照进程的活动顺序，以列表的形式持续更新显示系统进程的当前信息（默认每3秒更新一次）。</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">top</span> - <span class="token number">16</span>:11:15 up  <span class="token number">4</span>:43,  <span class="token number">0</span> users,  load average: <span class="token number">0.52</span>, <span class="token number">0.58</span>, <span class="token number">0.59</span>
Tasks:   <span class="token number">8</span> total,   <span class="token number">1</span> running,   <span class="token number">7</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">4.9</span> us,  <span class="token number">3.9</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">90.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.4</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span> <span class="token number">16695540</span> total, <span class="token number">11518216</span> free,  <span class="token number">4940848</span> used,   <span class="token number">236476</span> buff/cache
KiB Swap: <span class="token number">13107196</span> total, <span class="token number">13107196</span> free,        <span class="token number">0</span> used. <span class="token number">11613836</span> avail Mem

  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8324</span>    <span class="token number">156</span>    <span class="token number">132</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.12 init
    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8328</span>    <span class="token number">160</span>    <span class="token number">120</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 init
    <span class="token number">4</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">115664</span>   <span class="token number">2048</span>   <span class="token number">1940</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.17 <span class="token function">bash</span>
   <span class="token number">27</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8328</span>    <span class="token number">160</span>    <span class="token number">120</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 init
   <span class="token number">28</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">115664</span>   <span class="token number">2040</span>   <span class="token number">1928</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.03 <span class="token function">bash</span>
   <span class="token number">41</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">118768</span>   <span class="token number">2188</span>   <span class="token number">2152</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.07 <span class="token function">su</span>
   <span class="token number">42</span> shenzx    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">115660</span>   <span class="token number">2060</span>   <span class="token number">1872</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.04 <span class="token function">bash</span>
   <span class="token number">59</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">119488</span>   <span class="token number">2220</span>   <span class="token number">1592</span> R   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.41 <span class="token function">top</span>
</code></pre></div><p>结果中顶部显示的是系统总体状态信息，这些信息包含很多有用的内容，其含义如下：</p> <ul><li>第一行中的信息</li></ul> <table><thead><tr><th style="text-align:center;">字段</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">top</td> <td style="text-align:center;">程序名</td></tr> <tr><td style="text-align:center;">16:11:15</td> <td style="text-align:center;">一天当中当前的时间</td></tr> <tr><td style="text-align:center;">up  4:43</td> <td style="text-align:center;">正常运行时间。<strong>从机器最后一次启动开始计算的时间总数</strong></td></tr> <tr><td style="text-align:center;">0 users</td> <td style="text-align:center;">显示有几个用户已登录</td></tr> <tr><td style="text-align:center;">load average</td> <td style="text-align:center;">负载均值（load average）指的是等待运行的进程数，即共享CPU资源的处于可运行状态的进程数。<br>显示的三个值分别对应不同的时间段<br>第一个对应的是前60秒的均值<br>第二个对应的是前5分钟的均值<br>最后一个对应的是前15分钟的均值<br>该值小于1.0代表机器不忙</td></tr></tbody></table> <ul><li>第二行中的信息</li></ul> <table><thead><tr><th style="text-align:center;">字段</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">Tasks:</td> <td style="text-align:center;">统计进程数及各个进程的状态信息</td></tr> <tr><td style="text-align:center;">4.9 us</td> <td style="text-align:center;">4.9%的CPU时间被用户进程占用，这里指的是内核外的进程</td></tr> <tr><td style="text-align:center;">3.9 sy</td> <td style="text-align:center;">3.9%的CPU时间被系统进程占用</td></tr> <tr><td style="text-align:center;">0.0 ni</td> <td style="text-align:center;">0.0%的CPU时间被低优先级进程占用</td></tr> <tr><td style="text-align:center;">90.8 id</td> <td style="text-align:center;">90.8%的CPU时间是空闲的</td></tr> <tr><td style="text-align:center;">0.0 wa</td> <td style="text-align:center;">0.0%的CPU时间用来等待I/O操作</td></tr></tbody></table> <ul><li>第三行中的信息</li></ul> <table><thead><tr><th style="text-align:center;">字段</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">Mem</td> <td style="text-align:center;">显示物理内存（随机存取内存）的使用情况</td></tr> <tr><td style="text-align:center;">Swap</td> <td style="text-align:center;">显示交换空间（虚拟内存）的使用情况</td></tr></tbody></table> <p><strong><code>top</code>命令可以接受键盘指令，若需要退出<code>top</code>命令，则输入<code>q</code>。若输入<code>h</code>，则显示程序的帮助界面。</strong></p> <p>一般来说，<code>top</code>命令速度优于输出监控信息的图形化应用程序，而且消耗的资源也比较少。</p> <h3 id="ctrl-c-中断进程"><a href="#ctrl-c-中断进程" class="header-anchor">#</a> <code>Ctrl-C</code>-中断进程</h3> <p>在Linux中，我们可以在终端里按下Ctrl-C组合键中断一个程序，它意味着我们委婉地请求程序结束。</p> <p>例如，我们上一节学习的动态查看进程信息的<code>top</code>命令。当我们执行<code>top</code>命令后，若不按组合键Ctrl-C，则终端的提示符不会返回。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>root@LAPTOP-2ESIRNKO ~<span class="token punctuation">]</span><span class="token comment"># top</span>
<span class="token function">top</span> - <span class="token number">10</span>:11:31 up  <span class="token number">1</span>:27,  <span class="token number">0</span> users,  load average: <span class="token number">0.52</span>, <span class="token number">0.58</span>, <span class="token number">0.59</span>
Tasks:   <span class="token number">4</span> total,   <span class="token number">1</span> running,   <span class="token number">3</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">3.3</span> us,  <span class="token number">4.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">91.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.9</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span> <span class="token number">16695540</span> total, <span class="token number">11592476</span> free,  <span class="token number">4866588</span> used,   <span class="token number">236476</span> buff/cache
KiB Swap: <span class="token number">13107196</span> total, <span class="token number">13107196</span> free,        <span class="token number">0</span> used. <span class="token number">11688096</span> avail Mem

  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8324</span>    <span class="token number">156</span>    <span class="token number">132</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 init
    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8328</span>    <span class="token number">160</span>    <span class="token number">124</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 init
    <span class="token number">4</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">115664</span>   <span class="token number">2072</span>   <span class="token number">1976</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 <span class="token function">bash</span>
   <span class="token number">20</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">119488</span>   <span class="token number">2236</span>   <span class="token number">1608</span> R   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.32 <span class="token function">top</span>

</code></pre></div><p>只有按下Ctrl-C请求程序结束后，终端提示符才会返回。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>root@LAPTOP-2ESIRNKO ~<span class="token punctuation">]</span><span class="token comment"># top</span>
<span class="token function">top</span> - <span class="token number">10</span>:13:14 up  <span class="token number">1</span>:29,  <span class="token number">0</span> users,  load average: <span class="token number">0.52</span>, <span class="token number">0.58</span>, <span class="token number">0.59</span>
Tasks:   <span class="token number">4</span> total,   <span class="token number">1</span> running,   <span class="token number">3</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">1.5</span> us,  <span class="token number">1.5</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">95.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">1.5</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span> <span class="token number">16695540</span> total, <span class="token number">11572640</span> free,  <span class="token number">4886424</span> used,   <span class="token number">236476</span> buff/cache
KiB Swap: <span class="token number">13107196</span> total, <span class="token number">13107196</span> free,        <span class="token number">0</span> used. <span class="token number">11668260</span> avail Mem

  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8324</span>    <span class="token number">156</span>    <span class="token number">132</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 init
    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8328</span>    <span class="token number">160</span>    <span class="token number">124</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 init
    <span class="token number">4</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">115664</span>   <span class="token number">2076</span>   <span class="token number">1976</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 <span class="token function">bash</span>
   <span class="token number">21</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">119488</span>   <span class="token number">2184</span>   <span class="token number">1548</span> R   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 <span class="token function">top</span>


<span class="token punctuation">[</span>root@LAPTOP-2ESIRNKO ~<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre></div><h3 id="使进程在后台运行"><a href="#使进程在后台运行" class="header-anchor">#</a> <code>&amp;</code>-使进程在后台运行</h3> <p>假设我们想要shell提示符返回，又不终止程序，则可以通过让该程序在后台运行来实现。我们可以把终端想象成又一个前台（表面可见的内容，例如shell提示符）和一个后台（隐藏在表层下面的内容）。</p> <p><strong>要想在程序启动时让程序在后台运行，可以在命令后面加上和字符（&amp;）来实现。</strong></p> <h3 id="jobs-查看当前终端后台运行的任务"><a href="#jobs-查看当前终端后台运行的任务" class="header-anchor">#</a> <code>jobs</code>-查看当前终端后台运行的任务</h3> <p>为了演示如何使用<code>jobs</code>命令查看当前终端后台运行的任务，我们先使<code>top</code>命令在后台运行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">top</span> <span class="token operator">&amp;</span>
</code></pre></div><p>此时，返回输出结果</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">22</span>
</code></pre></div><p>这个信息是shell的一个称为作业控制的特性表现，shell这条信息表明已经启动的作业编号为1（[1]），其对应的PID是22。若执行<code>ps</code>命令，可以查看到当前运行的进程。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>  PID TTY          TIME CMD
    <span class="token number">3</span> tty1     00:00:00 init
    <span class="token number">4</span> tty1     00:00:00 <span class="token function">bash</span>
   <span class="token number">22</span> tty1     00:00:00 <span class="token function">top</span>
   <span class="token number">23</span> tty1     00:00:00 <span class="token function">ps</span>

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">top</span>
</code></pre></div><h3 id="fg-让进程回到前台运行"><a href="#fg-让进程回到前台运行" class="header-anchor">#</a> <code>fg</code>-让进程回到前台运行</h3> <p>后台运行的进程不会受到任何键盘输入的影响，包括试图用来中断它的Ctrl-C组合键，要想使得进程返回到前台运行，可以使用<code>fg</code>命令来实现。</p> <p><strong>我们可以在<code>fg</code>命令后面加上百分比符号和作业编号（称为jobspec选项）来实现这个功能。<strong>如果后台只有一个任务，则可以不带</strong>jobspec</strong>选项。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">fg</span> %1
</code></pre></div><p>这里，由于<code>top</code>命令在后台很快就自动结束了。所以会报错。</p> <h3 id="ctrl-z-停止-暂停-进程"><a href="#ctrl-z-停止-暂停-进程" class="header-anchor">#</a> <code>Ctrl-Z</code>-停止（暂停）进程</h3> <p>如果我们只是想要暂停进程，而不是终止进程，那么，我们就可以按<code>Ctrl-Z</code>暂停进程。</p> <h3 id="bg-让进程移到后台运行"><a href="#bg-让进程移到后台运行" class="header-anchor">#</a> <code>bg</code>-让进程移到后台运行</h3> <p>若我们暂停了进程运行，或者在程序启动时没有让进程在后台运行，可以使用<code>bg</code>命令将进程移到后台运行。当然，暂停了的进程也可以使用<code>fg</code>命令让其在前台运行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">bg</span> %1
</code></pre></div><h3 id="kill-发送信号到进程"><a href="#kill-发送信号到进程" class="header-anchor">#</a> <code>kill</code>-发送信号到进程</h3> <p><strong><code>kill</code>命令通常用来“杀死”（终止）进程，它可以用来终止运行不正常的程序。</strong></p> <p>事实上，<code>kill</code>命令是用来给进程发信号。信号是操作系统和程序间通信的多种方式之一。在使用Ctrl-C和Ctrl-Z时已经见识过信号的作用。</p> <ul><li>当按下Ctrl-C组合键的情况下，它将发送一个INT（中断）信号。</li> <li>当按下Ctrl-Z组合键的情况下，它将发送一个TSTP（终端暂停）信号。</li></ul> <p>反过来，程序“侦听”信号，而且在接收到信号的时候按照它们的指示进行操作。</p> <p>kill最常用的语法格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">kill</span> <span class="token punctuation">[</span>-signal<span class="token punctuation">]</span> PID
</code></pre></div><p>其中，signal代表的信号编号。<strong>如果命令行中没有指定信号编号，那么默认将发送TERM（终止）信号，</strong> 下面是<code>kill</code>命令最常用来发送的信号。</p> <h3 id="kill命令最常用的发送信号"><a href="#kill命令最常用的发送信号" class="header-anchor">#</a> <code>Kill</code>命令最常用的发送信号</h3> <table><thead><tr><th style="text-align:center;">信号编号</th> <th style="text-align:center;">信号名</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">HUP</td> <td style="text-align:center;">挂起信号，当一个后台进程接收到该信号时，它将重启并且重新读取它的配置文件</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">INT</td> <td style="text-align:center;">中断信号，执行效果和在终端按下Ctrl-C键的效果一样，用来终止一个程序</td></tr> <tr><td style="text-align:center;">9</td> <td style="text-align:center;">KILL</td> <td style="text-align:center;">杀死信号，KILL信号不会被真正意义上地被发送到目标程序，而是内核立即终止该程序。<strong>当进程以这种方式被终止时，它将没有机会对它自己进行“清理”或者对当前工作进行保存。KILL信号只能当作其它的终端信号都执行失败的情况。</strong></td></tr> <tr><td style="text-align:center;">15</td> <td style="text-align:center;">TERM</td> <td style="text-align:center;">终止信号，kill默认发送的信号类型。如果程序有足够“活力”来接收信号，那么它将被终止。</td></tr> <tr><td style="text-align:center;">18</td> <td style="text-align:center;">CONT</td> <td style="text-align:center;">继续运行信号，恢复之前接受了STOP信号的进程</td></tr> <tr><td style="text-align:center;">19</td> <td style="text-align:center;">STOP</td> <td style="text-align:center;">暂停信号，该信号将使进程暂停，而不是终止。<strong>和KILL信号类似，该信号不会被发送给目标进程。</strong></td></tr></tbody></table> <h3 id="系统常用的其它信号"><a href="#系统常用的其它信号" class="header-anchor">#</a> 系统常用的其它信号</h3> <p>在Linux系统中，还存在一些经常被系统使用的信号。</p> <table><thead><tr><th style="text-align:center;">信号编号</th> <th style="text-align:center;">信号名</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">3</td> <td style="text-align:center;">QUIT</td> <td style="text-align:center;">退出信号</td></tr> <tr><td style="text-align:center;">11</td> <td style="text-align:center;">SEGV</td> <td style="text-align:center;">段错误信号，若程序试图在没有写权限的空间执行写操作，那么系统将发送该信号</td></tr> <tr><td style="text-align:center;">20</td> <td style="text-align:center;">TSTP</td> <td style="text-align:center;">终端暂停信号，在按下Ctrl-Z组合键时将发出该信号，TSTP信号由程序接收，并可以被程序所忽略</td></tr> <tr><td style="text-align:center;">28</td> <td style="text-align:center;">WINCH</td> <td style="text-align:center;">窗口改变信号。当窗口大小改变时，系统将发送该信号。类似<code>top</code>和<code>less</code>的一些程序将会对该信号做出响应。</td></tr></tbody></table> <p>如果想要查看更多的信号，使用如下命令将显示完整的信号列表。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">kill</span> <span class="token parameter variable">-l</span>
</code></pre></div><h3 id="killall-发送信号给多个进程"><a href="#killall-发送信号给多个进程" class="header-anchor">#</a> <code>killall</code>-发送信号给多个进程</h3> <p>通过使用<code>killall</code>命令，我们可以给指定程序或者指定用户名的多个进程发送信号。一般语法格式如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">killall</span> <span class="token punctuation">[</span>-u user<span class="token punctuation">]</span> <span class="token punctuation">[</span>-signal<span class="token punctuation">]</span> name<span class="token punctuation">..</span>.
</code></pre></div><p>其中name是程序名称，<code>...</code>代表若有多个程序，程序名之间用多个空格分隔。</p> <p><strong>记住，和<code>kill</code>命令一样，你必须具有超级用户权限，才能够使用<code>killall</code>命令给不属于自己的进程发送信号。</strong></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">LastUpdated:</span> <span class="time">3/11/2021, 7:31:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/mr-muggle/操作系统/Linux/Linux-env-config.html">
        Linux入门-Linux环境与配置
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> <div class="page-anchor"><div class="ant-space ant-space-vertical" style="width:100%;"><div class="ant-space-item"><div class="page-anchor-offset"><div><div class="ant-anchor-wrapper" style="max-height:100vh;"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a href="#前言" title="前言" class="ant-anchor-link-title">前言</a></div><div class="ant-anchor-link"><a href="#第一章-初探linux操作系统" title="第一章 初探Linux操作系统" class="ant-anchor-link-title">第一章 初探Linux操作系统</a><div class="ant-anchor-link"><a href="#date-显示当前系统日期和时间" title="date-显示当前系统日期和时间" class="ant-anchor-link-title">date-显示当前系统日期和时间</a></div><div class="ant-anchor-link"><a href="#cal-显示当前系统的日历" title="cal-显示当前系统的日历" class="ant-anchor-link-title">cal-显示当前系统的日历</a></div><div class="ant-anchor-link"><a href="#df-查看磁盘空间" title="df-查看磁盘空间" class="ant-anchor-link-title">df-查看磁盘空间</a></div><div class="ant-anchor-link"><a href="#free-查看linux可用内存" title="free-查看Linux可用内存" class="ant-anchor-link-title">free-查看Linux可用内存</a></div></div><div class="ant-anchor-link"><a href="#第二章-认识linux文件系统树" title="第二章 认识Linux文件系统树" class="ant-anchor-link-title">第二章 认识Linux文件系统树</a><div class="ant-anchor-link"><a href="#pwd-显示当前工作目录" title="pwd-显示当前工作目录" class="ant-anchor-link-title">pwd-显示当前工作目录</a></div><div class="ant-anchor-link"><a href="#ls-列出目录内容" title="ls-列出目录内容" class="ant-anchor-link-title">ls-列出目录内容</a></div><div class="ant-anchor-link"><a href="#cd-更改当前工作目录" title="cd-更改当前工作目录" class="ant-anchor-link-title">cd-更改当前工作目录</a></div><div class="ant-anchor-link"><a href="#cd命令常用快捷方式" title="cd命令常用快捷方式" class="ant-anchor-link-title">cd命令常用快捷方式</a></div><div class="ant-anchor-link"><a href="#文件名命名规则说明" title="文件名命名规则说明" class="ant-anchor-link-title">文件名命名规则说明</a></div><div class="ant-anchor-link"><a href="#linux命令选项和参数" title="Linux命令选项和参数" class="ant-anchor-link-title">Linux命令选项和参数</a></div></div><div class="ant-anchor-link"><a href="#第三章-linux系统" title="第三章 Linux系统" class="ant-anchor-link-title">第三章 Linux系统</a><div class="ant-anchor-link"><a href="#深入了解ls命令" title="深入了解ls命令" class="ant-anchor-link-title">深入了解ls命令</a></div><div class="ant-anchor-link"><a href="#file-命令确定文件类型" title="file-命令确定文件类型" class="ant-anchor-link-title">file-命令确定文件类型</a></div><div class="ant-anchor-link"><a href="#less-使用命令查看文本内容" title="less-使用命令查看文本内容" class="ant-anchor-link-title">less-使用命令查看文本内容</a></div><div class="ant-anchor-link"><a href="#linux系统重要目录" title="Linux系统重要目录" class="ant-anchor-link-title">Linux系统重要目录</a></div></div><div class="ant-anchor-link"><a href="#第四章-操作目录和文件" title="第四章 操作目录和文件" class="ant-anchor-link-title">第四章 操作目录和文件</a><div class="ant-anchor-link"><a href="#mkdir-创建目录" title="mkdir-创建目录" class="ant-anchor-link-title">mkdir-创建目录</a></div><div class="ant-anchor-link"><a href="#cp-复制文件和目录" title="cp-复制文件和目录" class="ant-anchor-link-title">cp-复制文件和目录</a></div><div class="ant-anchor-link"><a href="#mv-移动和重命名文件" title="mv-移动和重命名文件" class="ant-anchor-link-title">mv-移动和重命名文件</a></div><div class="ant-anchor-link"><a href="#rm-删除文件或目录" title="rm-删除文件或目录" class="ant-anchor-link-title">rm-删除文件或目录</a></div><div class="ant-anchor-link"><a href="#ln-创建软硬链接" title="ln-创建软硬链接" class="ant-anchor-link-title">ln-创建软硬链接</a></div><div class="ant-anchor-link"><a href="#linux操作实践" title="Linux操作实践" class="ant-anchor-link-title">Linux操作实践</a></div></div><div class="ant-anchor-link"><a href="#第五章-命令的使用" title="第五章 命令的使用" class="ant-anchor-link-title">第五章 命令的使用</a><div class="ant-anchor-link"><a href="#命令的含义" title="命令的含义" class="ant-anchor-link-title">命令的含义</a></div><div class="ant-anchor-link"><a href="#type-显示命令的类型" title="type-显示命令的类型" class="ant-anchor-link-title">type-显示命令的类型</a></div><div class="ant-anchor-link"><a href="#which-显示可执行程序的位置" title="which-显示可执行程序的位置" class="ant-anchor-link-title">which-显示可执行程序的位置</a></div><div class="ant-anchor-link"><a href="#help-获取shell内置命令的帮助文档" title="help-获取shell内置命令的帮助文档" class="ant-anchor-link-title">help-获取shell内置命令的帮助文档</a></div><div class="ant-anchor-link"><a href="#help选项-显示可执行命令的使用信息" title="help选项-显示可执行命令的使用信息" class="ant-anchor-link-title">help选项-显示可执行命令的使用信息</a></div><div class="ant-anchor-link"><a href="#man-显示程序的手册页" title="man-显示程序的手册页" class="ant-anchor-link-title">man-显示程序的手册页</a></div><div class="ant-anchor-link"><a href="#apropos-搜索合适的命令" title="apropos-搜索合适的命令" class="ant-anchor-link-title">apropos-搜索合适的命令</a></div><div class="ant-anchor-link"><a href="#whatis-显示命令的简要描述" title="whatis-显示命令的简要描述" class="ant-anchor-link-title">whatis-显示命令的简要描述</a></div><div class="ant-anchor-link"><a href="#info-显示程序的info条目" title="info-显示程序的info条目" class="ant-anchor-link-title">info-显示程序的info条目</a></div></div><div class="ant-anchor-link"><a href="#定义和删除别名" title="定义和删除别名" class="ant-anchor-link-title">定义和删除别名</a><div class="ant-anchor-link"><a href="#alias-查看与自定义命令别名" title="alias-查看与自定义命令别名" class="ant-anchor-link-title">alias-查看与自定义命令别名</a></div><div class="ant-anchor-link"><a href="#unalias-删除命令别名" title="unalias-删除命令别名" class="ant-anchor-link-title">unalias-删除命令别名</a></div></div><div class="ant-anchor-link"><a href="#第六章-重定向" title="第六章 重定向" class="ant-anchor-link-title">第六章 重定向</a><div class="ant-anchor-link"><a href="#标准输入、输出和标准错误" title="标准输入、输出和标准错误" class="ant-anchor-link-title">标准输入、输出和标准错误</a></div><div class="ant-anchor-link"><a href="#i-o重定向-标准输出重定向" title="I/O重定向-标准输出重定向" class="ant-anchor-link-title">I/O重定向-标准输出重定向</a></div><div class="ant-anchor-link"><a href="#i-o重定向-标准错误重定向" title="I/O重定向-标准错误重定向" class="ant-anchor-link-title">I/O重定向-标准错误重定向</a></div><div class="ant-anchor-link"><a href="#标准输出、标准错误重定向输出到同一个文件" title="标准输出、标准错误重定向输出到同一个文件" class="ant-anchor-link-title">标准输出、标准错误重定向输出到同一个文件</a></div><div class="ant-anchor-link"><a href="#位桶-抑制或隐藏不想要的输出" title="位桶-抑制或隐藏不想要的输出" class="ant-anchor-link-title">位桶-抑制或隐藏不想要的输出</a></div><div class="ant-anchor-link"><a href="#cat-合并、查看、创建文件以及重定向" title="cat-合并、查看、创建文件以及重定向" class="ant-anchor-link-title">cat-合并、查看、创建文件以及重定向</a></div><div class="ant-anchor-link"><a href="#管道操作符-过滤器" title="|-管道操作符 &amp;&amp; 过滤器" class="ant-anchor-link-title">|-管道操作符 &amp;&amp; 过滤器</a></div><div class="ant-anchor-link"><a href="#uniq-报告或忽略文件中重复的行" title="uniq-报告或忽略文件中重复的行" class="ant-anchor-link-title">uniq-报告或忽略文件中重复的行</a></div><div class="ant-anchor-link"><a href="#wc-打印行数、字数和字节数" title="wc-打印行数、字数和字节数" class="ant-anchor-link-title">wc-打印行数、字数和字节数</a></div><div class="ant-anchor-link"><a href="#grep-打印文本中的匹配行" title="grep-打印文本中的匹配行" class="ant-anchor-link-title">grep-打印文本中的匹配行</a></div><div class="ant-anchor-link"><a href="#head-tail-打印文件的开头部分-结尾部分" title="head/tail-打印文件的开头部分/结尾部分" class="ant-anchor-link-title">head/tail-打印文件的开头部分/结尾部分</a></div><div class="ant-anchor-link"><a href="#tee-从标准输入读取并输出到标准输出和文件" title="tee-从标准输入读取并输出到标准输出和文件" class="ant-anchor-link-title">tee-从标准输入读取并输出到标准输出和文件</a></div></div><div class="ant-anchor-link"><a href="#第七章-透过shell看世界" title="第七章 透过Shell看世界" class="ant-anchor-link-title">第七章 透过Shell看世界</a><div class="ant-anchor-link"><a href="#路径名扩展" title="路径名扩展" class="ant-anchor-link-title">路径名扩展</a></div><div class="ant-anchor-link"><a href="#波浪线扩展" title="波浪线扩展" class="ant-anchor-link-title">波浪线扩展</a></div><div class="ant-anchor-link"><a href="#算术扩展" title="算术扩展" class="ant-anchor-link-title">算术扩展</a></div><div class="ant-anchor-link"><a href="#花括号扩展" title="花括号扩展" class="ant-anchor-link-title">花括号扩展</a></div><div class="ant-anchor-link"><a href="#参数扩展" title="参数扩展" class="ant-anchor-link-title">参数扩展</a></div><div class="ant-anchor-link"><a href="#命令替换" title="命令替换" class="ant-anchor-link-title">命令替换</a></div><div class="ant-anchor-link"><a href="#各种类型的引用" title="各种类型的引用" class="ant-anchor-link-title">各种类型的引用</a></div></div><div class="ant-anchor-link"><a href="#第八章-高级键盘技巧" title="第八章 高级键盘技巧" class="ant-anchor-link-title">第八章 高级键盘技巧</a><div class="ant-anchor-link"><a href="#光标移动快捷键" title="光标移动快捷键" class="ant-anchor-link-title">光标移动快捷键</a></div><div class="ant-anchor-link"><a href="#修改文本快捷键" title="修改文本快捷键" class="ant-anchor-link-title">修改文本快捷键</a></div><div class="ant-anchor-link"><a href="#剪切、粘贴文本快捷键" title="剪切、粘贴文本快捷键" class="ant-anchor-link-title">剪切、粘贴文本快捷键</a></div><div class="ant-anchor-link"><a href="#tab键-自动补齐" title="Tab键-自动补齐" class="ant-anchor-link-title">Tab键-自动补齐</a></div><div class="ant-anchor-link"><a href="#history-搜索历史" title="history-搜索历史" class="ant-anchor-link-title">history-搜索历史</a></div><div class="ant-anchor-link"><a href="#历史记录扩展" title="历史记录扩展" class="ant-anchor-link-title">历史记录扩展</a></div></div><div class="ant-anchor-link"><a href="#第九章-权限管理" title="第九章 权限管理" class="ant-anchor-link-title">第九章 权限管理</a><div class="ant-anchor-link"><a href="#所有者、组成员和其他所有用户" title="所有者、组成员和其他所有用户" class="ant-anchor-link-title">所有者、组成员和其他所有用户</a></div><div class="ant-anchor-link"><a href="#id-显示用户身份标识" title="id-显示用户身份标识" class="ant-anchor-link-title">id-显示用户身份标识</a></div><div class="ant-anchor-link"><a href="#读取、写入和执行权限" title="读取、写入和执行权限" class="ant-anchor-link-title">读取、写入和执行权限</a></div><div class="ant-anchor-link"><a href="#chmod-更改文件模式-权限" title="chmod-更改文件模式（权限）" class="ant-anchor-link-title">chmod-更改文件模式（权限）</a></div><div class="ant-anchor-link"><a href="#su-以其他用户和组id的身份来运行shell" title="su-以其他用户和组ID的身份来运行shell" class="ant-anchor-link-title">su-以其他用户和组ID的身份来运行shell</a></div><div class="ant-anchor-link"><a href="#su和sudo命令的几点区别" title="su和sudo命令的几点区别" class="ant-anchor-link-title">su和sudo命令的几点区别</a></div><div class="ant-anchor-link"><a href="#chown-更改文件所有者和所属群组" title="chown-更改文件所有者和所属群组" class="ant-anchor-link-title">chown-更改文件所有者和所属群组</a></div><div class="ant-anchor-link"><a href="#passwd-修改用户密码" title="passwd-修改用户密码" class="ant-anchor-link-title">passwd-修改用户密码</a></div></div><div class="ant-anchor-link"><a href="#第十章-进程信息查看与进程控制" title="第十章 进程信息查看与进程控制" class="ant-anchor-link-title">第十章 进程信息查看与进程控制</a><div class="ant-anchor-link"><a href="#进程的工作方式" title="进程的工作方式" class="ant-anchor-link-title">进程的工作方式</a></div><div class="ant-anchor-link"><a href="#ps-显示当前所有进程的运行情况" title="ps-显示当前所有进程的运行情况" class="ant-anchor-link-title">ps-显示当前所有进程的运行情况</a></div><div class="ant-anchor-link"><a href="#top-动态查看进程信息" title="top-动态查看进程信息" class="ant-anchor-link-title">top-动态查看进程信息</a></div><div class="ant-anchor-link"><a href="#ctrl-c-中断进程" title="Ctrl-C-中断进程" class="ant-anchor-link-title">Ctrl-C-中断进程</a></div><div class="ant-anchor-link"><a href="#使进程在后台运行" title="&amp;-使进程在后台运行" class="ant-anchor-link-title">&amp;-使进程在后台运行</a></div><div class="ant-anchor-link"><a href="#jobs-查看当前终端后台运行的任务" title="jobs-查看当前终端后台运行的任务" class="ant-anchor-link-title">jobs-查看当前终端后台运行的任务</a></div><div class="ant-anchor-link"><a href="#fg-让进程回到前台运行" title="fg-让进程回到前台运行" class="ant-anchor-link-title">fg-让进程回到前台运行</a></div><div class="ant-anchor-link"><a href="#ctrl-z-停止-暂停-进程" title="Ctrl-Z-停止（暂停）进程" class="ant-anchor-link-title">Ctrl-Z-停止（暂停）进程</a></div><div class="ant-anchor-link"><a href="#bg-让进程移到后台运行" title="bg-让进程移到后台运行" class="ant-anchor-link-title">bg-让进程移到后台运行</a></div><div class="ant-anchor-link"><a href="#kill-发送信号到进程" title="kill-发送信号到进程" class="ant-anchor-link-title">kill-发送信号到进程</a></div><div class="ant-anchor-link"><a href="#kill命令最常用的发送信号" title="Kill命令最常用的发送信号" class="ant-anchor-link-title">Kill命令最常用的发送信号</a></div><div class="ant-anchor-link"><a href="#系统常用的其它信号" title="系统常用的其它信号" class="ant-anchor-link-title">系统常用的其它信号</a></div><div class="ant-anchor-link"><a href="#killall-发送信号给多个进程" title="killall-发送信号给多个进程" class="ant-anchor-link-title">killall-发送信号给多个进程</a></div></div></div></div></div></div></div></div></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/mr-muggle/assets/js/app.03b0f33a.js" defer></script><script src="/mr-muggle/assets/js/2.c49e4524.js" defer></script><script src="/mr-muggle/assets/js/16.88f016bf.js" defer></script>
  </body>
</html>